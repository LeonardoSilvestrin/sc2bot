===== EXPORT META =====
generated_at_utc: 2026-02-27T01:50:48.990809+00:00
repo_root: C:\Users\Asus\Documents\projetos\sc2bot\ares\ares-sc2-bot-template
hardcoded_bot_policy:
- bot/ares_wrapper: STRUCTURE_ONLY
- bot/intel: FULL
- bot/mind: FULL
- bot/planners: FULL
- bot/sensors: FULL
- bot/tasks: FULL
- bot/<top-level *.py>: FULL

===== ROOT PROMPT =====
Voce e meu parceiro tecnico para evoluir um bot de StarCraft II em Python.
Vou enviar um dump do repositorio gerado por _prompt/export_prompt_root.py.

CONTEXTO ATUAL (NOMES VALIDOS)
- Planners ativos: defense_planner, intel_planner, spending_planner, production_planner, housekeeping_planner, depot_control_planner.
- Tasks macro ativas: spending_tick, production_tick, scv_housekeeping_task.
- Task separada de wall/depot: control_depots_task.
- Legacy removido: macro_planner monolitico nao e referencia de verdade.

PRIORIDADES
1. Consistencia de contrato (Task, Planner, Proposal, Ego, Body, Awareness, Attention, Self)
2. Diagnostico por evidencias (logs e codigo atual)
3. Mudanca minima com impacto claro

REGRAS
- Nao invente contratos, campos, enums ou assinaturas fora do dump.
- Fonte da verdade: somente esta conversa e os arquivos enviados.
- Se faltar contexto, peca somente o trecho minimo necessario.

MODO DE RESPOSTA
- [PATCH]: mudanca pequena, resposta curta.
- [FILE]: um arquivo inteiro.
- [MULTI]: varios arquivos inteiros.
Se eu nao indicar modo, use [PATCH].

ENTREGA
- Em [FILE] e [MULTI], cada .py deve comecar com comentario de caminho.
  Exemplo: # bot/mind/ego.py

COMPORTAMENTO ESPERADO DO AGENTE
1. Ler o dump e validar contratos atuais
2. Apontar inconsistencias criticas primeiro
3. Propor/codar correcao com menor risco
4. Sugerir teste funcional objetivo (logs esperados + efeito esperado)

FORMATO DO DUMP
- PROJECT TREE (estrutura completa)
- BOT SNAPSHOT
  - algumas pastas com conteudo completo
  - outras apenas com lista de arquivos (structure-only)
- ROOT CONFIGS
- opcional: LOG SUMMARY

NOTA
O exportador usa selecao hardcoded por pasta do bot.
Se uma pasta estiver em structure-only, use os caminhos listados para pedir apenas os arquivos necessarios.

===== PROJECT TREE =====
.
|-- .github
|   `-- workflows
|       |-- build_windows_exe.yaml
|       `-- ladder_zip.yml
|-- _docs
|   `-- attention_awareness.md
|-- _prompt
|   |-- export_prompt_root.py
|   |-- root.txt
|   `-- view_devlog.py
|-- bot
|   |-- ares_wrapper
|   |   |-- __init__.py
|   |   |-- map.py
|   |   `-- roles.py
|   |-- intel
|   |   |-- enemy_build_intel.py
|   |   `-- my_army_composition_intel.py
|   |-- mind
|   |   |-- __init__.py
|   |   |-- attention.py
|   |   |-- awareness.py
|   |   |-- body.py
|   |   |-- ego.py
|   |   `-- self.py
|   |-- planners
|   |   |-- defense_planner.py
|   |   |-- depot_control_planner.py
|   |   |-- housekeeping_planner.py
|   |   |-- intel_planner.py
|   |   |-- production_planner.py
|   |   |-- proposals.py
|   |   `-- spending_planner.py
|   |-- sensors
|   |   |-- __init__.py
|   |   |-- combat_sensor.py
|   |   |-- economy_sensor.py
|   |   |-- enemy_build_sensor.py
|   |   |-- macro_sensor.py
|   |   |-- orbital_sensor.py
|   |   `-- threat_sensor.py
|   |-- tasks
|   |   |-- macro
|   |   |   |-- __init__.py
|   |   |   |-- macro_task.py
|   |   |   |-- opening.py
|   |   |   |-- production_tick.py
|   |   |   |-- scv_housekeeping_task.py
|   |   |   `-- spending_tick.py
|   |   |-- __init__.py
|   |   |-- base_task.py
|   |   |-- control_depots_task.py
|   |   |-- defend_task.py
|   |   |-- reaper_scout_task.py
|   |   |-- scan_task.py
|   |   `-- scout_task.py
|   |-- __init__.py
|   |-- devlog.py
|   `-- main.py
|-- logs
|   |-- devlog_20260227_014303
|   |   |-- components
|   |   |   |-- attention.full.jsonl
|   |   |   |-- attention.jsonl
|   |   |   |-- awareness.full.jsonl
|   |   |   |-- awareness.jsonl
|   |   |   |-- build_order.runner.jsonl
|   |   |   |-- defense.jsonl
|   |   |   |-- ego.jsonl
|   |   |   |-- intel.jsonl
|   |   |   |-- macro.jsonl
|   |   |   |-- planner.defense_planner.jsonl
|   |   |   |-- planner.depot_control_planner.jsonl
|   |   |   |-- planner.housekeeping_planner.jsonl
|   |   |   |-- planner.intel_planner.jsonl
|   |   |   |-- planner.production_planner.jsonl
|   |   |   |-- planner.spending_planner.jsonl
|   |   |   `-- runtime.jsonl
|   |   |-- ticks
|   |   |   |-- attention.jsonl
|   |   |   |-- defense.jsonl
|   |   |   `-- intel.jsonl
|   |   |-- attention.jsonl
|   |   |-- awareness.jsonl
|   |   |-- defense.jsonl
|   |   |-- ego.jsonl
|   |   |-- intel.jsonl
|   |   |-- macro.jsonl
|   |   |-- planner.jsonl
|   |   `-- runtime.jsonl
|   `-- devlog_20260227_014303.jsonl
|-- scripts
|   |-- create_ladder_zip.py
|   |-- create_pyinstaller_exe.py
|   |-- update_ares.py
|   `-- upload_to_ai_arena.py
|-- .env
|-- .gitignore
|-- .gitmodules
|-- ARCHITECTURE.md
|-- config.yml
|-- ladder.py
|-- LICENSE
|-- poetry.lock
|-- protoss_builds.yml
|-- pyproject.toml
|-- README.md
|-- run.py
`-- terran_builds.yml

===== BOT SNAPSHOT =====
## bot/<top-level *.py> (full)
# bot/__init__.py
```python

```
# bot/devlog.py
```python
# bot/devlog.py
from __future__ import annotations

import json
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Dict, Optional


@dataclass
class DevLogger:
    """
    JSONL logger (1 evento por linha).

    Estrutura de saida:
    - consolidado: logs/<filename>
    - por modulo: logs/<run_stem>/<module>.jsonl
    - ticks por modulo: logs/<run_stem>/ticks/<module>.jsonl
    """

    log_dir: str = "logs"
    filename: Optional[str] = None
    enabled: bool = True
    split_by_module: bool = True

    def _ensure_dir(self) -> None:
        os.makedirs(self.log_dir, exist_ok=True)

    def set_file(self, filename: str) -> None:
        self.filename = filename

    @staticmethod
    def _module_from_event(event: str, meta: Optional[Dict[str, Any]] = None) -> str:
        if isinstance(meta, dict):
            mod = meta.get("module")
            if isinstance(mod, str) and mod.strip():
                return mod.strip().lower()

        ev = str(event or "").strip().lower()
        if ev.startswith("macro_"):
            return "macro"
        if ev.startswith("defend_"):
            return "defense"
        if ev.startswith("reaper_") or ev.startswith("scout_") or ev.startswith("scan_") or ev.startswith("intel_"):
            return "intel"
        if ev.startswith("mission_"):
            return "ego"
        if ev.startswith("runtime_") or ev.startswith("game_"):
            return "runtime"
        return "misc"

    @staticmethod
    def _component_from_event(event: str, meta: Optional[Dict[str, Any]] = None) -> str:
        if isinstance(meta, dict):
            comp = meta.get("component")
            if isinstance(comp, str) and comp.strip():
                return comp.strip().lower()
        return DevLogger._module_from_event(event, meta)

    @staticmethod
    def _safe_stem(filename: str) -> str:
        stem, _ = os.path.splitext(str(filename))
        return stem or "devlog"

    @staticmethod
    def _write_jsonl(path: str, row: Dict[str, Any]) -> None:
        with open(path, "a", encoding="utf-8") as f:
            f.write(json.dumps(row, ensure_ascii=False) + "\n")

    def emit(
        self,
        event: str,
        payload: Optional[Dict[str, Any]] = None,
        *,
        meta: Optional[Dict[str, Any]] = None,
    ) -> None:
        if not self.enabled:
            return
        if not self.filename:
            # Se esquecer de setar, nao explode o jogo.
            return

        self._ensure_dir()

        module = self._module_from_event(event, meta)
        component = self._component_from_event(event, meta)
        row = {
            "ts_utc": datetime.now(timezone.utc).isoformat(),
            "event": event,
            "module": module,
            "component": component,
            "payload": payload or {},
            "meta": meta or {},
        }

        consolidated_path = os.path.join(self.log_dir, self.filename)
        try:
            # backward-compatible consolidated log
            self._write_jsonl(consolidated_path, row)

            if self.split_by_module:
                run_stem = self._safe_stem(self.filename)
                split_dir = os.path.join(self.log_dir, run_stem)
                os.makedirs(split_dir, exist_ok=True)

                module_path = os.path.join(split_dir, f"{module}.jsonl")
                self._write_jsonl(module_path, row)

                components_dir = os.path.join(split_dir, "components")
                os.makedirs(components_dir, exist_ok=True)
                safe_component = component.replace("/", "_").replace("\\", "_").replace(":", "_")
                component_path = os.path.join(components_dir, f"{safe_component}.jsonl")
                self._write_jsonl(component_path, row)

                if str(event).lower().endswith("_tick"):
                    ticks_dir = os.path.join(split_dir, "ticks")
                    os.makedirs(ticks_dir, exist_ok=True)
                    ticks_path = os.path.join(ticks_dir, f"{module}.jsonl")
                    self._write_jsonl(ticks_path, row)
        except Exception:
            # logging nunca pode matar o bot
            pass
```
# bot/main.py
```python
# bot/main.py
from __future__ import annotations

from typing import Optional

from ares import AresBot
from sc2.data import Result

from bot.ares_wrapper import AresWrapper
from bot.devlog import DevLogger
from bot.mind.self import RuntimeApp


class MyBot(AresBot):
    def __init__(self, game_step_override: Optional[int] = None, *, debug: bool = True):
        super().__init__(game_step_override)
        self.debug = debug

        # logger pode ficar aqui (infra), mas runtime decide como usar
        self.log = DevLogger(enabled=True)

        # wrapper do engine (opcional ficar aqui; pode migrar pro runtime depois)
        self.ares = AresWrapper(self)

        # runtime é a única "inteligência" conectada ao main
        self.rt = RuntimeApp.build(log=self.log, debug=debug)

    async def on_start(self) -> None:
        await super().on_start()

        # ensure DevLogger has a filename; otherwise emit() is a no-op
        if self.log and not getattr(self.log, "filename", None):
            from datetime import datetime, timezone
            self.log.set_file(f"devlog_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.jsonl")

        await self.rt.on_start(self)

    async def on_step(self, iteration: int) -> None:
        await super().on_step(iteration)
        await self.rt.on_step(self, iteration=iteration)

    async def on_end(self, game_result: Result) -> None:
        await super().on_end(game_result)
        await self.rt.on_end(self, game_result=game_result)
```
## bot/ares_wrapper (structure-only)
- bot/ares_wrapper/__init__.py
- bot/ares_wrapper/map.py
- bot/ares_wrapper/roles.py

## bot/intel (full)
# bot/intel/enemy_build_intel.py
```python
# bot/intel/enemy_build_intel.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Tuple

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.mind.awareness import Awareness, K
from bot.mind.attention import Attention


@dataclass(frozen=True)
class EnemyBuildIntelConfig:
    """
    MVP heuristic config.
    You can tune later without changing contract.
    """
    ttl_s: float = 12.0

    # timing thresholds
    early_s: float = 210.0     # ~3:30 window for "early aggression" classification
    greedy_s: float = 165.0    # ~2:45 window for "fast expand" classification

    # aggression signals
    rush_units_near_bases: int = 6
    rush_confidence_min: float = 0.65


def _count_enemy_bases(enemy_structures: Dict[U, int]) -> int:
    # Townhalls by race (visible only)
    return int(
        enemy_structures.get(U.HATCHERY, 0)
        + enemy_structures.get(U.LAIR, 0)
        + enemy_structures.get(U.HIVE, 0)
        + enemy_structures.get(U.NEXUS, 0)
        + enemy_structures.get(U.COMMANDCENTER, 0)
        + enemy_structures.get(U.ORBITALCOMMAND, 0)
        + enemy_structures.get(U.PLANETARYFORTRESS, 0)
    )


def _sum_units(enemy_units: Dict[U, int], types: Tuple[U, ...]) -> int:
    return int(sum(int(enemy_units.get(t, 0)) for t in types))


def derive_enemy_build_intel(
    bot,
    *,
    awareness: Awareness,
    attention: Attention,
    now: float,
    cfg: EnemyBuildIntelConfig = EnemyBuildIntelConfig(),
) -> None:
    """
    EnemyBuildIntel (inference -> Awareness):
      - reads Attention.enemy_build (tick facts)
      - infers enemy opening: GREEDY / NORMAL / AGGRESSIVE
      - writes to Awareness with TTL (belief/state, not tick fact)

    Rule: may write to Awareness; must not issue commands.
    """
    eb = attention.enemy_build
    enemy_units: Dict[U, int] = eb.enemy_units
    enemy_structs: Dict[U, int] = eb.enemy_structures

    enemy_bases = _count_enemy_bases(enemy_structs)

    # Signals we can use right now (MVP)
    near_bases = int(attention.combat.enemy_count_near_bases)
    threatened = bool(attention.combat.threatened)

    lings = _sum_units(enemy_units, (U.ZERGLING,))
    marines = _sum_units(enemy_units, (U.MARINE,))
    reapers = _sum_units(enemy_units, (U.REAPER,))
    zealots = _sum_units(enemy_units, (U.ZEALOT,))
    adepts = _sum_units(enemy_units, (U.ADEPT,))
    stalkers = _sum_units(enemy_units, (U.STALKER,))

    early = float(now) <= float(cfg.early_s)
    greedy_window = float(now) <= float(cfg.greedy_s)

    kind = "NORMAL"
    conf = 0.40

    # Natural visibility signal (new, from sensor)
    nat_on_ground = bool(getattr(eb, "enemy_natural_on_ground", False))

    # 1) Aggressive/Rush: strong immediate combat signals near our bases early.
    if early and (near_bases >= int(cfg.rush_units_near_bases) or (threatened and near_bases >= 3)):
        kind = "AGGRESSIVE"
        conf = min(0.95, 0.55 + 0.05 * float(near_bases))
        if (lings + marines + reapers + zealots + adepts + stalkers) >= 6:
            conf = min(0.98, conf + 0.10)

    # 2) Greedy: visible fast 2nd base in a greedy timing window and not much pressure.
    # Upgraded: use natural townhall visibility if we have it.
    elif greedy_window and (nat_on_ground or enemy_bases >= 2) and near_bases <= 1 and not threatened:
        kind = "GREEDY"
        conf = 0.75

    # else NORMAL

    # First-time "we saw anything meaningful" marker (permanent).
    # This is useful for planners that want to react on first scout info.
    first_seen = awareness.mem.get(K("enemy", "opening", "first_seen_t"), now=now, default=None)
    saw_anything = (len(enemy_units) > 0) or (len(enemy_structs) > 0)
    if first_seen is None and saw_anything:
        awareness.mem.set(K("enemy", "opening", "first_seen_t"), value=float(now), now=now, ttl=None)

    signals = {
        "t": round(float(now), 2),
        "early": bool(early),
        "greedy_window": bool(greedy_window),
        "enemy_bases_visible": int(enemy_bases),
        "enemy_near_our_bases": int(near_bases),
        "threatened": bool(threatened),
        "natural_on_ground": bool(nat_on_ground),
        "natural_townhall_progress": float(getattr(eb, "enemy_natural_townhall_progress", 0.0) or 0.0),
        "natural_townhall_type": str(getattr(eb, "enemy_natural_townhall_type", None)),
        "seen_units": {
            "lings": int(lings),
            "marines": int(marines),
            "reapers": int(reapers),
            "zealots": int(zealots),
            "adepts": int(adepts),
            "stalkers": int(stalkers),
        },
        # New sensor payload for debugging + future heuristics:
        "main_units": dict(getattr(eb, "enemy_units_main", {}) or {}),
        "main_structures": dict(getattr(eb, "enemy_structures_main", {}) or {}),
        "structures_progress": dict(getattr(eb, "enemy_structures_progress", {}) or {}),
    }

    awareness.mem.set(K("enemy", "opening", "kind"), value=str(kind), now=now, ttl=float(cfg.ttl_s))
    awareness.mem.set(K("enemy", "opening", "confidence"), value=float(conf), now=now, ttl=float(cfg.ttl_s))
    awareness.mem.set(K("enemy", "opening", "signals"), value=signals, now=now, ttl=float(cfg.ttl_s))
    awareness.mem.set(K("enemy", "opening", "last_update_t"), value=float(now), now=now, ttl=None)
```
# bot/intel/my_army_composition_intel.py
```python
# =============================================================================
# bot/intel/my_army_composition_intel.py  (NEW)
# =============================================================================
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict

from bot.mind.awareness import Awareness, K
from bot.mind.attention import Attention


@dataclass(frozen=True)
class MyArmyCompositionConfig:
    """
    Strategy-level macro reference:
      - desired mode (discrete)
      - desired comp (ratios)
    This is NOT production/spending. It's the setpoint.

    Keep TTL short: consumers should treat it as "recent intent".
    """
    ttl_s: float = 25.0
    min_confidence: float = 0.55

    # Default comps (ratios sum ~= 1.0)
    comp_defensive: Dict[str, float] = None
    comp_standard: Dict[str, float] = None
    comp_punish: Dict[str, float] = None

    def __post_init__(self):
        object.__setattr__(
            self,
            "comp_defensive",
            self.comp_defensive
            or {
                "MARINE": 0.75,
                "MARAUDER": 0.20,
                "MEDIVAC": 0.05,
            },
        )
        object.__setattr__(
            self,
            "comp_standard",
            self.comp_standard
            or {
                "MARINE": 0.60,
                "MARAUDER": 0.25,
                "MEDIVAC": 0.15,
            },
        )
        object.__setattr__(
            self,
            "comp_punish",
            self.comp_punish
            or {
                "MARINE": 0.65,
                "MARAUDER": 0.15,
                "MEDIVAC": 0.20,
            },
        )


def _normalize(comp: Dict[str, float]) -> Dict[str, float]:
    try:
        total = float(sum(float(v) for v in comp.values()))
    except Exception:
        return dict(comp)
    if total <= 0:
        return dict(comp)
    return {str(k): float(v) / total for k, v in comp.items()}


def derive_my_army_composition_intel(
    *,
    awareness: Awareness,
    attention: Attention,
    now: float,
    cfg: MyArmyCompositionConfig = MyArmyCompositionConfig(),
) -> None:
    """
    Reads enemy opening belief from Awareness, emits desired mode+comp into Awareness.

    Writes:
      - macro:desired:mode
      - macro:desired:comp
      - macro:desired:last_update_t
    """
    enemy_kind = awareness.mem.get(K("enemy", "opening", "kind"), now=now, default="NORMAL")
    conf = awareness.mem.get(K("enemy", "opening", "confidence"), now=now, default=0.0)

    mode = "STANDARD"
    if float(conf) >= float(cfg.min_confidence):
        if str(enemy_kind) == "AGGRESSIVE":
            mode = "DEFENSIVE"
        elif str(enemy_kind) == "GREEDY":
            mode = "PUNISH"
        else:
            mode = "STANDARD"

    if mode == "DEFENSIVE":
        comp = _normalize(dict(cfg.comp_defensive))
    elif mode == "PUNISH":
        comp = _normalize(dict(cfg.comp_punish))
    else:
        comp = _normalize(dict(cfg.comp_standard))

    awareness.mem.set(K("macro", "desired", "mode"), value=str(mode), now=now, ttl=float(cfg.ttl_s))
    awareness.mem.set(K("macro", "desired", "comp"), value=dict(comp), now=now, ttl=float(cfg.ttl_s))
    awareness.mem.set(K("macro", "desired", "last_update_t"), value=float(now), now=now, ttl=None)
```
## bot/mind (full)
# bot/mind/__init__.py
```python

```
# bot/mind/attention.py
```python
# bot/mind/attention.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

from sc2.position import Point2

from bot.mind.awareness import Awareness
from bot.sensors.threat_sensor import Threat


@dataclass(frozen=True)
class EconomySnapshot:
    units_ready: dict
    supply_left: int
    minerals: int
    gas: int


@dataclass(frozen=True)
class CombatSnapshot:
    threatened: bool
    defense_urgency: int
    threat_pos: Optional[Point2]
    enemy_count_near_bases: int


@dataclass(frozen=True)
class IntelSnapshot:
    orbital_ready_to_scan: bool
    orbital_energy: float


@dataclass(frozen=True)
class MacroSnapshot:
    opening_done: bool

    minerals: int
    vespene: int

    workers_total: int
    workers_idle: int

    bases_total: int
    bases_under_saturated: int
    bases_over_saturated: int

    prod_structures_total: int
    prod_structures_idle: int
    prod_structures_active: int

    supply_used: int
    supply_cap: int
    supply_left: int
    supply_blocked: bool


@dataclass(frozen=True)
class EnemyBuildSnapshot:
    """
    Tick facts only.

    Backwards-compatible fields:
      - enemy_units: counts of enemy units currently visible anywhere
      - enemy_structures: counts of enemy structures currently visible anywhere

    Extended fields (MVP for scouting + completion state):
      - enemy_main_pos: engine-provided enemy main (strict: enemy_start_locations[0])
      - enemy_natural_pos: inferred from expansion locations (2nd closest to enemy main)
      - enemy_units_main: counts of enemy units visible within main_radius of enemy_main_pos
      - enemy_structures_main: counts of enemy structures visible within main_radius of enemy_main_pos

      - enemy_structures_progress:
          per-structure-type stats of build_progress for currently visible enemy structures, e.g.
          {
            UnitTypeId.SPAWNINGPOOL: {
              "count": 1,
              "ready": 0,
              "incomplete": 1,
              "min": 0.42,
              "max": 0.42,
              "avg": 0.42,
            },
            ...
          }

      - enemy_natural_on_ground:
          True if a visible enemy townhall is on/near the enemy natural location.
      - enemy_natural_townhall_progress:
          max build_progress among visible townhalls near natural (None if not seen)
      - enemy_natural_townhall_type:
          type_id of the most-progressed townhall near natural (None if not seen)
    """
    enemy_units: dict
    enemy_structures: dict

    enemy_main_pos: Optional[Point2] = None
    enemy_natural_pos: Optional[Point2] = None

    enemy_units_main: dict = None
    enemy_structures_main: dict = None

    enemy_structures_progress: dict = None

    enemy_natural_on_ground: bool = False
    enemy_natural_townhall_progress: Optional[float] = None
    enemy_natural_townhall_type: Optional[object] = None  # UnitTypeId, but keep loose to avoid typing friction


@dataclass(frozen=True)
class Attention:
    """
    Tick snapshot (read-only).
    - immutable
    - derived each tick
    - history/inference belongs in Awareness
    """
    economy: EconomySnapshot
    combat: CombatSnapshot
    intel: IntelSnapshot
    macro: MacroSnapshot
    enemy_build: EnemyBuildSnapshot
    time: float = 0.0


def derive_attention(bot, *, awareness: Awareness, threat: Threat, log=None) -> Attention:
    """
    Derive tick snapshot from sensors.
    Rule: no side-effects.

    Note:
      - imports for sensors are local to avoid circular imports
        (sensors reference snapshot dataclasses from this module).
    """
    from bot.sensors.economy_sensor import derive_economy_snapshot
    from bot.sensors.combat_sensor import derive_combat_snapshot
    from bot.sensors.enemy_build_sensor import derive_enemy_build_sensor
    from bot.sensors.macro_sensor import derive_macro_snapshot
    from bot.sensors.orbital_sensor import derive_orbital_snapshot

    now = float(getattr(bot, "time", 0.0) or 0.0)

    economy = derive_economy_snapshot(bot)
    combat = derive_combat_snapshot(bot, threat=threat)
    intel = derive_orbital_snapshot(bot)
    macro = derive_macro_snapshot(bot)
    enemy_build = derive_enemy_build_sensor(bot)

    out = Attention(
        economy=economy,
        combat=combat,
        intel=intel,
        macro=macro,
        enemy_build=enemy_build,
        time=float(now),
    )
    if log is not None:
        log.emit(
            "attention_tick",
            {
                "t": round(float(now), 2),
                "threatened": bool(combat.threatened),
                "defense_urgency": int(combat.defense_urgency),
                "minerals": int(economy.minerals),
                "gas": int(economy.gas),
                "supply_left": int(economy.supply_left),
                "opening_done": bool(macro.opening_done),
            },
            meta={"module": "attention", "component": "attention"},
        )
    return out
```
# bot/mind/awareness.py
```python
# bot/mind/awareness.py
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Tuple


Key = Tuple[str, ...]


@dataclass(frozen=True)
class Fact:
    value: Any
    t: float
    confidence: float = 1.0
    ttl: Optional[float] = None


@dataclass
class MemoryStore:
    _facts: Dict[Key, Fact] = field(default_factory=dict)

    def set(
        self,
        key: Key,
        *,
        value: Any,
        now: float,
        ttl: Optional[float] = None,
        confidence: float = 1.0,
    ) -> None:
        self._facts[key] = Fact(value=value, t=float(now), confidence=float(confidence), ttl=ttl)

    def get(self, key: Key, *, now: float, default: Any = None, max_age: Optional[float] = None) -> Any:
        f = self._facts.get(key)
        if f is None:
            return default
        age = float(now) - float(f.t)
        if age < 0:
            age = 0.0
        if max_age is not None and age > float(max_age):
            return default
        if f.ttl is not None and age > float(f.ttl):
            return default
        return f.value

    def age(self, key: Key, *, now: float) -> Optional[float]:
        f = self._facts.get(key)
        if f is None:
            return None
        return max(0.0, float(now) - float(f.t))

    def is_stale(self, key: Key, *, now: float, max_age: float) -> bool:
        a = self.age(key, now=now)
        if a is None:
            return True
        return a > float(max_age)

    def has(self, key: Key, *, now: float, max_age: Optional[float] = None) -> bool:
        sentinel = object()
        return self.get(key, now=now, default=sentinel, max_age=max_age) is not sentinel

    def keys(self) -> Iterable[Key]:
        return self._facts.keys()

    def snapshot(self, *, now: float, prefix: Optional[Key] = None, max_age: Optional[float] = None) -> Dict[str, Any]:
        out: Dict[str, Any] = {}
        for k, f in self._facts.items():
            if prefix is not None and k[: len(prefix)] != prefix:
                continue
            age = max(0.0, float(now) - float(f.t))
            if max_age is not None and age > float(max_age):
                continue
            if f.ttl is not None and age > float(f.ttl):
                continue
            sk = ":".join(k)
            out[sk] = {
                "value": f.value,
                "t": round(float(f.t), 2),
                "age": round(float(age), 2),
                "ttl": f.ttl,
                "confidence": round(float(f.confidence), 2),
            }
        return out


def K(*parts: str) -> Key:
    return tuple(parts)


@dataclass
class Awareness:
    mem: MemoryStore = field(default_factory=MemoryStore)
    log: Any = None

    _events: List[Dict[str, Any]] = field(default_factory=list)
    _events_cap: int = 200

    def emit(self, name: str, *, now: float, data: Optional[Dict[str, Any]] = None) -> None:
        evt = {"t": round(float(now), 2), "name": str(name)}
        if data:
            evt["data"] = data
        self._events.append(evt)
        if len(self._events) > self._events_cap:
            self._events = self._events[-self._events_cap :]
        if self.log is not None:
            self.log.emit(
                "awareness_event",
                {"t": round(float(now), 2), "name": str(name), "data": data or {}},
                meta={"module": "awareness", "component": "awareness"},
            )

    def tail_events(self, n: int = 10) -> List[Dict[str, Any]]:
        if n <= 0:
            return []
        return self._events[-n:]

    def ops_proposal_running(self, *, proposal_id: str, now: float) -> bool:
        if not isinstance(proposal_id, str) or not proposal_id:
            raise ValueError("proposal_id must be a non-empty string")

        for k, f in self.mem._facts.items():
            if len(k) < 4:
                continue
            if k[0] != "ops" or k[1] != "mission":
                continue
            if k[-1] != "proposal_id":
                continue
            if f.value != proposal_id:
                continue

            mission_id = k[2]
            st = str(self.mem.get(K("ops", "mission", mission_id, "status"), now=now, default=""))
            if st == "RUNNING":
                return True

        return False

    # -----------------------
    # Convenience “intel” API
    # -----------------------
    _K_SCV_DISPATCHED = K("intel", "scv", "dispatched")
    _K_SCV_ARRIVED_MAIN = K("intel", "scv", "arrived_main")
    _K_SCAN_ENEMY_MAIN = K("intel", "scan", "enemy_main")
    _K_LAST_SCV_DISPATCH_AT = K("intel", "scv", "last_dispatch_at")
    _K_LAST_SCAN_AT = K("intel", "scan", "last_scan_at")

    # New: reaper scout bookkeeping
    _K_REAPER_SCOUT_DISPATCHED = K("intel", "reaper", "scout", "dispatched")
    _K_LAST_REAPER_SCOUT_AT = K("intel", "reaper", "scout", "last_dispatch_at")
    _K_REAPER_SCOUT_LAST_DONE_AT = K("intel", "reaper", "scout", "last_done_at")

    def intel_scv_dispatched(self, *, now: float) -> bool:
        return bool(self.mem.get(self._K_SCV_DISPATCHED, now=now, default=False))

    def intel_scv_arrived_main(self, *, now: float) -> bool:
        return bool(self.mem.get(self._K_SCV_ARRIVED_MAIN, now=now, default=False))

    def intel_scanned_enemy_main(self, *, now: float) -> bool:
        return bool(self.mem.get(self._K_SCAN_ENEMY_MAIN, now=now, default=False))

    def intel_last_scv_dispatch_at(self, *, now: float) -> float:
        return float(self.mem.get(self._K_LAST_SCV_DISPATCH_AT, now=now, default=0.0))

    def intel_last_scan_at(self, *, now: float) -> float:
        return float(self.mem.get(self._K_LAST_SCAN_AT, now=now, default=0.0))

    def mark_scv_dispatched(self, *, now: float) -> None:
        self.mem.set(self._K_SCV_DISPATCHED, value=True, now=now, ttl=None)
        self.mem.set(self._K_LAST_SCV_DISPATCH_AT, value=float(now), now=now, ttl=None)

    def mark_scv_arrived_main(self, *, now: float, ttl: Optional[float] = None) -> None:
        self.mem.set(self._K_SCV_ARRIVED_MAIN, value=True, now=now, ttl=ttl)

    def mark_scanned_enemy_main(self, *, now: float) -> None:
        self.mem.set(self._K_SCAN_ENEMY_MAIN, value=True, now=now, ttl=None)
        self.mem.set(self._K_LAST_SCAN_AT, value=float(now), now=now, ttl=None)

    # Reaper scout markers
    def intel_reaper_scout_dispatched(self, *, now: float) -> bool:
        return bool(self.mem.get(self._K_REAPER_SCOUT_DISPATCHED, now=now, default=False))

    def intel_last_reaper_scout_dispatch_at(self, *, now: float) -> float:
        return float(self.mem.get(self._K_LAST_REAPER_SCOUT_AT, now=now, default=0.0))

    def intel_last_reaper_scout_done_at(self, *, now: float) -> float:
        return float(self.mem.get(self._K_REAPER_SCOUT_LAST_DONE_AT, now=now, default=0.0))

    def mark_reaper_scout_dispatched(self, *, now: float) -> None:
        self.mem.set(self._K_REAPER_SCOUT_DISPATCHED, value=True, now=now, ttl=None)
        self.mem.set(self._K_LAST_REAPER_SCOUT_AT, value=float(now), now=now, ttl=None)

    def mark_reaper_scout_done(self, *, now: float) -> None:
        self.mem.set(self._K_REAPER_SCOUT_LAST_DONE_AT, value=float(now), now=now, ttl=None)
```
# bot/mind/body.py
```python
# bot/mind/body.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Optional, Set

from ares.consts import UnitRole


@dataclass
class Lease:
    owner: str  # mission_id
    role: UnitRole
    expires_at: float


class UnitLeases:
    """
    Unit ownership with TTL and reverse index.
    """

    def __init__(self, *, default_ttl: float = 8.0):
        self.default_ttl = float(default_ttl)
        self._leases: Dict[int, Lease] = {}      # unit_tag -> Lease
        self._by_owner: Dict[str, Set[int]] = {} # mission_id -> {unit_tag}

    def reset(self) -> None:
        self._leases.clear()
        self._by_owner.clear()

    def reap(self, *, now: float) -> None:
        expired: List[int] = [tag for tag, lease in self._leases.items() if lease.expires_at <= now]
        for tag in expired:
            self._remove_tag(tag)

    def _remove_tag(self, unit_tag: int) -> None:
        lease = self._leases.pop(unit_tag, None)
        if lease is None:
            return
        s = self._by_owner.get(lease.owner)
        if s:
            s.discard(unit_tag)
            if not s:
                del self._by_owner[lease.owner]

    # ---------------- Queries ----------------

    def owner_of(self, unit_tag: int, *, now: float) -> Optional[str]:
        self.reap(now=now)
        lease = self._leases.get(unit_tag)
        return lease.owner if lease else None

    def units_of(self, task_id: str, *, now: float) -> Set[int]:
        self.reap(now=now)
        return set(self._by_owner.get(task_id, set()))

    def can_claim(self, unit_tag: int, *, now: float) -> bool:
        self.reap(now=now)
        return unit_tag not in self._leases

    # ---------------- Claim API ----------------

    def claim(
        self,
        *,
        task_id: str,
        unit_tag: int,
        role: UnitRole,
        now: float,
        ttl: Optional[float] = None,
        force: bool = False,
    ) -> bool:
        self.reap(now=now)

        if (not force) and unit_tag in self._leases:
            return False

        if unit_tag in self._leases:
            self._remove_tag(unit_tag)

        t = float(ttl) if ttl is not None else self.default_ttl
        self._leases[unit_tag] = Lease(owner=task_id, role=role, expires_at=now + t)
        self._by_owner.setdefault(task_id, set()).add(unit_tag)
        return True

    def try_acquire(
        self,
        task_id: str,
        *,
        unit_tag: int,
        role: UnitRole,
        now: float,
        ttl: Optional[float] = None,
        force: bool = False,
    ) -> bool:
        return self.claim(
            task_id=task_id,
            unit_tag=unit_tag,
            role=role,
            now=now,
            ttl=ttl,
            force=force,
        )

    def touch(self, *, task_id: str, unit_tag: int, now: float, ttl: Optional[float] = None) -> None:
        self.reap(now=now)
        lease = self._leases.get(unit_tag)
        if not lease or lease.owner != task_id:
            return
        t = float(ttl) if ttl is not None else self.default_ttl
        lease.expires_at = now + t

    def release(self, *, unit_tag: int) -> None:
        self._remove_tag(unit_tag)

    def release_owner(self, *, task_id: str) -> None:
        tags = list(self._by_owner.get(task_id, []))
        for tag in tags:
            self._remove_tag(tag)

    def release_mission(self, *, mission_id: str) -> None:
        self.release_owner(task_id=mission_id)

    def snapshot(self, *, now: float) -> dict:
        self.reap(now=now)
        return {
            "total_leases": len(self._leases),
            "by_owner": {owner: len(tags) for owner, tags in self._by_owner.items()},
        }

    # -----------------------
    # Role mapping
    # -----------------------
    def _role_for_domain(self, domain: str) -> UnitRole:
        d = domain.upper()
        if d == "DEFENSE":
            return UnitRole.DEFENDING
        if d in ("HARASS", "DROP"):
            return UnitRole.HARASSING
        if d in ("SCOUT", "INTEL"):
            return UnitRole.SCOUTING
        return UnitRole.IDLE
```
# bot/mind/ego.py
```python
# bot/mind/ego.py
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Sequence, Tuple

from bot.mind.attention import Attention
from bot.mind.awareness import Awareness, K
from bot.mind.body import UnitLeases
from bot.planners.proposals import Proposal, TaskSpec, UnitRequirement
from bot.tasks.base_task import Task, TaskTick, TaskResult


@dataclass
class Commitment:
    mission_id: str
    proposal_id: str
    domain: str
    task: Task
    started_at: float
    expires_at: Optional[float]
    non_preemptible_until: float
    assigned_tags: List[int] = field(default_factory=list)

    def is_expired(self, now: float) -> bool:
        return self.expires_at is not None and float(now) >= float(self.expires_at)


@dataclass(frozen=True)
class EgoConfig:
    threat_block_start_at: int = 70
    threat_force_preempt_at: int = 90
    non_preemptible_grace_s: float = 2.5
    default_failure_cooldown_s: float = 8.0
    singleton_domains: frozenset[str] = frozenset({"MACRO"})


class Ego:
    def __init__(self, *, body: UnitLeases, log: Any = None, cfg: EgoConfig = EgoConfig()):
        self.body = body
        self.log = log
        self.cfg = cfg

        self._planners: List[Any] = []
        self._active: Dict[str, Commitment] = {}
        self._active_by_domain: Dict[str, List[str]] = {}

    def register_planners(self, planners: Sequence[Any]) -> None:
        self._planners = list(planners)

    async def tick(self, bot, *, tick: TaskTick, attention: Attention, awareness: Awareness) -> None:
        now = float(tick.time)

        self.body.reap(now=now)
        self._reap_commitments(now=now, awareness=awareness)

        proposals: List[Proposal] = []
        for planner in self._planners:
            proposals.extend(planner.propose(bot, awareness=awareness, attention=attention) or [])

        for prop in proposals:
            prop.validate()

        proposals.sort(key=lambda p: int(p.score), reverse=True)

        await self._admit(bot, now=now, attention=attention, awareness=awareness, proposals=proposals)
        await self._execute(bot, tick=tick, attention=attention, awareness=awareness)

    async def _admit(
        self,
        bot,
        *,
        now: float,
        attention: Attention,
        awareness: Awareness,
        proposals: List[Proposal],
    ) -> None:
        threatened = bool(attention.combat.threatened)
        urgency = int(attention.combat.defense_urgency)

        for prop in proposals:
            if self._is_in_cooldown(awareness, now=now, proposal_id=prop.proposal_id):
                continue

            domain = str(prop.domain)

            # Never admit the same proposal while one is already running.
            # This is the key guard that prevents many parallel scout missions.
            if self._is_proposal_running(prop.proposal_id):
                continue

            if threatened and urgency >= self.cfg.threat_block_start_at and domain != "DEFENSE":
                continue

            if domain in self.cfg.singleton_domains:
                self._preempt_domain(now=now, awareness=awareness, domain=domain, reason=f"preempted_by:{prop.proposal_id}")

            mission_id = f"{prop.proposal_id}:{int(now * 1000)}"
            spec: TaskSpec = prop.task()

            ok, tags, fail_reason = self._select_and_claim_units(
                bot,
                now=now,
                attention=attention,
                spec=spec,
                proposal=prop,
                mission_id=mission_id,
            )
            if not ok:
                self._set_cooldown(
                    awareness,
                    now=now,
                    proposal_id=prop.proposal_id,
                    seconds=float(prop.cooldown_s),
                    reason=fail_reason,
                )
                continue

            task_obj = spec.task_factory(mission_id)
            self._validate_task(task_obj, spec=spec)
            task_obj.bind_mission(mission_id=mission_id, assigned_tags=list(tags))

            ttl = spec.lease_ttl if spec.lease_ttl is not None else prop.lease_ttl
            expires_at = None if ttl is None else (float(now) + float(ttl))

            c = Commitment(
                mission_id=mission_id,
                proposal_id=prop.proposal_id,
                domain=domain,
                task=task_obj,
                started_at=float(now),
                expires_at=expires_at,
                non_preemptible_until=float(now) + float(self.cfg.non_preemptible_grace_s),
                assigned_tags=list(tags),
            )
            self._active[mission_id] = c
            self._active_by_domain.setdefault(domain, []).append(mission_id)

            self._awareness_start_mission(awareness, now=now, c=c)
            awareness.emit(
                "mission_started",
                now=now,
                data={
                    "mission_id": mission_id,
                    "proposal_id": prop.proposal_id,
                    "domain": domain,
                    "tags": len(tags),
                    "ttl": ttl,
                },
            )
            if self.log is not None:
                self.log.emit(
                    "mission_started",
                    {
                        "time": round(now, 2),
                        "mission_id": mission_id,
                        "proposal_id": prop.proposal_id,
                        "domain": domain,
                        "tags": len(tags),
                        "ttl": ttl,
                    },
                )

    async def _execute(self, bot, *, tick: TaskTick, attention: Attention, awareness: Awareness) -> None:
        now = float(tick.time)

        for mission_id, c in list(self._active.items()):
            if c.is_expired(now):
                self._finish_mission(awareness, now=now, c=c, status="DONE", reason="expired")
                continue

            self._touch_leases_for_commitment(now=now, c=c)

            res = await c.task.step(bot, tick, attention)
            if not isinstance(res, TaskResult):
                raise TypeError(f"Task {type(c.task).__name__} returned non-TaskResult: {type(res)!r}")

            if res.status == "FAILED":
                cooldown = float(res.retry_after_s) if float(res.retry_after_s) > 0 else float(self.cfg.default_failure_cooldown_s)
                self._set_cooldown(awareness, now=now, proposal_id=c.proposal_id, seconds=cooldown, reason=res.reason)
                self._finish_mission(awareness, now=now, c=c, status="FAILED", reason=res.reason)
                continue

            if res.status == "DONE":
                self._finish_mission(awareness, now=now, c=c, status="DONE", reason=res.reason)
                continue

            if self._should_emit_mission_step(awareness, now=now, c=c, status=res.status):
                awareness.emit(
                    "mission_step",
                    now=now,
                    data={"mission_id": c.mission_id, "domain": c.domain, "status": res.status, "reason": res.reason},
                )

    def _reap_commitments(self, *, now: float, awareness: Awareness) -> None:
        for mission_id, c in list(self._active.items()):
            if c.is_expired(now):
                self._finish_mission(awareness, now=now, c=c, status="DONE", reason="expired")

    def _finish_mission(self, awareness: Awareness, *, now: float, c: Commitment, status: str, reason: str) -> None:
        self.body.release_mission(mission_id=c.mission_id)

        self._active.pop(c.mission_id, None)
        ids = self._active_by_domain.get(c.domain)
        if ids is not None:
            try:
                ids.remove(c.mission_id)
            except ValueError:
                pass
            if not ids:
                self._active_by_domain.pop(c.domain, None)

        self._awareness_end_mission(awareness, now=now, mission_id=c.mission_id, status=status, reason=reason)
        awareness.emit(
            "mission_ended",
            now=now,
            data={"mission_id": c.mission_id, "proposal_id": c.proposal_id, "domain": c.domain, "status": status, "reason": reason},
        )
        if self.log is not None:
            self.log.emit(
                "mission_ended",
                {
                    "time": round(now, 2),
                    "mission_id": c.mission_id,
                    "proposal_id": c.proposal_id,
                    "domain": c.domain,
                    "status": status,
                    "reason": reason,
                },
            )

    def _is_proposal_running(self, proposal_id: str) -> bool:
        return any(c.proposal_id == proposal_id for c in self._active.values())

    def _preempt_domain(self, *, now: float, awareness: Awareness, domain: str, reason: str) -> None:
        mids = list(self._active_by_domain.get(domain, []))
        for mid in mids:
            c = self._active.get(mid)
            if c is None:
                continue
            self._finish_mission(awareness, now=now, c=c, status="DONE", reason=reason)

    def _validate_task(self, task_obj: Any, *, spec: TaskSpec) -> None:
        if not isinstance(task_obj, Task):
            raise TypeError(f"Task factory for {spec.task_id} returned non-Task: {type(task_obj)!r}")

    def _select_and_claim_units(
        self,
        bot,
        *,
        now: float,
        attention: Attention,
        spec: TaskSpec,
        proposal: Proposal,
        mission_id: str,
    ) -> Tuple[bool, List[int], str]:
        reqs: List[UnitRequirement] = list(spec.unit_requirements)
        if not reqs:
            return True, [], ""

        units_ready = attention.economy.units_ready
        selected: List[int] = []

        for req in reqs:
            utype = req.unit_type
            need = int(req.count)

            if int(units_ready.get(utype, 0)) <= 0:
                return False, [], f"no_{utype.name.lower()}"

            candidates: List[int] = []
            for u in bot.units.of_type(utype).ready:
                tag = int(u.tag)
                if self.body.can_claim(tag, now=now):
                    candidates.append(tag)

            if len(candidates) < need:
                return False, [], f"insufficient_free_{utype.name.lower()}"

            selected.extend(candidates[:need])

        ttl_for_claim = spec.lease_ttl if spec.lease_ttl is not None else proposal.lease_ttl
        if ttl_for_claim is None:
            ttl_for_claim = self.body.default_ttl

        role = self.body._role_for_domain(str(proposal.domain))

        for tag in selected:
            ok = self.body.claim(task_id=mission_id, unit_tag=tag, role=role, now=now, ttl=float(ttl_for_claim), force=False)
            if not ok:
                self.body.release_mission(mission_id=mission_id)
                return False, [], "claim_failed"

        return True, selected, ""

    def _touch_leases_for_commitment(self, *, now: float, c: Commitment) -> None:
        if not c.assigned_tags:
            return

        if c.expires_at is None:
            ttl = self.body.default_ttl
        else:
            remaining = float(c.expires_at) - float(now)
            if remaining <= 0.0:
                return
            ttl = max(0.25, min(8.0, remaining))

        for tag in c.assigned_tags:
            self.body.touch(task_id=c.mission_id, unit_tag=int(tag), now=now, ttl=ttl)

    def _is_in_cooldown(self, awareness: Awareness, *, now: float, proposal_id: str) -> bool:
        until = awareness.mem.get(K("ops", "cooldown", proposal_id, "until"), now=now, default=None)
        if until is None:
            return False
        return float(now) < float(until)

    def _set_cooldown(self, awareness: Awareness, *, now: float, proposal_id: str, seconds: float, reason: str) -> None:
        if seconds <= 0:
            return
        awareness.mem.set(K("ops", "cooldown", proposal_id, "until"), value=float(now) + float(seconds), now=now, ttl=None)
        awareness.mem.set(K("ops", "cooldown", proposal_id, "reason"), value=str(reason), now=now, ttl=None)

    def _awareness_start_mission(self, awareness: Awareness, *, now: float, c: Commitment) -> None:
        awareness.mem.set(K("ops", "mission", c.mission_id, "status"), value="RUNNING", now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", c.mission_id, "domain"), value=c.domain, now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", c.mission_id, "proposal_id"), value=c.proposal_id, now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", c.mission_id, "started_at"), value=float(c.started_at), now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", c.mission_id, "expires_at"), value=c.expires_at, now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", c.mission_id, "assigned_tags"), value=list(c.assigned_tags), now=now, ttl=None)

    def _awareness_end_mission(self, awareness: Awareness, *, now: float, mission_id: str, status: str, reason: str) -> None:
        awareness.mem.set(K("ops", "mission", mission_id, "status"), value=str(status), now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", mission_id, "reason"), value=str(reason), now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", mission_id, "ended_at"), value=float(now), now=now, ttl=None)

    def _should_emit_mission_step(self, awareness: Awareness, *, now: float, c: Commitment, status: str) -> bool:
        # Always emit stateful transitions; throttle repetitive NOOP spam.
        if str(status) != "NOOP":
            return True
        key = K("ops", "mission", c.mission_id, "last_noop_emit_at")
        last = awareness.mem.get(key, now=now, default=None)
        if last is None or (float(now) - float(last)) >= 5.0:
            awareness.mem.set(key, value=float(now), now=now, ttl=None)
            return True
        return False
```
# bot/mind/self.py
```python
# bot/mind/self.py
from __future__ import annotations

from dataclasses import asdict, dataclass, is_dataclass
from enum import Enum
from typing import Any

from sc2.data import Result

from bot.devlog import DevLogger
from bot.sensors.threat_sensor import Threat
from bot.intel.enemy_build_intel import EnemyBuildIntelConfig, derive_enemy_build_intel
from bot.intel.my_army_composition_intel import MyArmyCompositionConfig, derive_my_army_composition_intel
from bot.mind.attention import derive_attention
from bot.mind.awareness import Awareness
from bot.mind.body import UnitLeases
from bot.mind.ego import Ego, EgoConfig
from bot.tasks.base_task import TaskTick

from bot.tasks.defend_task import Defend
from bot.tasks.scout_task import Scout
from bot.tasks.macro.opening import MacroOpeningTick

from bot.planners.defense_planner import DefensePlanner
from bot.planners.intel_planner import IntelPlanner

from bot.planners.production_planner import ProductionPlanner
from bot.planners.spending_planner import SpendingPlanner
from bot.planners.housekeeping_planner import HousekeepingPlanner
from bot.planners.depot_control_planner import DepotControlPlanner


def _jsonable(value: Any) -> Any:
    if value is None or isinstance(value, (str, int, float, bool)):
        return value

    if isinstance(value, Enum):
        return str(value.name)

    if is_dataclass(value):
        return _jsonable(asdict(value))

    if isinstance(value, dict):
        out: dict[str, Any] = {}
        for k, v in value.items():
            out[str(k)] = _jsonable(v)
        return out

    if isinstance(value, (list, tuple, set, frozenset)):
        return [_jsonable(v) for v in value]

    if hasattr(value, "x") and hasattr(value, "y"):
        try:
            return {"x": float(getattr(value, "x")), "y": float(getattr(value, "y"))}
        except Exception:
            return str(value)

    return str(value)


@dataclass
class RuntimeApp:
    log: DevLogger
    awareness: Awareness
    threat: Threat
    body: UnitLeases
    ego: Ego
    enemy_build_cfg: EnemyBuildIntelConfig
    my_comp_cfg: MyArmyCompositionConfig
    debug: bool = True
    attention_full_every_iters: int = 25
    awareness_full_every_iters: int = 50
    bo_diag_every_iters: int = 25
    bo_stall_warn_s: float = 25.0
    _bo_last_step_idx: int = -1
    _bo_last_step_t: float = 0.0

    @classmethod
    def build(cls, *, log: DevLogger, debug: bool = True) -> "RuntimeApp":
        awareness = Awareness(log=log)
        threat = Threat(defend_radius=22.0, min_enemy=1)
        body = UnitLeases(default_ttl=8.0)

        ego = Ego(
            body=body,
            log=log,
            cfg=EgoConfig(
                # New singleton macro domains: allow spending+production+housekeeping concurrently,
                # without changing Ego internals.
                singleton_domains=frozenset({"MACRO_SPENDING", "MACRO_PRODUCTION", "MACRO_HOUSEKEEPING", "MACRO_DEPOT_CONTROL"}),
                threat_block_start_at=70,
                threat_force_preempt_at=90,
                non_preemptible_grace_s=2.5,
                default_failure_cooldown_s=8.0,
            ),
        )

        defend_task = Defend(log=log, log_every_iters=11)

        scout_task = Scout(
            awareness=awareness,
            log=log,
            trigger_time=25.0,
            log_every=6.0,
            see_radius=14.0,
        )

        # Opening remains a tiny SCV-only macro while BuildRunner/YML does the rest.
        opening_macro_task = MacroOpeningTick(log=log, log_every_iters=22, scv_cap=60)

        defense_planner = DefensePlanner(defend_task=defend_task, log=log)
        intel_planner = IntelPlanner(awareness=awareness, log=log, scout_task=scout_task)

        spending_planner = SpendingPlanner(
            target_bases_default=2,
            flood_m=800,
            flood_hi_m=1400,
            flood_hold_s=12.0,
            log=log,
        )

        production_planner = ProductionPlanner(
            scv_cap=66,
            log=log,
        )

        housekeeping_planner = HousekeepingPlanner(
            interval_s=35.0,
            cooldown_s=6.0,
            lease_ttl_s=12.0,
            score=18,
            log=log,
        )

        depot_control_planner = DepotControlPlanner(
            interval_s=1.5,
            cooldown_s=0.0,
            score=24,
            log=log,
        )

        # Keep opening as a "pre-macro" handled by its own planner? (MVP: reuse ProductionPlanner gate.)
        # For now: register opening via a tiny planner-inline shim inside runtime:
        # We keep it as a planner to respect the architecture.
        from bot.planners.proposals import Proposal, TaskSpec

        @dataclass
        class OpeningPlanner:
            planner_id: str = "opening_planner"
            score: int = 60
            log: DevLogger | None = None
            opening_task: MacroOpeningTick = None

            def _pid(self) -> str:
                return f"{self.planner_id}:macro_opening"

            def propose(self, bot, *, awareness: Awareness, attention) -> list[Proposal]:
                now = float(attention.time)
                # If BuildOrderRunner exists, let it own opening execution.
                if getattr(bot, "build_order_runner", None) is not None:
                    return []
                if bool(attention.macro.opening_done):
                    return []
                pid = self._pid()
                if awareness.ops_proposal_running(proposal_id=pid, now=now):
                    return []

                def _factory(mission_id: str) -> MacroOpeningTick:
                    return self.opening_task.spawn()

                out = [
                    Proposal(
                        proposal_id=pid,
                        domain="MACRO_PRODUCTION",  # opening shares the production lane
                        score=int(self.score),
                        tasks=[TaskSpec(task_id="macro_opening", task_factory=_factory, unit_requirements=[], lease_ttl=None)],
                        lease_ttl=None,
                        cooldown_s=0.0,
                        risk_level=0,
                        allow_preempt=True,
                    )
                ]
                if self.log:
                    self.log.emit(
                        "planner_proposed",
                        {"planner": self.planner_id, "count": len(out), "mode": "opening"},
                        meta={"module": "planner", "component": f"planner.{self.planner_id}"},
                    )
                return out

        opening_planner = OpeningPlanner(opening_task=opening_macro_task, log=log)

        ego.register_planners(
            [
                defense_planner,
                intel_planner,
                opening_planner,
                spending_planner,
                production_planner,
                housekeeping_planner,
                depot_control_planner,
            ]
        )

        return cls(
            log=log,
            awareness=awareness,
            threat=threat,
            body=body,
            ego=ego,
            enemy_build_cfg=EnemyBuildIntelConfig(),
            my_comp_cfg=MyArmyCompositionConfig(),
            debug=bool(debug),
        )

    async def on_start(self, bot) -> None:
        try:
            self.body.reset()
        except Exception:
            pass
        if self.log:
            self.log.emit("runtime_start", {})

    async def on_step(self, bot, *, iteration: int) -> None:
        now = float(getattr(bot, "time", 0.0))

        attention = derive_attention(bot, awareness=self.awareness, threat=self.threat, log=self.log)

        derive_enemy_build_intel(
            bot,
            awareness=self.awareness,
            attention=attention,
            now=now,
            cfg=self.enemy_build_cfg,
        )

        # New: strategy reference (mode + proportions)
        derive_my_army_composition_intel(
            awareness=self.awareness,
            attention=attention,
            now=now,
            cfg=self.my_comp_cfg,
        )

        self._emit_build_order_diagnostics(bot, now=now, iteration=int(iteration))

        if self.log:
            if int(iteration) % max(1, int(self.attention_full_every_iters)) == 0:
                self.log.emit(
                    "attention_full",
                    _jsonable(attention),
                    meta={"module": "attention", "component": "attention.full"},
                )
            if int(iteration) % max(1, int(self.awareness_full_every_iters)) == 0:
                self.log.emit(
                    "awareness_full",
                    {
                        "mem": _jsonable(self.awareness.mem.snapshot(now=now)),
                        "events_tail": _jsonable(self.awareness.tail_events(80)),
                    },
                    meta={"module": "awareness", "component": "awareness.full"},
                )

        tick = TaskTick(iteration=int(iteration), time=now)
        await self.ego.tick(bot, tick=tick, attention=attention, awareness=self.awareness)

    async def on_end(self, bot, game_result: Result) -> None:
        if self.log:
            self.log.emit("game_end", {"result": str(game_result)})

    def _emit_build_order_diagnostics(self, bot, *, now: float, iteration: int) -> None:
        if self.log is None:
            return

        bor = getattr(bot, "build_order_runner", None)
        if bor is None:
            return

        build_order = list(getattr(bor, "build_order", []) or [])
        total_steps = len(build_order)
        step_idx = int(getattr(bor, "build_step", 0) or 0)
        temp_step_idx = int(getattr(bor, "_temporary_build_step", -1) or -1)
        build_completed = bool(getattr(bor, "build_completed", False))
        chosen_opening = str(getattr(bor, "chosen_opening", ""))
        current_step_started = bool(getattr(bor, "current_step_started", False))
        current_step_complete = bool(getattr(bor, "current_step_complete", False))

        if step_idx != self._bo_last_step_idx:
            self._bo_last_step_idx = int(step_idx)
            self._bo_last_step_t = float(now)
        stall_s = max(0.0, float(now) - float(self._bo_last_step_t))

        command_name = ""
        start_at_supply = None
        target = None
        start_condition_ok = None
        end_condition_ok = None

        if 0 <= step_idx < total_steps:
            step = build_order[step_idx]
            command_name = getattr(step.command, "name", str(step.command))
            start_at_supply = int(getattr(step, "start_at_supply", 0) or 0)
            target = _jsonable(getattr(step, "target", None))
            try:
                start_condition_ok = bool(step.start_condition())
            except Exception as e:
                start_condition_ok = f"error:{type(e).__name__}"
            try:
                end_condition_ok = bool(step.end_condition())
            except Exception as e:
                end_condition_ok = f"error:{type(e).__name__}"

        if int(iteration) % max(1, int(self.bo_diag_every_iters)) == 0:
            self.log.emit(
                "build_order_status",
                {
                    "iter": int(iteration),
                    "t": round(float(now), 2),
                    "chosen_opening": chosen_opening,
                    "build_completed": bool(build_completed),
                    "step_idx": int(step_idx),
                    "total_steps": int(total_steps),
                    "temp_step_idx": int(temp_step_idx),
                    "current_step_started": bool(current_step_started),
                    "current_step_complete": bool(current_step_complete),
                    "command": command_name,
                    "start_at_supply": start_at_supply,
                    "target": target,
                    "start_condition_ok": start_condition_ok,
                    "end_condition_ok": end_condition_ok,
                    "supply_used": float(getattr(bot, "supply_used", 0.0) or 0.0),
                    "minerals": int(getattr(bot, "minerals", 0) or 0),
                    "vespene": int(getattr(bot, "vespene", 0) or 0),
                    "stall_s_on_step": round(float(stall_s), 2),
                },
                meta={"module": "macro", "component": "build_order.runner"},
            )

        if (
            not build_completed
            and total_steps > 0
            and stall_s >= float(self.bo_stall_warn_s)
            and int(iteration) % max(1, int(self.bo_diag_every_iters)) == 0
        ):
            self.log.emit(
                "build_order_stall",
                {
                    "iter": int(iteration),
                    "t": round(float(now), 2),
                    "chosen_opening": chosen_opening,
                    "step_idx": int(step_idx),
                    "total_steps": int(total_steps),
                    "command": command_name,
                    "start_at_supply": start_at_supply,
                    "start_condition_ok": start_condition_ok,
                    "end_condition_ok": end_condition_ok,
                    "current_step_started": bool(current_step_started),
                    "current_step_complete": bool(current_step_complete),
                    "stall_s_on_step": round(float(stall_s), 2),
                },
                meta={"module": "macro", "component": "build_order.runner"},
            )
```
## bot/planners (full)
# bot/planners/defense_planner.py
```python
# bot/planners/defense_planner.py
from __future__ import annotations

from dataclasses import dataclass

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.planners.proposals import Proposal, TaskSpec
from bot.tasks.defend_task import Defend


@dataclass
class DefensePlanner:
    """
    Planner reativo de defesa.
    """
    planner_id: str = "defense_planner"
    defend_task: Defend = None  # template instance
    log: DevLogger | None = None

    def _pid_defend(self) -> str:
        return f"{self.planner_id}:defend:bases"

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        if (not bool(attention.combat.threatened)) or (not attention.combat.threat_pos):
            return []

        now = float(attention.time)
        pid = self._pid_defend()

        # Avoid planner/log spam while an equal DEFENSE mission is already running.
        if awareness.ops_proposal_running(proposal_id=pid, now=now):
            return []

        urg = int(attention.combat.defense_urgency)
        score = max(80, min(100, 60 + urg))

        if self.defend_task is None:
            raise TypeError("DefensePlanner requires defend_task template instance")

        def _factory(mission_id: str) -> Defend:
            return self.defend_task.spawn()

        out = [
            Proposal(
                proposal_id=pid,
                domain="DEFENSE",
                score=score,
                tasks=[TaskSpec(task_id="defend_bases", task_factory=_factory, unit_requirements=[])],
                lease_ttl=6.0,
                cooldown_s=0.0,
                risk_level=0,
                allow_preempt=True,
            )
        ]
        if self.log is not None:
            self.log.emit(
                "planner_proposed",
                {"planner": self.planner_id, "count": len(out), "score": int(score)},
                meta={"module": "planner", "component": f"planner.{self.planner_id}"},
            )
        return out
```
# bot/planners/depot_control_planner.py
```python
# bot/planners/depot_control_planner.py
from __future__ import annotations

from dataclasses import dataclass

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness, K
from bot.planners.proposals import Proposal, TaskSpec
from bot.tasks.control_depots_task import ControlDepots


@dataclass
class DepotControlPlanner:
    """
    Periodic proposer for wall-depot control.
    """

    planner_id: str = "depot_control_planner"
    interval_s: float = 1.5
    cooldown_s: float = 0.0
    score: int = 24
    log: DevLogger | None = None

    def _pid(self) -> str:
        return f"{self.planner_id}:control_depots"

    def _due(self, *, awareness: Awareness, now: float) -> bool:
        last = awareness.mem.get(K("macro", "wall", "depot_control", "last_done_at"), now=now, default=None)
        if last is None:
            return True
        try:
            return (float(now) - float(last)) >= float(self.interval_s)
        except Exception:
            return True

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        now = float(attention.time)
        pid = self._pid()

        if not self._due(awareness=awareness, now=now):
            return []
        if awareness.ops_proposal_running(proposal_id=pid, now=now):
            return []

        def _factory(mission_id: str) -> ControlDepots:
            return ControlDepots(awareness=awareness)

        out = [
            Proposal(
                proposal_id=pid,
                domain="MACRO_DEPOT_CONTROL",
                score=int(self.score),
                tasks=[TaskSpec(task_id="control_depots", task_factory=_factory, unit_requirements=[])],
                lease_ttl=None,
                cooldown_s=float(self.cooldown_s),
                risk_level=0,
                allow_preempt=True,
            )
        ]

        if self.log is not None:
            self.log.emit(
                "planner_proposed",
                {"planner": self.planner_id, "count": len(out)},
                meta={"module": "planner", "component": f"planner.{self.planner_id}"},
            )

        return out
```
# bot/planners/housekeeping_planner.py
```python
# =============================================================================
# bot/planners/housekeeping_planner.py  (NEW)
# =============================================================================
from __future__ import annotations

from dataclasses import dataclass

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness, K
from bot.planners.proposals import Proposal, TaskSpec
from bot.tasks.macro.scv_housekeeping_task import ScvHousekeeping


@dataclass
class HousekeepingPlanner:
    """
    Low-cost periodic housekeeping (SCV rebalance, etc.).
    """
    planner_id: str = "housekeeping_planner"
    interval_s: float = 35.0
    cooldown_s: float = 6.0
    lease_ttl_s: float = 12.0
    score: int = 18
    log: DevLogger | None = None

    def _pid_housekeeping(self) -> str:
        return f"{self.planner_id}:scv_housekeeping"

    def _due(self, *, awareness: Awareness, now: float) -> bool:
        last = awareness.mem.get(K("macro", "scv", "housekeeping", "last_done_at"), now=now, default=None)
        if last is None:
            return True
        try:
            return (float(now) - float(last)) >= float(self.interval_s)
        except Exception:
            return True

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        now = float(attention.time)
        pid = self._pid_housekeeping()

        if not self._due(awareness=awareness, now=now):
            return []
        if awareness.ops_proposal_running(proposal_id=pid, now=now):
            return []

        def _hk_factory(mission_id: str) -> ScvHousekeeping:
            return ScvHousekeeping(awareness=awareness)

        out = [
            Proposal(
                proposal_id=pid,
                domain="MACRO_HOUSEKEEPING",
                score=int(self.score),
                tasks=[TaskSpec(task_id="scv_housekeeping", task_factory=_hk_factory, unit_requirements=[])],
                lease_ttl=float(self.lease_ttl_s),
                cooldown_s=float(self.cooldown_s),
                risk_level=0,
                allow_preempt=True,
            )
        ]

        if self.log is not None:
            self.log.emit(
                "planner_proposed",
                {"planner": self.planner_id, "count": len(out)},
                meta={"module": "planner", "component": f"planner.{self.planner_id}"},
            )
        return out
```
# bot/planners/intel_planner.py
```python
# bot/planners/intel_planner.py
from __future__ import annotations

from dataclasses import dataclass
from pickle import FALSE
from typing import Optional, Tuple

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness, K
from bot.planners.proposals import Proposal, TaskSpec, UnitRequirement
from bot.tasks.scan_task import ScanAt
from bot.tasks.scout_task import Scout
from bot.tasks.reaper_scout_task import ReaperScout, ReaperScoutObjective


@dataclass
class IntelPlanner:
    planner_id: str = "intel_planner"

    awareness: Awareness = None  # injected
    log: DevLogger | None = None

    # SCV re-scout (optional; early SCV scout is YAML now)
    scout_task: Scout | None = None
    scout_min_dispatch_interval_s: float = 75.0
    scout_lease_ttl_s: float = 120.0

    # Reaper scout
    reaper_scout_interval_early_s: float = 35.0
    reaper_scout_interval_mid_s: float = 70.0
    reaper_scout_lease_ttl_s: float = 90.0

    confidence_min: float = 0.70
    confidence_rescout_below: float = 0.65

    def _pid_scv_rescout(self) -> str:
        return f"{self.planner_id}:scout:scv_rescout"

    def _pid_reaper_scout(self) -> str:
        return f"{self.planner_id}:scout:reaper"

    def _pid_scan(self, label: str) -> str:
        return f"{self.planner_id}:scan:{label}"

    def _enemy_main(self, bot) -> Point2:
        return bot.enemy_start_locations[0]

    def _opening_state(self, *, awareness: Awareness, now: float) -> Tuple[Optional[str], float, float, Optional[float], dict]:
        first_seen_t = awareness.mem.get(K("enemy", "opening", "first_seen_t"), now=now, default=None)
        last_update_t = awareness.mem.get(K("enemy", "opening", "last_update_t"), now=now, default=None)

        kind = awareness.mem.get(K("enemy", "opening", "kind"), now=now, default=None)
        conf = awareness.mem.get(K("enemy", "opening", "confidence"), now=now, default=0.0)
        signals = awareness.mem.get(K("enemy", "opening", "signals"), now=now, default={}) or {}

        try:
            conf_f = float(conf)
        except Exception:
            conf_f = 0.0

        age_s = 9999.0
        if last_update_t is not None:
            try:
                age_s = max(0.0, float(now) - float(last_update_t))
            except Exception:
                age_s = 9999.0

        kind_s = str(kind) if kind is not None else None
        fst = float(first_seen_t) if first_seen_t is not None else None
        return kind_s, conf_f, float(age_s), fst, dict(signals)

    def _reaper_objective(self, *, kind: Optional[str], conf: float, signals: dict, now: float) -> ReaperScoutObjective:
        """
        Pick ONE discriminative objective.
        Keep it simple; we can add proxy sweeps later.
        """
        nat_on_ground = bool(signals.get("natural_on_ground", False))
        if float(now) <= 210.0 and not nat_on_ground:
            return ReaperScoutObjective.CONFIRM_NATURAL
        if kind == "AGGRESSIVE" and conf >= 0.70:
            # in aggressive case, just peek main/ramp quickly
            return ReaperScoutObjective.CONFIRM_MAIN_RAMP
        return ReaperScoutObjective.CONFIRM_NATURAL

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        now = float(attention.time)
        proposals: list[Proposal] = []

        if self.awareness is None:
            raise TypeError("IntelPlanner requires awareness injected")

        # -------------------------
        # 0) SCV re-scout (optional)
        # -------------------------
        if False and (self.scout_task is not None):
            pid = self._pid_scv_rescout()
            # never donate SCV under pressure
            if not bool(attention.combat.threatened):
                kind, conf, age_s, first_seen_t, signals = self._opening_state(awareness=awareness, now=now)

                need_scv = False
                if first_seen_t is None and now >= 75.0:
                    need_scv = True
                elif kind is None and now >= 75.0:
                    need_scv = True
                elif conf < float(self.confidence_rescout_below) and now >= 75.0:
                    need_scv = True

                if need_scv:
                    last_dispatch = awareness.intel_last_scv_dispatch_at(now=now)
                    if last_dispatch <= 0.0 or (now - float(last_dispatch)) >= float(self.scout_min_dispatch_interval_s):
                        if not awareness.ops_proposal_running(proposal_id=pid, now=now):

                            def _scv_factory(mission_id: str) -> Scout:
                                return self.scout_task.spawn()

                            proposals.append(
                                Proposal(
                                    proposal_id=pid,
                                    domain="INTEL",
                                    score=33,
                                    tasks=[
                                        TaskSpec(
                                            task_id="scout_scv",
                                            task_factory=_scv_factory,
                                            unit_requirements=[UnitRequirement(unit_type=U.SCV, count=1)],
                                        )
                                    ],
                                    lease_ttl=float(self.scout_lease_ttl_s),
                                    cooldown_s=8.0,
                                    risk_level=1,
                                    allow_preempt=True,
                                )
                            )

        # -------------------------
        # 1) Reaper scout controller
        # -------------------------
        # Only if we have a reaper ready
        reapers_ready = int(attention.economy.units_ready.get(U.REAPER, 0) or 0)
        if reapers_ready >= 1:
            pid = self._pid_reaper_scout()

            # don't send reaper scout if home is on fire
            if not bool(attention.combat.threatened):
                kind, conf, age_s, first_seen_t, signals = self._opening_state(awareness=awareness, now=now)

                # staleness window: tighter early, looser mid
                refresh = float(self.reaper_scout_interval_early_s) if now <= 240.0 else float(self.reaper_scout_interval_mid_s)

                need_reaper = False
                if first_seen_t is None and now >= 75.0:
                    need_reaper = True
                elif kind is None and now >= 75.0:
                    need_reaper = True
                elif conf < float(self.confidence_min):
                    need_reaper = True
                elif age_s >= refresh:
                    need_reaper = True

                # anti-spam using awareness timestamp
                last_rep = awareness.intel_last_reaper_scout_dispatch_at(now=now)
                if need_reaper and (last_rep <= 0.0 or (now - float(last_rep)) >= refresh):
                    if not awareness.ops_proposal_running(proposal_id=pid, now=now):
                        obj = self._reaper_objective(kind=kind, conf=conf, signals=signals, now=now)

                        def _reaper_factory(mission_id: str) -> ReaperScout:
                            return ReaperScout(awareness=awareness, log=self.log, objective=obj)

                        proposals.append(
                            Proposal(
                                proposal_id=pid,
                                domain="INTEL",
                                score=52 if conf < 0.65 else 42,
                                tasks=[
                                    TaskSpec(
                                        task_id="reaper_scout",
                                        task_factory=_reaper_factory,
                                        unit_requirements=[UnitRequirement(unit_type=U.REAPER, count=1)],
                                    )
                                ],
                                lease_ttl=float(self.reaper_scout_lease_ttl_s),
                                cooldown_s=6.0,
                                risk_level=1,
                                allow_preempt=True,
                            )
                        )

                        if self.log:
                            self.log.emit(
                                "intel_reaper_scout_proposed",
                                {
                                    "t": round(float(now), 2),
                                    "proposal_id": pid,
                                    "objective": str(obj.value),
                                    "kind": str(kind),
                                    "confidence": float(conf),
                                    "age_s": float(age_s),
                                },
                                meta={"module": "planner", "component": f"planner.{self.planner_id}"},
                            )

        # -------------------------
        # 2) Scan when threatened and orbital ready
        # -------------------------
        if bool(attention.combat.threatened) and bool(attention.intel.orbital_ready_to_scan):
            target = self._enemy_main(bot)
            label = "enemy_main"

            def _scan_factory(mission_id: str) -> ScanAt:
                return ScanAt(awareness=awareness, target=target, label=label, cooldown=20.0, log=self.log)

            proposals.append(
                Proposal(
                    proposal_id=self._pid_scan(label),
                    domain="INTEL",
                    score=55,
                    tasks=[TaskSpec(task_id="scan_at", task_factory=_scan_factory, unit_requirements=[])],
                    lease_ttl=5.0,
                    cooldown_s=20.0,
                    risk_level=1,
                    allow_preempt=True,
                )
            )

        return proposals
```
# bot/planners/production_planner.py
```python
# =============================================================================
# bot/planners/production_planner.py  (NEW)
# =============================================================================
from __future__ import annotations

from dataclasses import dataclass

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.planners.proposals import Proposal, TaskSpec
from bot.tasks.macro.production_tick import MacroProductionTick


@dataclass
class ProductionPlanner:
    """
    Always-on production loop (singleton by domain).
    Runs only after opening is done (BuildRunner/yml done).
    """
    planner_id: str = "production_planner"
    score: int = 55
    log: DevLogger | None = None

    scv_cap: int = 66
    log_every_iters: int = 22

    def _pid(self) -> str:
        return f"{self.planner_id}:macro_production"

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        now = float(attention.time)

        # Respect your current opening gate: don't run production loop until opening_done.
        if not bool(attention.macro.opening_done):
            return []

        pid = self._pid()
        if awareness.ops_proposal_running(proposal_id=pid, now=now):
            return []

        def _factory(mission_id: str) -> MacroProductionTick:
            return MacroProductionTick(awareness=awareness, log=self.log, scv_cap=int(self.scv_cap), log_every_iters=int(self.log_every_iters))

        out = [
            Proposal(
                proposal_id=pid,
                domain="MACRO_PRODUCTION",
                score=int(self.score),
                tasks=[TaskSpec(task_id="macro_production", task_factory=_factory, unit_requirements=[])],
                lease_ttl=None,
                cooldown_s=0.0,
                risk_level=0,
                allow_preempt=True,
            )
        ]

        if self.log is not None:
            self.log.emit(
                "planner_proposed",
                {"planner": self.planner_id, "count": len(out), "mode": "production"},
                meta={"module": "planner", "component": f"planner.{self.planner_id}"},
            )
        return out
```
# bot/planners/proposals.py
```python
# bot/planners/proposals.py
from __future__ import annotations

from dataclasses import dataclass, field
import inspect
from typing import Callable, List, Optional

from sc2.ids.unit_typeid import UnitTypeId


@dataclass(frozen=True)
class UnitRequirement:
    unit_type: UnitTypeId
    count: int

    def validate(self) -> None:
        if not isinstance(self.unit_type, UnitTypeId):
            raise TypeError(f"UnitRequirement.unit_type must be UnitTypeId, got {type(self.unit_type)!r}")
        if not isinstance(self.count, int):
            raise TypeError(f"UnitRequirement.count must be int, got {type(self.count)!r}")
        if self.count <= 0:
            raise ValueError("UnitRequirement.count must be > 0")


@dataclass(frozen=True)
class TaskSpec:
    """
    One atomic task inside a proposal.

    lease_ttl:
      - None => no time-based mission expiry
      - float => mission expires when ttl elapses
    """

    task_id: str
    task_factory: Callable[[str], object]
    unit_requirements: List[UnitRequirement] = field(default_factory=list)
    lease_ttl: Optional[float] = None

    def validate(self) -> None:
        if not isinstance(self.task_id, str) or not self.task_id.strip():
            raise ValueError("TaskSpec.task_id must be a non-empty string")
        if not callable(self.task_factory):
            raise TypeError("TaskSpec.task_factory must be callable")

        try:
            sig = inspect.signature(self.task_factory)
        except (TypeError, ValueError) as e:
            raise TypeError(f"TaskSpec.task_factory must have an inspectable signature: {e}") from e

        params = list(sig.parameters.values())
        if len(params) != 1:
            raise TypeError("TaskSpec.task_factory must accept exactly 1 parameter: mission_id")

        for r in self.unit_requirements:
            if not isinstance(r, UnitRequirement):
                raise TypeError(f"TaskSpec.unit_requirements must contain UnitRequirement, got {type(r)!r}")
            r.validate()

        if self.lease_ttl is not None:
            if not isinstance(self.lease_ttl, (int, float)):
                raise TypeError("TaskSpec.lease_ttl must be a number")
            if float(self.lease_ttl) <= 0.0:
                raise ValueError("TaskSpec.lease_ttl must be > 0")


@dataclass(frozen=True)
class Proposal:
    proposal_id: str
    domain: str
    score: int

    tasks: List[TaskSpec] = field(default_factory=list)

    lease_ttl: Optional[float] = 30.0
    cooldown_s: float = 10.0
    risk_level: int = 1
    allow_preempt: bool = True

    def __post_init__(self) -> None:
        self.validate()

    def validate(self) -> None:
        if not isinstance(self.proposal_id, str) or not self.proposal_id.strip():
            raise ValueError("Proposal.proposal_id must be a non-empty string")
        if not isinstance(self.domain, str) or not self.domain.strip():
            raise ValueError("Proposal.domain must be a non-empty string")
        if not isinstance(self.score, int):
            raise TypeError("Proposal.score must be int")

        if not isinstance(self.tasks, list) or len(self.tasks) != 1:
            raise ValueError("Proposal.tasks must contain exactly 1 TaskSpec")

        t0 = self.tasks[0]
        if not isinstance(t0, TaskSpec):
            raise TypeError(f"Proposal.tasks[0] must be TaskSpec, got {type(t0)!r}")
        t0.validate()

        if self.lease_ttl is not None:
            if not isinstance(self.lease_ttl, (int, float)):
                raise TypeError("Proposal.lease_ttl must be a number or None")
            if float(self.lease_ttl) <= 0.0:
                raise ValueError("Proposal.lease_ttl must be > 0 when provided")

        if not isinstance(self.cooldown_s, (int, float)):
            raise TypeError("Proposal.cooldown_s must be a number")
        if float(self.cooldown_s) < 0.0:
            raise ValueError("Proposal.cooldown_s must be >= 0")

        if not isinstance(self.risk_level, int):
            raise TypeError("Proposal.risk_level must be int")
        if self.risk_level < 0:
            raise ValueError("Proposal.risk_level must be >= 0")

        if not isinstance(self.allow_preempt, bool):
            raise TypeError("Proposal.allow_preempt must be bool")

    def task(self) -> TaskSpec:
        return self.tasks[0]
```
# bot/planners/spending_planner.py
```python
# =============================================================================
# bot/planners/spending_planner.py  (NEW)
# =============================================================================
from __future__ import annotations

from dataclasses import dataclass

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.planners.proposals import Proposal, TaskSpec
from bot.tasks.macro.spending_tick import MacroSpendingTick


@dataclass
class SpendingPlanner:
    """
    Structural spending loop (singleton by domain).
    Runs only after opening is done.
    """
    planner_id: str = "spending_planner"
    score: int = 45
    log: DevLogger | None = None

    target_bases_default: int = 2
    flood_m: int = 800
    flood_hi_m: int = 1400
    flood_hold_s: float = 12.0

    log_every_iters: int = 22

    def _pid(self) -> str:
        return f"{self.planner_id}:macro_spending"

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        now = float(attention.time)

        bor = getattr(bot, "build_order_runner", None)
        if bor is not None and not bool(getattr(bor, "build_completed", False)):
            return []

        if not bool(attention.macro.opening_done):
            return []

        pid = self._pid()
        if awareness.ops_proposal_running(proposal_id=pid, now=now):
            return []

        def _factory(mission_id: str) -> MacroSpendingTick:
            return MacroSpendingTick(
                awareness=awareness,
                log=self.log,
                target_bases_default=int(self.target_bases_default),
                flood_m=int(self.flood_m),
                flood_hi_m=int(self.flood_hi_m),
                flood_hold_s=float(self.flood_hold_s),
                log_every_iters=int(self.log_every_iters),
            )

        out = [
            Proposal(
                proposal_id=pid,
                domain="MACRO_SPENDING",
                score=int(self.score),
                tasks=[TaskSpec(task_id="macro_spending", task_factory=_factory, unit_requirements=[])],
                lease_ttl=None,
                cooldown_s=0.0,
                risk_level=0,
                allow_preempt=True,
            )
        ]

        if self.log is not None:
            self.log.emit(
                "planner_proposed",
                {"planner": self.planner_id, "count": len(out), "mode": "spending"},
                meta={"module": "planner", "component": f"planner.{self.planner_id}"},
            )
        return out
```
## bot/sensors (full)
# bot/sensors/__init__.py
```python

```
# bot/sensors/combat_sensor.py
```python
# bot/sensors/combat_sensor.py
from __future__ import annotations

from bot.mind.attention import CombatSnapshot
from bot.sensors.threat_sensor import Threat


def derive_combat_snapshot(bot, *, threat: Threat) -> CombatSnapshot:
    """
    Combat snapshot from threat evaluation.
    Rule: no side-effects.
    """
    thr = threat.evaluate(bot)
    return CombatSnapshot(
        threatened=bool(thr.threatened),
        defense_urgency=int(thr.urgency),
        threat_pos=thr.threat_pos,
        enemy_count_near_bases=int(thr.enemy_count),
    )

```
# bot/sensors/economy_sensor.py
```python
# bot/sensors/economy_sensor.py
from __future__ import annotations

from dataclasses import dataclass
from collections import Counter

from bot.mind.attention import EconomySnapshot


def derive_economy_snapshot(bot) -> EconomySnapshot:
    """
    Economy intel module:
    - units_ready histogram
    - supply_left / minerals / gas

    Rule: no side-effects.
    """
    units_ready = Counter()
    try:
        for u in bot.units.ready:
            units_ready[u.type_id] += 1
    except Exception:
        # keep module resilient (intel should never crash the whole bot)
        pass

    try:
        supply_left = int(getattr(bot, "supply_left", 0) or 0)
        minerals = int(getattr(bot, "minerals", 0) or 0)
        gas = int(getattr(bot, "vespene", 0) or 0)
    except Exception:
        supply_left, minerals, gas = 0, 0, 0

    return EconomySnapshot(
        units_ready=dict(units_ready),
        supply_left=supply_left,
        minerals=minerals,
        gas=gas,
    )
```
# bot/sensors/enemy_build_sensor.py
```python
# bot/sensors/enemy_build_sensor.py
from __future__ import annotations

from collections import Counter, defaultdict
from dataclasses import dataclass
from typing import Dict, Optional, Tuple

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2

from bot.mind.attention import EnemyBuildSnapshot


_TOWNHALL_TYPES: Tuple[U, ...] = (
    U.HATCHERY,
    U.LAIR,
    U.HIVE,
    U.NEXUS,
    U.COMMANDCENTER,
    U.ORBITALCOMMAND,
    U.PLANETARYFORTRESS,
)


def _enemy_main_strict(bot) -> Point2:
    locs = getattr(bot, "enemy_start_locations", None)
    if not locs or len(locs) == 0:
        raise RuntimeError("EnemyBuildSensor requires bot.enemy_start_locations[0]")
    return locs[0]


def _enemy_natural_from_expansions(bot, enemy_main: Point2) -> Optional[Point2]:
    exps = getattr(bot, "expansion_locations_list", None)
    if not exps or len(exps) < 2:
        return None
    # nearest to enemy main is usually the main expansion; second nearest is natural
    ordered = sorted(exps, key=lambda p: p.distance_to(enemy_main))
    return ordered[1] if len(ordered) >= 2 else None


def _progress_stats(values: list[float]) -> dict:
    if not values:
        return {"count": 0, "ready": 0, "incomplete": 0, "min": 0.0, "max": 0.0, "avg": 0.0}
    c = len(values)
    ready = sum(1 for v in values if v >= 0.999)
    incomplete = c - ready
    mn = min(values)
    mx = max(values)
    avg = sum(values) / float(c)
    return {
        "count": int(c),
        "ready": int(ready),
        "incomplete": int(incomplete),
        "min": float(round(mn, 4)),
        "max": float(round(mx, 4)),
        "avg": float(round(avg, 4)),
    }


def derive_enemy_build_sensor(bot) -> EnemyBuildSnapshot:
    """
    EnemyBuildSensor (tick facts -> Attention):
      - counts enemy UNITS and STRUCTURES we currently see this tick
      - also extracts "what's in enemy main" and structure build_progress stats
      - detects whether enemy natural townhall is on the ground (visible)

    Rule: no side-effects. Strict positioning sources (no fallbacks).
    """
    enemy_main = _enemy_main_strict(bot)
    enemy_nat = _enemy_natural_from_expansions(bot, enemy_main)

    # radii are deliberately "loose" so we don't miss mineral line / tech placements
    main_radius = 26.0
    natural_radius = 10.0

    units_all = Counter()
    structs_all = Counter()
    units_main = Counter()
    structs_main = Counter()

    progress_by_type: Dict[U, list[float]] = defaultdict(list)

    # enemy units currently visible
    for u in bot.enemy_units:
        try:
            tid = u.type_id
            units_all[tid] += 1
            if u.position.distance_to(enemy_main) <= main_radius:
                units_main[tid] += 1
        except Exception:
            continue

    # enemy structures currently visible (+ progress stats)
    for s in bot.enemy_structures:
        try:
            tid = s.type_id
            structs_all[tid] += 1

            # build_progress is meaningful for "ongoing vs ready"
            prog = float(getattr(s, "build_progress", 1.0))
            # clamp for sanity
            if prog < 0.0:
                prog = 0.0
            if prog > 1.0:
                prog = 1.0
            progress_by_type[tid].append(prog)

            if s.position.distance_to(enemy_main) <= main_radius:
                structs_main[tid] += 1
        except Exception:
            continue

    # natural townhall visibility
    natural_on_ground = False
    nat_best_prog: Optional[float] = None
    nat_best_type: Optional[U] = None
    if enemy_nat is not None:
        for s in bot.enemy_structures:
            try:
                if s.type_id not in _TOWNHALL_TYPES:
                    continue
                if s.position.distance_to(enemy_nat) <= natural_radius:
                    natural_on_ground = True
                    prog = float(getattr(s, "build_progress", 1.0))
                    if nat_best_prog is None or prog > nat_best_prog:
                        nat_best_prog = prog
                        nat_best_type = s.type_id
            except Exception:
                continue

    progress_stats = {tid: _progress_stats(vals) for tid, vals in progress_by_type.items()}

    return EnemyBuildSnapshot(
        enemy_units=dict(units_all),
        enemy_structures=dict(structs_all),
        enemy_main_pos=enemy_main,
        enemy_natural_pos=enemy_nat,
        enemy_units_main=dict(units_main),
        enemy_structures_main=dict(structs_main),
        enemy_structures_progress=progress_stats,
        enemy_natural_on_ground=bool(natural_on_ground),
        enemy_natural_townhall_progress=float(nat_best_prog) if nat_best_prog is not None else None,
        enemy_natural_townhall_type=nat_best_type,
    )
```
# bot/sensors/macro_sensor.py
```python
# bot/sensors/macro_sensor.py
from __future__ import annotations

from sc2.ids.unit_typeid import UnitTypeId
from bot.mind.attention import MacroSnapshot


def _opening_done(bot) -> bool:
    bor = getattr(bot, "build_order_runner", None)
    if bor is None:
        return False
    if not hasattr(bor, "build_completed"):
        raise AttributeError("Macro sensor requires build_order_runner.build_completed")

    return bool(bor.build_completed)


def _get_bases(bot):
    # Terran bases: CommandCenter, OrbitalCommand, PlanetaryFortress
    base_types = {
        UnitTypeId.COMMANDCENTER,
        UnitTypeId.ORBITALCOMMAND,
        UnitTypeId.PLANETARYFORTRESS,
    }
    return bot.townhalls.filter(lambda u: u.type_id in base_types)


def _get_production_structures(bot):
    # Terran production
    prod_types = {
        UnitTypeId.BARRACKS,
        UnitTypeId.FACTORY,
        UnitTypeId.STARPORT,
    }
    return bot.structures.filter(lambda u: u.type_id in prod_types and u.is_ready)


def derive_macro_snapshot(bot) -> MacroSnapshot:

    # --- Economy ---
    minerals = int(bot.minerals)
    vespene = int(bot.vespene)

    workers = bot.workers
    workers_total = workers.amount
    workers_idle = workers.idle.amount

    # --- Bases / Saturation ---
    bases = _get_bases(bot)
    bases_total = bases.amount

    bases_under = 0
    bases_over = 0

    for base in bases:
        assigned = base.assigned_harvesters
        ideal = base.ideal_harvesters

        if ideal == 0:
            continue

        if assigned < ideal:
            bases_under += 1
        elif assigned > ideal:
            bases_over += 1

    # --- Production structures ---
    prod_structs = _get_production_structures(bot)
    prod_structures_total = prod_structs.amount

    prod_structures_idle = prod_structs.idle.amount
    prod_structures_active = prod_structures_total - prod_structures_idle

    # --- Supply ---
    supply_used = bot.supply_used
    supply_cap = bot.supply_cap
    supply_left = supply_cap - supply_used
    supply_blocked = supply_left <= 0

    return MacroSnapshot(
        opening_done=bool(_opening_done(bot)),

        minerals=minerals,
        vespene=vespene,

        workers_total=workers_total,
        workers_idle=workers_idle,

        bases_total=bases_total,
        bases_under_saturated=bases_under,
        bases_over_saturated=bases_over,

        prod_structures_total=prod_structures_total,
        prod_structures_idle=prod_structures_idle,
        prod_structures_active=prod_structures_active,

        supply_used=supply_used,
        supply_cap=supply_cap,
        supply_left=supply_left,
        supply_blocked=supply_blocked,
    )
```
# bot/sensors/orbital_sensor.py
```python
# bot/sensors/orbital_sensor.py
from __future__ import annotations

from typing import Tuple

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.mind.attention import IntelSnapshot


def _orbital_scan_status(bot) -> Tuple[bool, float]:
    """
    Returns (ready_to_scan, energy).
    Rule: no side-effects.
    """
    try:
        orbitals = bot.structures(U.ORBITALCOMMAND).ready
        if orbitals.amount == 0:
            return False, 0.0
        oc = orbitals.first
        energy = float(getattr(oc, "energy", 0.0) or 0.0)
        return (energy >= 50.0), energy
    except Exception:
        return False, 0.0


def derive_orbital_snapshot(bot) -> IntelSnapshot:
    ready, energy = _orbital_scan_status(bot)
    return IntelSnapshot(
        orbital_ready_to_scan=bool(ready),
        orbital_energy=float(energy),
    )
```
# bot/sensors/threat_sensor.py
```python
# bot/sensors/threat_sensor.py
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional, Tuple

from sc2.position import Point2
from sc2.unit import Unit


@dataclass(frozen=True)
class ThreatReport:
    threatened: bool
    threat_pos: Optional[Point2]
    enemy_count: int
    radius: float
    urgency: int  # 0..100


class Threat:
    """
    Intelligence-only:
      - Detecta inimigos perto de townhalls
      - Produz threat_pos + enemy_count + urgency
    """

    def __init__(self, *, defend_radius: float = 22.0, min_enemy: int = 1):
        self.defend_radius = float(defend_radius)
        self.min_enemy = int(min_enemy)

    def _townhalls(self, bot) -> List[Unit]:
        try:
            return list(bot.townhalls)
        except Exception:
            return []

    def evaluate(self, bot) -> ThreatReport:
        ths = self._townhalls(bot)
        if not ths:
            return ThreatReport(False, None, 0, self.defend_radius, 0)

        enemies = bot.enemy_units
        if not enemies:
            return ThreatReport(False, None, 0, self.defend_radius, 0)

        best: Tuple[int, Optional[Point2]] = (0, None)
        for th in ths:
            near = enemies.closer_than(self.defend_radius, th.position)
            c = int(near.amount)
            if c > best[0]:
                best = (c, th.position)

        threatened = best[0] >= self.min_enemy
        enemy_count = int(best[0])

        # urgência simples (MVP): ameaça => 50 + 10*count, cap 100
        urgency = 0
        if threatened:
            urgency = min(100, 50 + 10 * enemy_count)

        return ThreatReport(threatened, best[1], enemy_count, self.defend_radius, int(urgency))
```
## bot/tasks (full)
# bot/tasks/__init__.py
```python

```
# bot/tasks/base_task.py
```python
# bot/tasks/base_task.py
from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import Optional, Protocol, runtime_checkable
import copy

from bot.mind.attention import Attention


class TaskStatus(str, Enum):
    """
    Task lifecycle. Keep values stable because logs/debug will depend on this.
    """
    IDLE = "IDLE"
    ACTIVE = "ACTIVE"
    PAUSED = "PAUSED"
    DONE = "DONE"
    ABORTED = "ABORTED"


@dataclass(frozen=True)
class TaskTick:
    iteration: int
    time: float


@dataclass(frozen=True)
class TaskResult:
    """
    Execution feedback (task -> Ego). STRICT contract: tasks must return TaskResult.

    status:
      - RUNNING: task continues as active mission
      - DONE: task completed successfully (mission can end)
      - FAILED: task failed (mission should end; Ego applies cooldown etc.)
      - NOOP: task chose to do nothing this tick (still running)
    """
    status: str  # RUNNING | DONE | FAILED | NOOP
    reason: str = ""
    retry_after_s: float = 0.0
    telemetry: Optional[dict] = None

    @staticmethod
    def running(reason: str = "", telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="RUNNING", reason=str(reason), telemetry=telemetry)

    @staticmethod
    def done(reason: str = "", telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="DONE", reason=str(reason), telemetry=telemetry)

    @staticmethod
    def failed(reason: str = "", retry_after_s: float = 0.0, telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="FAILED", reason=str(reason), retry_after_s=float(retry_after_s), telemetry=telemetry)

    @staticmethod
    def noop(reason: str = "", telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="NOOP", reason=str(reason), telemetry=telemetry)


@runtime_checkable
class Task(Protocol):
    """
    Contract required by Ego + planners.

    Notes:
    - domain is a string slot key (e.g. "DEFENSE", "INTEL")
    - step() returns TaskResult (STRICT)
    """
    task_id: str
    domain: str
    commitment: int

    def status(self) -> TaskStatus: ...
    def is_done(self) -> bool: ...
    def evaluate(self, bot, attention: Attention) -> int: ...
    def bind_mission(self, *, mission_id: str, assigned_tags: list[int]) -> None: ...
    async def step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult: ...
    async def pause(self, bot, reason: str) -> None: ...
    async def abort(self, bot, reason: str) -> None: ...
    def last_reason(self) -> str: ...
    def last_step_time(self) -> float: ...
    def spawn(self) -> "BaseTask": ...


@dataclass
class BaseTask:
    """
    Convenience base class.

    Policy:
      - NO legacy bool returns. on_step MUST return TaskResult.
      - Mission binding is explicit via bind_mission(); no setattr fallbacks.
    """
    task_id: str
    domain: str
    commitment: int  # NOTE: required (no default) to avoid dataclass field-order issues in subclasses

    # mission binding (set by Ego)
    mission_id: Optional[str] = field(default=None, init=False)
    assigned_tags: list[int] = field(default_factory=list, init=False)

    # internal state
    _status: TaskStatus = field(default=TaskStatus.IDLE, init=False)
    _last_reason: str = field(default="", init=False)
    _last_step_t: float = field(default=0.0, init=False)

    # -----------------------
    # Core contract
    # -----------------------
    def status(self) -> TaskStatus:
        return self._status

    def is_done(self) -> bool:
        return self._status in (TaskStatus.DONE, TaskStatus.ABORTED)

    def evaluate(self, bot, attention: Attention) -> int:
        return 0

    def bind_mission(self, *, mission_id: str, assigned_tags: list[int]) -> None:
        if not isinstance(mission_id, str) or not mission_id:
            raise ValueError("mission_id must be a non-empty string")
        self.mission_id = mission_id
        self.assigned_tags = [int(x) for x in (assigned_tags or [])]

    async def step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        if self.is_done():
            return TaskResult.noop("already_done")

        if self._status == TaskStatus.IDLE:
            self._status = TaskStatus.ACTIVE

        self._last_step_t = float(tick.time)

        out = await self.on_step(bot, tick, attention)

        if not isinstance(out, TaskResult):
            raise TypeError(f"{self.__class__.__name__}.on_step must return TaskResult, got {type(out)!r}")

        return out

    async def pause(self, bot, reason: str) -> None:
        if self.is_done():
            return
        self._status = TaskStatus.PAUSED
        self._last_reason = str(reason)

    async def abort(self, bot, reason: str) -> None:
        if self.is_done():
            return
        self._status = TaskStatus.ABORTED
        self._last_reason = str(reason)

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        raise NotImplementedError

    # -----------------------
    # Helpers (optional)
    # -----------------------
    def _done(self, reason: str = "") -> None:
        self._status = TaskStatus.DONE
        self._last_reason = str(reason)

    def _active(self, reason: str = "") -> None:
        self._status = TaskStatus.ACTIVE
        if reason:
            self._last_reason = str(reason)

    def _paused(self, reason: str = "") -> None:
        self._status = TaskStatus.PAUSED
        if reason:
            self._last_reason = str(reason)

    def last_reason(self) -> str:
        return self._last_reason

    def last_step_time(self) -> float:
        return float(self._last_step_t)

    def spawn(self) -> "BaseTask":
        """
        Create a fresh instance of this task (for multiple missions using same script).
        This is a deep copy + reset of lifecycle and mission binding.
        """
        t: BaseTask = copy.deepcopy(self)
        t._status = TaskStatus.IDLE
        t._last_reason = ""
        t._last_step_t = 0.0
        t.mission_id = None
        t.assigned_tags = []
        return t
```
# bot/tasks/control_depots_task.py
```python
# bot/tasks/control_depots_task.py
from __future__ import annotations

from dataclasses import dataclass

from sc2.ids.ability_id import AbilityId
from sc2.ids.unit_typeid import UnitTypeId as U

from bot.mind.attention import Attention
from bot.mind.awareness import Awareness, K
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class ControlDepots(BaseTask):
    """
    Global wall-depot control with no unit leases.
    Raises on nearby threat, lowers otherwise.
    """

    awareness: Awareness

    def __init__(self, *, awareness: Awareness):
        super().__init__(task_id="control_depots", domain="MACRO_DEPOT_CONTROL", commitment=0)
        self.awareness = awareness

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        now = float(tick.time)
        threatened = bool(attention.combat.threatened) and bool(attention.combat.threat_pos)

        issued = 0
        action = "none"

        if threatened:
            lowered = bot.structures.of_type({U.SUPPLYDEPOTLOWERED}).ready
            for depot in lowered:
                depot(AbilityId.MORPH_SUPPLYDEPOT_RAISE)
                issued += 1
            action = "raise"
        else:
            raised = bot.structures.of_type({U.SUPPLYDEPOT}).ready
            for depot in raised:
                depot(AbilityId.MORPH_SUPPLYDEPOT_LOWER)
                issued += 1
            action = "lower"

        self.awareness.mem.set(K("macro", "wall", "depot_control", "last_done_at"), value=now, now=now, ttl=None)
        self.awareness.mem.set(K("macro", "wall", "depot_control", "last_action"), value=action, now=now, ttl=None)

        self._done("depots_controlled")
        return TaskResult.done(
            "depots_controlled",
            telemetry={
                "threatened": bool(threatened),
                "action": str(action),
                "orders": int(issued),
            },
        )
```
# bot/tasks/defend_task.py
```python
# bot/tasks/defend_task.py
from __future__ import annotations

from dataclasses import dataclass

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class Defend(BaseTask):
    """
    Defesa reativa das bases.
    """
    log: DevLogger | None = None
    log_every_iters: int = 11

    def __init__(self, *, log: DevLogger | None = None, log_every_iters: int = 11):
        super().__init__(task_id="defend_bases", domain="DEFENSE", commitment=90)
        self.log = log
        self.log_every_iters = int(log_every_iters)

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        if (not attention.combat.threatened) or (not attention.combat.threat_pos):
            self._paused("no_threat")
            return TaskResult.noop("no_threat")

        defenders = bot.units.of_type(
            {
                U.MARINE,
                U.MARAUDER,
                U.SIEGETANK,
                U.SIEGETANKSIEGED,
                U.HELLION,
                U.CYCLONE,
                U.THOR,
                U.THORAP,
                U.MEDIVAC,
            }
        )
        if defenders.amount == 0:
            self._paused("no_defenders")
            return TaskResult.noop("no_defenders")

        local = defenders.closer_than(45, attention.combat.threat_pos)
        if local.amount == 0:
            local = defenders

        medivacs = local(U.MEDIVAC)
        army = local - medivacs

        issued = False

        for u in army:
            if u.is_idle:
                u.attack(attention.combat.threat_pos)
                issued = True

        for m in medivacs:
            if m.is_idle:
                m.move(attention.combat.threat_pos.towards(bot.start_location, 6))
                issued = True

        if issued:
            self._active("defending")
            if self.log and (tick.iteration % self.log_every_iters == 0):
                self.log.emit(
                    "defend_tick",
                    {
                        "iteration": int(tick.iteration),
                        "time": round(float(getattr(bot, "time", 0.0)), 2),
                        "enemy_count": int(attention.combat.enemy_count_near_bases),
                        "urgency": int(attention.combat.defense_urgency),
                        "pos": [round(attention.combat.threat_pos.x, 1), round(attention.combat.threat_pos.y, 1)],
                    },
                )
            return TaskResult.running("defending")
        else:
            self._active("defending_no_orders")
            return TaskResult.noop("defending_no_orders")
```
# bot/tasks/macro/__init__.py
```python
from bot.tasks.macro.opening import MacroOpeningTick
from bot.tasks.macro.production_tick import MacroProductionTick
from bot.tasks.macro.scv_housekeeping_task import ScvHousekeeping
from bot.tasks.macro.spending_tick import MacroSpendingTick

__all__ = [
    "MacroOpeningTick",
    "MacroProductionTick",
    "MacroSpendingTick",
    "ScvHousekeeping",
]
```
# bot/tasks/macro/macro_task.py
```python
# bot/tasks/macro_task.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict

from ares.behaviors.macro.auto_supply import AutoSupply
from ares.behaviors.macro.build_workers import BuildWorkers
from ares.behaviors.macro.expansion_controller import ExpansionController
from ares.behaviors.macro.gas_building_controller import GasBuildingController
from ares.behaviors.macro.macro_plan import MacroPlan
from ares.behaviors.macro.production_controller import ProductionController
from ares.behaviors.macro.spawn_controller import SpawnController
from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class MacroOpeningTick(BaseTask):
    """
    Opening macro minimalista:
      - SCV contínuo até scv_cap

    (Mantido propositalmente simples. O build runner/YML pode cuidar do resto do opening.)
    """
    log: DevLogger | None = None
    log_every_iters: int = 22
    scv_cap: int = 60

    def __init__(self, *, log: DevLogger | None = None, log_every_iters: int = 22, scv_cap: int = 60):
        super().__init__(task_id="macro_opening_scv_only", domain="MACRO", commitment=10)
        self.log = log
        self.log_every_iters = int(log_every_iters)
        self.scv_cap = int(scv_cap)

    def _workers(self, bot) -> int:
        return int(bot.workers.amount)

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        ths = bot.townhalls.ready
        if ths.amount == 0:
            self._paused("no_townhalls")
            return TaskResult.noop("no_townhalls")

        if int(bot.supply_left) <= 0:
            self._paused("no_supply")
            return TaskResult.noop("no_supply")

        if self._workers(bot) >= self.scv_cap:
            self._active("scv_cap")
            return TaskResult.noop("scv_cap")

        if not bot.can_afford(U.SCV):
            self._paused("cant_afford_scv")
            return TaskResult.noop("cant_afford_scv")

        idle_ths = ths.idle
        if idle_ths.amount == 0:
            self._active("townhalls_busy")
            return TaskResult.noop("townhalls_busy")

        idle_ths.first.train(U.SCV)
        self._active("training_scv_opening")

        if self.log and (tick.iteration % self.log_every_iters == 0):
            self.log.emit(
                "macro_opening",
                {"iter": int(tick.iteration), "t": round(float(tick.time), 2), "action": "train_scv"},
            )

        return TaskResult.running("train_scv")


# ---------------------------
# Ares-powered macro builds
# ---------------------------

def _register_macro_plan(bot, plan, *, log: DevLogger | None, tick: TaskTick, label: str) -> None:
    """
    Strict: relies on AresBot.register_behavior existing.
    This is inside macro task, not planner/ego.
    """
    bot.register_behavior(plan)
    if log and (tick.iteration % 22 == 0):
        log.emit("macro_ares_plan", {"iter": int(tick.iteration), "t": round(float(tick.time), 2), "label": str(label)})


@dataclass
class MacroAresBioStandardTick(BaseTask):
    """
    Standard macro (BIO-ish) using Ares MacroPlan behaviors.

    Goal: "never stalls" macro:
      - autosupply
      - continuous workers (to scv_cap)
      - expand to 2 bases (can bump later)
      - basic production + spawn loop (marines + occasional medivac)
    """
    log: DevLogger | None = None
    scv_cap: int = 66
    target_bases: int = 2

    def __init__(self, *, log: DevLogger | None = None, scv_cap: int = 66, target_bases: int = 2):
        super().__init__(task_id="macro_ares_bio_standard", domain="MACRO", commitment=15)
        self.log = log
        self.scv_cap = int(scv_cap)
        self.target_bases = int(target_bases)

    def _army_comp(self) -> Dict[U, int]:
        # Weights (not absolute caps). Keep simple & robust.
        return {
            U.MARINE: 10,
            U.MEDIVAC: 2,
        }

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        plan = MacroPlan()

        # Priority order matters: MacroPlan executes behaviors sequentially and stops after a successful one.
        plan.add(AutoSupply(base_location=bot.start_location))
        plan.add(BuildWorkers(to_count=int(self.scv_cap)))
        plan.add(GasBuildingController(to_count=max(0, int(len(bot.townhalls)) * 2)))
        plan.add(ExpansionController(to_base_count=int(self.target_bases)))
        plan.add(ProductionController())
        plan.add(SpawnController(army_composition_dict=self._army_comp()))

        _register_macro_plan(bot, plan, log=self.log, tick=tick, label="BIO_STANDARD")
        self._active("ares_macro_standard")
        return TaskResult.running("ares_macro_standard")


@dataclass
class MacroAresRushDefenseTick(BaseTask):
    """
    Rush-defense macro using Ares MacroPlan behaviors.

    Philosophy:
      - DO NOT expand
      - Keep workers going (but lower cap)
      - Spend on immediate army
      - Keep supply safe
    """
    log: DevLogger | None = None
    scv_cap: int = 40
    target_bases: int = 1

    def __init__(self, *, log: DevLogger | None = None, scv_cap: int = 40, target_bases: int = 1):
        super().__init__(task_id="macro_ares_rush_defense", domain="MACRO", commitment=20)
        self.log = log
        self.scv_cap = int(scv_cap)
        self.target_bases = int(target_bases)

    def _army_comp(self) -> Dict[U, int]:
        # Pure "don't die" comp. You can enrich later (marauder, bunker logic, etc).
        return {
            U.MARINE: 14,
        }

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        plan = MacroPlan()
        plan.add(AutoSupply(base_location=bot.start_location))
        plan.add(BuildWorkers(to_count=int(self.scv_cap)))
        plan.add(ExpansionController(to_base_count=int(self.target_bases)))  # locks at 1
        plan.add(ProductionController())
        plan.add(SpawnController(army_composition_dict=self._army_comp()))

        _register_macro_plan(bot, plan, log=self.log, tick=tick, label="RUSH_DEFENSE")
        self._active("ares_macro_rush_defense")
        return TaskResult.running("ares_macro_rush_defense")
```
# bot/tasks/macro/opening.py
```python
# bot/tasks/macro/opening.py
from __future__ import annotations

from dataclasses import dataclass

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class MacroOpeningTick(BaseTask):
    """
    Opening macro minimalista:
      - SCV contínuo até scv_cap

    Mantido simples de propósito. (BuildRunner/YML pode cuidar do resto do opening.)
    """
    log: DevLogger | None = None
    log_every_iters: int = 22
    scv_cap: int = 60

    def __init__(self, *, log: DevLogger | None = None, log_every_iters: int = 22, scv_cap: int = 60):
        super().__init__(task_id="macro_opening_scv_only", domain="MACRO", commitment=10)
        self.log = log
        self.log_every_iters = int(log_every_iters)
        self.scv_cap = int(scv_cap)

    def _workers(self, bot) -> int:
        return int(bot.workers.amount)

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        ths = bot.townhalls.ready
        if ths.amount == 0:
            self._paused("no_townhalls")
            return TaskResult.noop("no_townhalls")

        if int(bot.supply_left) <= 0:
            self._paused("no_supply")
            return TaskResult.noop("no_supply")

        if self._workers(bot) >= self.scv_cap:
            self._active("scv_cap")
            return TaskResult.noop("scv_cap")

        if not bot.can_afford(U.SCV):
            self._paused("cant_afford_scv")
            return TaskResult.noop("cant_afford_scv")

        idle_ths = ths.idle
        if idle_ths.amount == 0:
            self._active("townhalls_busy")
            return TaskResult.noop("townhalls_busy")

        idle_ths.first.train(U.SCV)
        self._active("training_scv_opening")

        if self.log and (tick.iteration % self.log_every_iters == 0):
            self.log.emit(
                "macro_opening",
                {"iter": int(tick.iteration), "t": round(float(tick.time), 2), "action": "train_scv"},
            )

        return TaskResult.running("train_scv")
```
# bot/tasks/macro/production_tick.py
```python
from __future__ import annotations

from dataclasses import dataclass

from ares.behaviors.macro.build_workers import BuildWorkers
from ares.behaviors.macro.macro_plan import MacroPlan
from ares.behaviors.macro.spawn_controller import SpawnController
from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness, K
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class MacroProductionTick(BaseTask):
    awareness: Awareness
    log: DevLogger | None = None
    scv_cap: int = 66
    log_every_iters: int = 22

    def __init__(
        self,
        *,
        awareness: Awareness,
        log: DevLogger | None = None,
        scv_cap: int = 66,
        log_every_iters: int = 22,
    ):
        super().__init__(task_id="macro_production", domain="MACRO_PRODUCTION", commitment=10)
        self.awareness = awareness
        self.log = log
        self.scv_cap = int(scv_cap)
        self.log_every_iters = int(log_every_iters)

    @staticmethod
    def _normalize(comp: dict[U, float]) -> dict[U, float]:
        total = float(sum(float(v) for v in comp.values()))
        if total <= 0.0:
            return comp
        return {k: float(v) / total for k, v in comp.items()}

    def _desired_comp(self, now: float) -> dict[U, float]:
        raw = self.awareness.mem.get(K("macro", "desired", "comp"), now=now, default=None)

        comp: dict[U, float] = {}
        if isinstance(raw, dict):
            for k, v in raw.items():
                if not isinstance(k, str):
                    continue
                try:
                    uid = getattr(U, k)
                except Exception:
                    continue
                try:
                    fv = float(v)
                except Exception:
                    continue
                if fv > 0:
                    comp[uid] = fv

        if not comp:
            comp = {
                U.MARINE: 0.60,
                U.MARAUDER: 0.25,
                U.MEDIVAC: 0.15,
            }

        return self._normalize(comp)

    def _spawn_dict(self, now: float) -> dict[U, dict[str, float | int]]:
        comp = self._desired_comp(now)
        ordered = sorted(comp.items(), key=lambda kv: kv[1], reverse=True)
        out: dict[U, dict[str, float | int]] = {}
        for idx, (uid, proportion) in enumerate(ordered):
            out[uid] = {"proportion": float(proportion), "priority": int(idx)}
        return out

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        if not isinstance(self.mission_id, str) or not self.mission_id:
            return TaskResult.failed("unbound_mission")

        now = float(tick.time)
        spawn_dict = self._spawn_dict(now)

        plan = MacroPlan()
        plan.add(BuildWorkers(to_count=int(self.scv_cap)))
        plan.add(
            SpawnController(
                army_composition_dict=spawn_dict,
                freeflow_mode=bool(attention.economy.minerals >= 1200),
                ignore_proportions_below_unit_count=8,
                over_produce_on_low_tech=True,
            )
        )

        bot.register_behavior(plan)

        if self.log is not None and (int(tick.iteration) % self.log_every_iters == 0):
            self.log.emit(
                "macro_production",
                {
                    "iter": int(tick.iteration),
                    "t": round(float(now), 2),
                    "scv_cap": int(self.scv_cap),
                    "units": [u.name for u in spawn_dict.keys()],
                },
            )

        return TaskResult.running("production_plan_registered")
```
# bot/tasks/macro/scv_housekeeping_task.py
```python
# =============================================================================
# bot/tasks/macro/scv_housekeeping_task.py  (MODIFIED: domain)
# =============================================================================
from __future__ import annotations

from dataclasses import dataclass

from ares.consts import UnitRole
from sc2.ids.unit_typeid import UnitTypeId as U

from bot.mind.attention import Attention
from bot.mind.awareness import Awareness, K
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class ScvHousekeeping(BaseTask):
    """
    Light-weight SCV housekeeping.
    - Planner decides WHEN to run (interval / sensors later).
    - Task decides HOW with assigned SCV(s).
    - Must be safe, fast, and idempotent.

    Policy:
      1) Gas first: keep 3 workers per refinery.
      2) Minerals main: keep up to 16 mineral workers in main.
      3) Overflow: send remaining mineral workers to natural.
    """

    awareness: Awareness
    max_reassign_per_run: int = 4
    mineral_balance_margin: int = 1

    def __init__(self, *, awareness: Awareness):
        # Global housekeeping task: no unit leases are required.
        super().__init__(task_id="scv_housekeeping", domain="MACRO_HOUSEKEEPING", commitment=0)
        self.awareness = awareness
        self.max_reassign_per_run = 4
        self.mineral_balance_margin = 1

    def evaluate(self, bot, attention: Attention) -> int:
        return 10

    @staticmethod
    def _assign_worker_to_mineral(worker, mineral_fields) -> None:
        if mineral_fields.amount == 0:
            return
        worker.gather(mineral_fields.closest_to(worker))

    def _reserved_running_tags(self, now: float) -> set[int]:
        """
        Tags currently assigned to RUNNING missions in Ego/Awareness.
        Housekeeping must not retask these workers.
        """
        out: set[int] = set()
        try:
            facts = self.awareness.mem._facts.items()
        except Exception:
            return out

        for k, _f in facts:
            if len(k) < 4:
                continue
            if k[0] != "ops" or k[1] != "mission" or k[-1] != "status":
                continue
            mission_id = k[2]
            st = str(self.awareness.mem.get(K("ops", "mission", mission_id, "status"), now=now, default=""))
            if st != "RUNNING":
                continue
            tags = self.awareness.mem.get(K("ops", "mission", mission_id, "assigned_tags"), now=now, default=[])
            if not isinstance(tags, list):
                continue
            for t in tags:
                try:
                    out.add(int(t))
                except Exception:
                    pass
        return out

    def _rebalance_workers(self, bot, *, now: float) -> tuple[int, int, int, int]:
        workers = bot.mediator.get_units_from_role(role=UnitRole.GATHERING, unit_type=U.SCV)
        if workers.amount == 0:
            return 0, 0, 0, 0

        townhalls = bot.townhalls.ready
        if townhalls.amount == 0:
            return 0, 0, 0, 0

        reserved_tags = self._reserved_running_tags(now)
        try:
            bo_scouts = bot.mediator.get_units_from_role(role=UnitRole.BUILD_RUNNER_SCOUT, unit_type=U.SCV)
            reserved_tags.update(int(u.tag) for u in bo_scouts)
        except Exception:
            pass

        worker_to_gas = bot.mediator.get_worker_to_vespene_dict
        worker_to_th = bot.mediator.get_worker_tag_to_townhall_tag

        own_bases = list(townhalls)

        def _is_local_worker(worker) -> bool:
            # Do not retask distant workers (typically scouting/pathing units).
            if not own_bases:
                return True
            try:
                nearest = min(float(worker.distance_to(th.position)) for th in own_bases)
                return nearest <= 18.0
            except Exception:
                return True

        mineral_workers = [
            w for w in workers
            if int(w.tag) not in worker_to_gas
            and int(w.tag) not in reserved_tags
            and _is_local_worker(w)
        ]
        if not mineral_workers:
            return 0, 0, 0, len(reserved_tags)

        moved_tags: set[int] = set()
        moved_to_gas = 0
        remaining_budget = int(self.max_reassign_per_run)

        # 1) Gas saturation first.
        gas_deficit = 0
        gas_buildings = [g for g in bot.gas_buildings if g.is_ready]
        for gas in gas_buildings:
            assigned = int(getattr(gas, "assigned_harvesters", 0) or 0)
            ideal = int(getattr(gas, "ideal_harvesters", 0) or 0)
            if ideal <= 0:
                continue
            need = max(0, ideal - assigned)
            gas_deficit += int(need)
            if need <= 0 or remaining_budget <= 0:
                continue

            donors = sorted(
                [w for w in mineral_workers if int(w.tag) not in moved_tags],
                key=lambda w: w.distance_to(gas),
            )
            for worker in donors:
                if need <= 0 or remaining_budget <= 0:
                    break
                wtag = int(worker.tag)
                worker.gather(gas)
                moved_tags.add(wtag)
                moved_to_gas += 1
                remaining_budget -= 1
                need -= 1

        # If we used the whole budget on gas, stop here.
        if remaining_budget <= 0:
            return gas_deficit, moved_to_gas, 0, len(reserved_tags)

        # Mineral-only target per base. Keep conservative to avoid large swings.
        desired_per_base = 16

        deficits: list[tuple[object, int]] = []
        surplus_by_base: dict[int, list] = {}
        total_deficit = 0

        for th in townhalls:
            th_tag = int(th.tag)
            base_min_workers = [
                w for w in mineral_workers
                if int(worker_to_th.get(int(w.tag), -1)) == th_tag and int(w.tag) not in moved_tags
            ]
            count = len(base_min_workers)
            if count < (desired_per_base - int(self.mineral_balance_margin)):
                need = desired_per_base - count
                deficits.append((th, need))
                total_deficit += need
            elif count > (desired_per_base + int(self.mineral_balance_margin)):
                excess = count - desired_per_base
                # Prefer moving farthest workers first when base is over target.
                surplus_by_base[th_tag] = sorted(
                    base_min_workers, key=lambda w: w.distance_to(th.position), reverse=True
                )[:excess]

        if not deficits:
            return gas_deficit, moved_to_gas, 0, len(reserved_tags)

        # Only pull from truly oversaturated bases; never drain balanced bases.
        donors_primary = []
        for items in surplus_by_base.values():
            donors_primary.extend(items)
        if not donors_primary:
            return gas_deficit, moved_to_gas, total_deficit, len(reserved_tags)

        moved_to_minerals = 0

        for th, need in deficits:
            if moved_to_minerals >= remaining_budget:
                break
            mineral_fields = bot.mineral_field.closer_than(10.0, th.position)
            if mineral_fields.amount == 0:
                continue

            need_left = int(need)
            primary_sorted = sorted(
                [w for w in donors_primary if int(w.tag) not in moved_tags],
                key=lambda w: w.distance_to(th),
            )
            for worker in primary_sorted:
                if need_left <= 0:
                    break
                if moved_to_minerals >= remaining_budget:
                    break
                wtag = int(worker.tag)
                self._assign_worker_to_mineral(worker, mineral_fields)
                moved_tags.add(wtag)
                moved_to_minerals += 1
                need_left -= 1

        return gas_deficit, moved_to_gas, total_deficit, len(reserved_tags)

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        now = float(tick.time)

        gas_deficit, moved_to_gas, mineral_deficit, reserved = self._rebalance_workers(bot, now=now)

        # Mark last done time (planner uses it as interval gate).
        self.awareness.mem.set(K("macro", "scv", "housekeeping", "last_done_at"), value=float(now), now=now, ttl=None)

        self._done("housekeeping_done")
        return TaskResult.done(
            "housekeeping_done",
            telemetry={
                "gas_deficit": int(gas_deficit),
                "moved_to_gas": int(moved_to_gas),
                "mineral_deficit": int(mineral_deficit),
                "reserved_tags": int(reserved),
            },
        )
```
# bot/tasks/macro/spending_tick.py
```python
from __future__ import annotations

from dataclasses import dataclass

from ares.behaviors.macro.auto_supply import AutoSupply
from ares.behaviors.macro.expansion_controller import ExpansionController
from ares.behaviors.macro.gas_building_controller import GasBuildingController
from ares.behaviors.macro.macro_plan import MacroPlan
from ares.behaviors.macro.production_controller import ProductionController
from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness, K
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class MacroSpendingTick(BaseTask):
    awareness: Awareness
    log: DevLogger | None = None
    target_bases_default: int = 2
    flood_m: int = 800
    flood_hi_m: int = 1400
    flood_hold_s: float = 12.0
    log_every_iters: int = 22

    def __init__(
        self,
        *,
        awareness: Awareness,
        log: DevLogger | None = None,
        target_bases_default: int = 2,
        flood_m: int = 800,
        flood_hi_m: int = 1400,
        flood_hold_s: float = 12.0,
        log_every_iters: int = 22,
    ):
        super().__init__(task_id="macro_spending", domain="MACRO_SPENDING", commitment=10)
        self.awareness = awareness
        self.log = log
        self.target_bases_default = int(target_bases_default)
        self.flood_m = int(flood_m)
        self.flood_hi_m = int(flood_hi_m)
        self.flood_hold_s = float(flood_hold_s)
        self.log_every_iters = int(log_every_iters)

    @staticmethod
    def _normalize(comp: dict[U, float]) -> dict[U, float]:
        total = float(sum(float(v) for v in comp.values()))
        if total <= 0.0:
            return comp
        return {k: float(v) / total for k, v in comp.items()}

    def _desired_comp(self, now: float) -> dict[U, float]:
        raw = self.awareness.mem.get(K("macro", "desired", "comp"), now=now, default=None)

        comp: dict[U, float] = {}
        if isinstance(raw, dict):
            for k, v in raw.items():
                if not isinstance(k, str):
                    continue
                try:
                    uid = getattr(U, k)
                except Exception:
                    continue
                try:
                    fv = float(v)
                except Exception:
                    continue
                if fv > 0:
                    comp[uid] = fv

        if not comp:
            comp = {
                U.MARINE: 0.60,
                U.MARAUDER: 0.25,
                U.MEDIVAC: 0.15,
            }

        return self._normalize(comp)

    def _army_comp_for_controllers(self, now: float) -> dict[U, dict[str, float | int]]:
        comp = self._desired_comp(now)
        ordered = sorted(comp.items(), key=lambda kv: kv[1], reverse=True)
        out: dict[U, dict[str, float | int]] = {}
        for idx, (uid, proportion) in enumerate(ordered):
            out[uid] = {"proportion": float(proportion), "priority": int(idx)}
        return out

    def _target_bases(self, *, attention: Attention, now: float) -> int:
        minerals = int(attention.economy.minerals)

        flood_until = float(self.awareness.mem.get(K("macro", "spending", "flood_until"), now=now, default=0.0) or 0.0)
        if minerals >= self.flood_hi_m:
            flood_until = now + float(self.flood_hold_s)
            self.awareness.mem.set(K("macro", "spending", "flood_until"), value=float(flood_until), now=now, ttl=None)

        flood_active = minerals >= self.flood_m or now < flood_until

        target = int(self.target_bases_default)
        if flood_active:
            target += 1

        return max(1, int(target))

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        if not isinstance(self.mission_id, str) or not self.mission_id:
            return TaskResult.failed("unbound_mission")

        bor = getattr(bot, "build_order_runner", None)
        if bor is not None and not bool(getattr(bor, "build_completed", False)):
            return TaskResult.noop("build_order_active")

        now = float(tick.time)
        target_bases = self._target_bases(attention=attention, now=now)
        gas_target = max(0, int(attention.macro.bases_total) * 2)
        army_comp = self._army_comp_for_controllers(now)

        plan = MacroPlan()
        plan.add(AutoSupply(base_location=bot.start_location))
        plan.add(GasBuildingController(to_count=int(gas_target)))
        plan.add(ExpansionController(to_count=int(target_bases)))
        plan.add(
            ProductionController(
                army_composition_dict=army_comp,
                base_location=bot.start_location,
            )
        )

        bot.register_behavior(plan)

        if self.log is not None and (int(tick.iteration) % self.log_every_iters == 0):
            self.log.emit(
                "macro_spending",
                {
                    "iter": int(tick.iteration),
                    "t": round(float(now), 2),
                    "target_bases": int(target_bases),
                    "gas_target": int(gas_target),
                    "minerals": int(attention.economy.minerals),
                },
            )

        return TaskResult.running("spending_plan_registered")
```
# bot/tasks/reaper_scout_task.py
```python
# bot/tasks/reaper_scout_task.py
from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import Optional, Any

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


class ReaperScoutObjective(str, Enum):
    CONFIRM_NATURAL = "CONFIRM_NATURAL"
    CONFIRM_MAIN_RAMP = "CONFIRM_MAIN_RAMP"
    CONFIRM_MAIN = "CONFIRM_MAIN"
    MAP_CENTER = "MAP_CENTER"
    RETURN_HOME = "RETURN_HOME"


def _coerce_objective(obj: Any) -> ReaperScoutObjective:
    """
    Accept:
      - ReaperScoutObjective enum
      - raw value string: "CONFIRM_NATURAL"
      - qualified string: "ReaperScoutObjective.CONFIRM_NATURAL" (from str(enum))
    """
    if isinstance(obj, ReaperScoutObjective):
        return obj

    if isinstance(obj, str):
        s = obj.strip()
        # handle "ReaperScoutObjective.CONFIRM_NATURAL"
        if "." in s and s.startswith("ReaperScoutObjective."):
            s = s.split(".", 1)[1].strip()

        # prefer value lookup (Enum is str-based, so constructor matches values)
        try:
            return ReaperScoutObjective(s)
        except Exception:
            # also allow name lookup (in case caller passes "CONFIRM_NATURAL" as name)
            try:
                return ReaperScoutObjective[s]
            except Exception as e:
                raise ValueError(f"{obj!r} is not a valid ReaperScoutObjective") from e

    raise TypeError(f"objective must be ReaperScoutObjective or str, got {type(obj)}")


@dataclass
class ReaperScout(BaseTask):
    awareness: Awareness
    log: DevLogger | None = None

    objective: ReaperScoutObjective = ReaperScoutObjective.CONFIRM_NATURAL

    log_every: float = 6.0
    retreat_hp_frac: float = 0.40
    avoid_enemy_near_bases: int = 6
    arrive_radius_main: float = 4.5
    arrive_radius_nat: float = 7.0

    _last_log_t: float = field(default=0.0, init=False)
    _phase: int = field(default=0, init=False)

    def __init__(
        self,
        *,
        awareness: Awareness,
        log: DevLogger | None = None,
        objective: ReaperScoutObjective | str = ReaperScoutObjective.CONFIRM_NATURAL,
        log_every: float = 6.0,
        retreat_hp_frac: float = 0.40,
        arrive_radius_main: float = 4.5,
        arrive_radius_nat: float = 7.0,
    ):
        super().__init__(task_id="reaper_scout", domain="INTEL", commitment=7)
        self.awareness = awareness
        self.log = log

        # FIX: robust enum coercion
        self.objective = _coerce_objective(objective)

        self.log_every = float(log_every)
        self.retreat_hp_frac = float(retreat_hp_frac)
        self.arrive_radius_main = float(arrive_radius_main)
        self.arrive_radius_nat = float(arrive_radius_nat)
        self._last_log_t = 0.0
        self._phase = 0

    def evaluate(self, bot, attention: Attention) -> int:
        return 25

    def _enemy_main(self, bot) -> Point2:
        return bot.enemy_start_locations[0]

    def _enemy_natural(self, bot) -> Point2:
        enemy_main = self._enemy_main(bot)
        exps = list(getattr(bot, "expansion_locations_list", []) or [])
        if not exps:
            raise RuntimeError("expansion_locations_list unavailable for enemy natural computation")
        exps_sorted = sorted(exps, key=lambda p: p.distance_to(enemy_main))
        if len(exps_sorted) < 2:
            return exps_sorted[0]
        return exps_sorted[1]

    def _map_center(self, bot) -> Point2:
        gi = getattr(bot, "game_info", None)
        if gi is None:
            raise RuntimeError("game_info unavailable for map center")
        return gi.map_center

    def _log_tick(self, *, now: float, reason: str, tag: int, pos: Point2) -> None:
        if not self.log:
            return
        if (now - float(self._last_log_t)) < float(self.log_every):
            return
        self._last_log_t = float(now)
        self.log.emit(
            "reaper_scout_tick",
            {
                "t": round(float(now), 2),
                "mission_id": str(self.mission_id or ""),
                "tag": int(tag),
                "objective": str(self.objective.value),
                "phase": int(self._phase),
                "reason": str(reason),
                "pos": [round(float(pos.x), 1), round(float(pos.y), 1)],
            },
        )

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        now = float(tick.time)

        if not isinstance(self.mission_id, str) or not self.mission_id:
            return TaskResult.failed("unbound_mission")

        if not isinstance(self.assigned_tags, list) or len(self.assigned_tags) != 1:
            return TaskResult.failed("expected_exactly_1_assigned_tag")

        tag = int(self.assigned_tags[0])
        unit = bot.units.find_by_tag(tag)
        if unit is None:
            return TaskResult.failed("assigned_unit_missing")

        if unit.type_id != U.REAPER:
            return TaskResult.failed("assigned_unit_not_reaper")

        if bool(attention.combat.threatened) and int(attention.combat.enemy_count_near_bases) >= int(self.avoid_enemy_near_bases):
            unit.move(bot.start_location)
            self._active("retreat_home_under_threat")
            self._log_tick(now=now, reason="home_under_threat", tag=tag, pos=unit.position)
            return TaskResult.running("retreat_home_under_threat")

        hp_frac = float(unit.health_percentage) if hasattr(unit, "health_percentage") else 1.0
        if hp_frac <= float(self.retreat_hp_frac):
            unit.move(bot.start_location)
            self._active("retreat_low_hp")
            self._log_tick(now=now, reason="low_hp", tag=tag, pos=unit.position)
            return TaskResult.running("retreat_low_hp")

        if not self.awareness.intel_reaper_scout_dispatched(now=now):
            self.awareness.mark_reaper_scout_dispatched(now=now)

        if self.objective == ReaperScoutObjective.CONFIRM_NATURAL:
            nat = self._enemy_natural(bot)
            if self._phase == 0:
                if unit.distance_to(nat) <= float(self.arrive_radius_nat):
                    self._phase = 1
                else:
                    unit.move(nat)
                    self._active("move_enemy_natural")
                    self._log_tick(now=now, reason="to_natural", tag=tag, pos=unit.position)
                    return TaskResult.running("move_enemy_natural")

            main = self._enemy_main(bot)
            if unit.distance_to(main) <= float(self.arrive_radius_main):
                self.awareness.mark_reaper_scout_done(now=now)
                self._done("confirmed_natural_then_peeked_main")
                return TaskResult.done("confirmed_natural_then_peeked_main")

            unit.move(main)
            self._active("peek_enemy_main")
            self._log_tick(now=now, reason="peek_main", tag=tag, pos=unit.position)
            return TaskResult.running("peek_enemy_main")

        if self.objective == ReaperScoutObjective.CONFIRM_MAIN_RAMP:
            target = self._enemy_main(bot)
            if unit.distance_to(target) <= float(self.arrive_radius_main):
                self.awareness.mark_reaper_scout_done(now=now)
                self._done("peeked_enemy_main")
                return TaskResult.done("peeked_enemy_main")

            unit.move(target)
            self._active("move_enemy_main")
            self._log_tick(now=now, reason="to_main", tag=tag, pos=unit.position)
            return TaskResult.running("move_enemy_main")

        if self.objective == ReaperScoutObjective.MAP_CENTER:
            mc = self._map_center(bot)
            unit.move(mc)
            self._active("move_map_center")
            self._log_tick(now=now, reason="to_center", tag=tag, pos=unit.position)
            self.awareness.mark_reaper_scout_done(now=now)
            self._done("moved_map_center")
            return TaskResult.done("moved_map_center")

        if self.objective == ReaperScoutObjective.RETURN_HOME:
            unit.move(bot.start_location)
            self._active("return_home")
            self._log_tick(now=now, reason="return", tag=tag, pos=unit.position)
            self.awareness.mark_reaper_scout_done(now=now)
            self._done("returned_home")
            return TaskResult.done("returned_home")

        mc = self._map_center(bot)
        unit.move(mc)
        self._active("move_map_center_default")
        self._log_tick(now=now, reason="default_center", tag=tag, pos=unit.position)
        return TaskResult.running("move_map_center_default")
```
# bot/tasks/scan_task.py
```python
# bot/tasks/scan_task.py
from __future__ import annotations

from dataclasses import dataclass, field

from sc2.ids.ability_id import AbilityId
from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class ScanAt(BaseTask):
    # required deps first (avoid dataclass non-default-after-default errors)
    awareness: Awareness
    target: object
    label: str

    # config
    cooldown: float = 20.0
    log: DevLogger | None = None

    # internal state
    _last_scan_t: float = field(default=0.0, init=False)

    def __init__(self, *, awareness: Awareness, target, label: str, cooldown: float = 20.0, log: DevLogger | None = None):
        super().__init__(task_id="scan_at", domain="INTEL", commitment=5)
        self.awareness = awareness
        self.target = target
        self.label = str(label)
        self.cooldown = float(cooldown)
        self.log = log
        self._last_scan_t = 0.0

    def evaluate(self, bot, attention: Attention) -> int:
        now = float(attention.time)

        # if no orbital energy, don't propose high
        if not bool(attention.intel.orbital_ready_to_scan):
            return 0

        # cooldown
        if now - float(self._last_scan_t) < float(self.cooldown):
            return 0

        # if already scanned enemy main, reduce need
        if self.label == "enemy_main" and self.awareness.intel_scanned_enemy_main(now=now):
            return 0

        return 40

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        now = float(tick.time)

        if not bool(attention.intel.orbital_ready_to_scan):
            self._paused("no_orbital_energy")
            return TaskResult.noop("no_orbital_energy")

        if now - float(self._last_scan_t) < float(self.cooldown):
            self._paused("cooldown")
            return TaskResult.noop("cooldown")

        try:
            orbitals = bot.structures(U.ORBITALCOMMAND).ready
            if orbitals.amount == 0:
                self._paused("no_orbital")
                return TaskResult.noop("no_orbital")

            oc = orbitals.first
            target = self.target

            oc(AbilityId.SCANNERSWEEP_SCAN, target)
            self._last_scan_t = float(now)

            if self.label == "enemy_main":
                self.awareness.mark_scanned_enemy_main(now=now)

            if self.log:
                self.log.emit("scan_cast", {"t": round(float(now), 2), "label": str(self.label)})

            self._active("scan_cast")
            return TaskResult.running("scan_cast")

        except Exception:
            self._paused("scan_failed")
            return TaskResult.failed("scan_failed", retry_after_s=6.0)
```
# bot/tasks/scout_task.py
```python
# bot/tasks/scout_task.py
from __future__ import annotations

from dataclasses import dataclass, field

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class Scout(BaseTask):
    """
    Single SCV scout to enemy main.

    IMPORTANT POLICY:
      - This task MUST NOT decide if it's "time" to start scouting.
        That decision belongs to the planner.
      - This task MUST ONLY use the unit(s) assigned by Ego via bind_mission().
        Never request/select a new worker by itself (otherwise you end up with ALL SCVs scouting).
    """

    # required deps first (avoid dataclass non-default-after-default errors)
    awareness: Awareness

    # config
    log: DevLogger | None = None
    trigger_time: float = 25.0  # kept for planner to read; task does NOT gate on it
    log_every: float = 6.0
    see_radius: float = 14.0
    arrived_ttl: float = 120.0

    # internal state
    _last_log_t: float = field(default=0.0, init=False)

    def __init__(
        self,
        *,
        awareness: Awareness,
        log: DevLogger | None = None,
        trigger_time: float = 25.0,
        log_every: float = 6.0,
        see_radius: float = 14.0,
        arrived_ttl: float = 120.0,
    ):
        super().__init__(task_id="scout_scv", domain="INTEL", commitment=3)
        self.awareness = awareness
        self.log = log
        self.trigger_time = float(trigger_time)
        self.log_every = float(log_every)
        self.see_radius = float(see_radius)
        self.arrived_ttl = float(arrived_ttl)
        self._last_log_t = 0.0

    def evaluate(self, bot, attention: Attention) -> int:
        now = float(attention.time)

        # If already succeeded, this task is not needed.
        if self.awareness.intel_scv_arrived_main(now=now):
            return 0

        # Don't time-gate here; planner decides. Keep a modest baseline.
        return 20

    def _log_tick(self, *, now: float, reason: str, tag: int, dist: float) -> None:
        if not self.log:
            return
        if (now - float(self._last_log_t)) < float(self.log_every):
            return
        self._last_log_t = float(now)
        self.log.emit(
            "scout_tick",
            {
                "t": round(float(now), 2),
                "mission_id": str(self.mission_id or ""),
                "tag": int(tag),
                "reason": str(reason),
                "dist": round(float(dist), 2),
            },
        )

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        now = float(tick.time)

        if not isinstance(self.mission_id, str) or not self.mission_id:
            return TaskResult.failed("unbound_mission")

        if not isinstance(self.assigned_tags, list) or len(self.assigned_tags) != 1:
            return TaskResult.failed("expected_exactly_1_assigned_tag")

        tag = int(self.assigned_tags[0])

        # mark dispatch the first time the mission actually runs
        if not self.awareness.intel_scv_dispatched(now=now):
            self.awareness.mark_scv_dispatched(now=now)

        # Fetch the assigned SCV (do NOT request/select a new one)
        scv = bot.units.find_by_tag(tag)
        if scv is None:
            return TaskResult.failed("assigned_unit_missing")

        if scv.type_id != U.SCV:
            return TaskResult.failed("assigned_unit_not_scv")

        target = bot.enemy_start_locations[0]  # strict: engine must provide
        dist = float(scv.distance_to(target))

        # success condition: got close enough to enemy main
        if dist <= float(self.see_radius):
            self.awareness.mark_scv_arrived_main(now=now, ttl=self.arrived_ttl)
            # release the worker back to economy after scout success
            if bot.mineral_field.amount > 0:
                scv.gather(bot.mineral_field.closest_to(bot.start_location))
            else:
                scv.move(bot.start_location)
            if self.log:
                self.log.emit(
                    "scout_success",
                    {
                        "t": round(float(now), 2),
                        "mission_id": str(self.mission_id),
                        "tag": int(tag),
                        "dist": round(float(dist), 2),
                    },
                )
            self._done("arrived_enemy_main")
            return TaskResult.done("arrived_enemy_main")

        # otherwise keep moving
        scv.move(target)
        self._active("moving_to_enemy_main")
        self._log_tick(now=now, reason="moving", tag=tag, dist=dist)
        return TaskResult.running("moving_to_enemy_main")
```

===== ROOT CONFIGS =====
# terran_builds.yml
```yaml
UseData: False
BuildSelection: Cycle
MinGamesWinrateBased: 3

BuildChoices:
  Protoss:
    BotName: MyBot
    Cycle: [Default]
  Terran:
    BotName: MyBot
    Cycle: [Default]
  Zerg:
    BotName: MyBot
    Cycle: [Default]
  Random:
    BotName: MyBot
    Cycle: [Default]

Builds:
  Default:
    AutoSupplyAtSupply: 25
    ConstantWorkerProductionTill: 32
    OpeningBuildOrder:
      - 14 supply @ ramp
      - 12 worker_scout:
          [enemy_spawn, enemy_nat, enemy_ramp, map_center]
      - 16 barracks @ ramp
      - 16 gas
      - 0 orbital
      - 19 reaper
      - 19 expand
      - 19 supply @ ramp
      - 21 factory
      - 21 barracksreactor
      - 21 gas
      - 21 starport
      - 21 addonswap factory barracksreactor
      - 23 hellion *4

  DefensiveOpening:
    AutoSupplyAtSupply: 30
    ConstantWorkerProductionTill: 28
    OpeningBuildOrder:
      - 14 supply @ ramp
      - 16 barracks @ ramp
      - 16 gas
      - 19 supply @ ramp
      - 19 reaper
      - 0 orbital
      - 20 marine *3
      - 21 factory
      - 21 gas
      - 21 starport
      - 23 marine *4

```
# config.yml
```yaml
# Check `ares-sc2/src/ares/config.yml` for valid config options
# Use this to override those values
# Can add own unique config options here if desired

# Set custom values here for your bot
MyBotName: MyBot
MyBotRace: Terran
# setting ture allows auto upload to aiareana (https://aiarena.net/) on push to `main` branch
# see tutorial on readme before setting to True
AutoUploadToAiarena: False
BotZipPubliclyDownloadable: False
BotDataPubliclyDownloadable: False
BotDataEnabled: True
########################

UseData: False
Debug: False
GameStep: 2
DebugGameStep: 2

# Turn ares features on/off for performance reasons
Features:
    # this grid is useful for disruptor balls and maybe some other uses
    # off by default to save computation
    TacticalGroundGrid: False

DebugOptions:
    # one of: Air, AirVsGround, Ground, GroundAvoidance, AirAvoidance
    ActiveGrid: TacticalGround
    ChatDebug: True
    DebugSpawn: False
    ShowPathingCost: True
    ResourceDebug: False
    ShowBuildingFormation: False
```
# run.py
```python
#run.py
import random
import sys
from os import path
from pathlib import Path
import platform
from typing import List
from loguru import logger

from sc2 import maps
from sc2.data import AIBuild, Difficulty, Race
from sc2.main import run_game
from sc2.player import Bot, Computer

sys.path.append("ares-sc2/src/ares")
sys.path.append("ares-sc2/src")
sys.path.append("ares-sc2")

import yaml

from bot.main import MyBot
from ladder import run_ladder_game

plt = platform.system()
if plt == "Windows":
    MAPS_PATH: str = "C:\\Program Files (x86)\\StarCraft II\\Maps"
elif plt == "Darwin":
    MAPS_PATH: str = "/Applications/StarCraft II/Maps"
elif plt == "Linux":
    MAPS_PATH: str = (
        "~/<username>/Games/battlenet/drive_c/Program Files (x86)/StarCraft II/Maps"
    )
else:
    logger.error(f"{plt} not supported")
    sys.exit()

CONFIG_FILE: str = "config.yml"
MAP_FILE_EXT: str = "SC2Map"
MY_BOT_NAME: str = "MyBotName"
MY_BOT_RACE: str = "MyBotRace"


def main():
    bot_name: str = "MyBot"

    # ✅ não deixe Random aqui, sua build order é Terran
    race: Race = Race.Terran

    __user_config_location__: str = path.abspath(".")
    user_config_path: str = path.join(__user_config_location__, CONFIG_FILE)

    # opcional: permitir override por config.yml, mas valida
    if path.isfile(user_config_path):
        with open(user_config_path) as config_file:
            config: dict = yaml.safe_load(config_file) or {}
            if MY_BOT_NAME in config:
                bot_name = config[MY_BOT_NAME]
            if MY_BOT_RACE in config:
                cfg_race = str(config[MY_BOT_RACE]).title()
                try:
                    race = Race[cfg_race]
                except Exception:
                    logger.warning(f"Invalid {MY_BOT_RACE}='{cfg_race}', forcing Terran.")
                    race = Race.Terran

    # ✅ se alguém colocar Random no config, ainda assim trava tudo.
    # então aqui eu garanto Terran:
    race = Race.Terran

    bot1 = Bot(race, MyBot(), bot_name)

    if "--LadderServer" in sys.argv:
        print("Starting ladder game...")
        result, opponentid = run_ladder_game(bot1)
        print(result, " against opponent ", opponentid)
    else:
        map_list: List[str] = [
            p.name.replace(f".{MAP_FILE_EXT}", "")
            for p in Path(MAPS_PATH).glob(f"*.{MAP_FILE_EXT}")
            if p.is_file()
        ]
        if len(map_list) == 0:
            logger.error(f"Can't find maps, please check `MAPS_PATH` in `run.py'")
            logger.info("Trying back up option")
            map_list = [
                "PylonAIE_v4",
                "PersephoneAIE_v4",
                "TorchesAIE_v4",
                "IncorporealAIE_v4",
                "MagannathaAIE_v2",
                "UltraloveAIE_v2",
            ]

        random_race = random.choice([Race.Zerg, Race.Terran, Race.Protoss])
        print("Starting local game...")
        run_game(
            maps.get(random.choice(map_list)),
            [
                bot1,
                Computer(random_race, Difficulty.VeryEasy, ai_build=AIBuild.Macro),
            ],
            realtime=False,
        )


if __name__ == "__main__":
    main()
```
# ARCHITECTURE.md
```markdown
# ARQUITETURA v2 (Runtime Real)

## 1. Objetivo

Este documento define a arquitetura oficial do bot com base no codigo atual.

Modelo oficial:

`Sensor -> Attention -> Intel -> Awareness -> Planner -> Ego -> Task -> Ares/python-sc2`

Objetivos praticos:

- Separar fatos do tick (`Attention`) de memoria e inferencia (`Awareness`).
- Manter um orquestrador unico de missoes (`Ego`) com contratos estaveis.
- Garantir ownership explicito de unidades (`UnitLeases`).
- Manter o sistema auditavel por eventos e logs (`DevLogger`).

Este documento foca exclusivamente no modelo operacional vigente no codigo atual.

---

## 2. Principios Arquiteturais

1. `Sensors` leem estado do jogo e nao emitem comandos.
2. `Attention` e um snapshot imutavel por tick.
3. `Intel` transforma sinais em crenças e grava em `Awareness`.
4. `Planners` propõem candidatos de missao (`Proposal`) e nao executam micro.
5. `Ego` e o unico arbitro de admissao, cooldown, preempcao e leases.
6. `Tasks` sao a unica camada que comanda unidades/estruturas.
7. Ownership de unidade e explicito por `mission_id` e `UnitRole`.
8. Toda decisao operacional relevante deve ser observavel em log/evento.

---

## 3. Topologia do Sistema (real)

### 3.1 Entradas principais

- [`run.py`](run.py): inicializacao do bot e partida local/ladder.
- [`bot/main.py`](bot/main.py): integra `MyBot(AresBot)` com `RuntimeApp`.
- [`bot/mind/self.py`](bot/mind/self.py): composicao da runtime e loop por tick.

### 3.2 Componentes centrais

- `Sensors`: em `bot/sensors/*`
- `Attention`: [`bot/mind/attention.py`](bot/mind/attention.py)
- `Intel`: `bot/intel/*` (atual: enemy opening inference)
- `Awareness`: [`bot/mind/awareness.py`](bot/mind/awareness.py)
- `Planners`: `bot/planners/*`
- `Ego`: [`bot/mind/ego.py`](bot/mind/ego.py)
- `Tasks`: `bot/tasks/*`
- `Body/Leases`: [`bot/mind/body.py`](bot/mind/body.py)

### 3.3 Pipeline canonico

1. Sensors derivam snapshot do tick.
2. Snapshot e consolidado em `Attention`.
3. Intel le `Attention` e atualiza `Awareness` (stateful).
4. Planners leem `Attention + Awareness` e retornam `Proposal`.
5. Ego valida/ordena/admite propostas.
6. Ego executa tasks ativas e fecha missoes quando necessario.
7. Tasks enviam comandos via Ares/python-sc2.

---

## 4. Fluxo por Tick (sequencia oficial)

Sequencia implementada em [`RuntimeApp.on_step`](bot/mind/self.py):

1. `attention = derive_attention(...)`
2. `derive_enemy_build_intel(..., attention=attention, awareness=awareness, ...)`
3. `await ego.tick(..., tick=TaskTick, attention=attention, awareness=awareness)`

Dentro de `Ego.tick`:

1. `body.reap(...)` + reap de commitments expirados.
2. coleta de propostas de todos os planners.
3. `prop.validate()` para cada proposta.
4. ordenacao por `score` decrescente.
5. admissao (`_admit`) com regras de cooldown, singleton domain e threat gate.
6. execucao (`_execute`) das missoes ativas e transicao por `TaskResult`.

Eventos emitidos durante o fluxo:

- `attention_tick`
- `planner_proposed` (quando planner loga)
- `mission_started`
- `mission_step`
- `mission_ended`

---

## 5. Contratos por Camada

## 5.1 Sensors

Responsabilidade:

- Derivar fatos do estado atual do jogo.

Permitido:

- Ler estado do bot/engine.

Proibido:

- Escrever em `Awareness`.
- Emitir comandos de unidade.

Exemplos:

- `derive_economy_snapshot`
- `derive_combat_snapshot`
- `derive_enemy_build_sensor`
- `derive_macro_snapshot`
- `derive_orbital_snapshot`

## 5.2 Attention

Responsabilidade:

- Representar snapshot imutavel por tick.

Contrato:

- Sem side-effects.
- Sem memoria historica.
- Campos estaveis usados por planners/tasks.

Tipos principais:

- `EconomySnapshot`
- `CombatSnapshot`
- `IntelSnapshot`
- `MacroSnapshot`
- `EnemyBuildSnapshot`
- `Attention`

## 5.3 Intel

Responsabilidade:

- Converter fatos de `Attention` em crenças stateful em `Awareness`.

Permitido:

- Escrever chaves em `Awareness.mem` com TTL quando fizer sentido.

Proibido:

- Comandar unidades.

Exemplo atual:

- [`derive_enemy_build_intel`](bot/intel/enemy_build_intel.py): classifica abertura inimiga (`GREEDY/NORMAL/AGGRESSIVE`) e grava sinais em `Awareness`.

## 5.4 Awareness

Responsabilidade:

- Blackboard de estado entre ticks.

Contrato:

- Chaves namespaceadas via `K(...)`.
- Suporte a `ttl`, `age`, `staleness`.
- API de eventos (`emit`, `tail_events`).

Regra:

- `Awareness` nao executa comandos; apenas estado e eventos.

## 5.5 Planners

Responsabilidade:

- Gerar `Proposal` com score e `TaskSpec`.

Entrada:

- `Attention` + `Awareness`.

Saida:

- `list[Proposal]`.

Proibido:

- Comandar unidades diretamente.

Planners atuais:

- `DefensePlanner`
- `IntelPlanner`
- `MacroPlanner`

## 5.6 Ego

Responsabilidade:

- Arbitragem central de operacoes.

Funcoes:

- aplicar cooldown de proposta
- bloquear dominios nao defensivos sob alta ameaca
- garantir singleton por dominio configurado
- selecionar/claim de unidades por requisito
- bind de missao em task
- lifecycle de missao + persistencia em `Awareness`

`Ego` e o unico dono do ciclo de admissao/execucao/encerramento de missao.

## 5.7 Tasks

Responsabilidade:

- Execucao concreta no jogo.

Contrato:

- `on_step` retorna obrigatoriamente `TaskResult`.
- Estados efetivos: `RUNNING`, `DONE`, `FAILED`, `NOOP`.
- `bind_mission(...)` e obrigatorio antes de executar.

Somente tasks podem enviar comandos para jogo (`attack`, `move`, `train`, `register_behavior`, etc.).

---

## 6. Modelo de Missao Atual

Definicoes em [`bot/planners/proposals.py`](bot/planners/proposals.py):

- `UnitRequirement(unit_type, count)`
- `TaskSpec(task_id, task_factory, unit_requirements, lease_ttl)`
- `Proposal(proposal_id, domain, score, tasks[1], lease_ttl, cooldown_s, risk_level, allow_preempt)`

Observacoes:

- `Proposal.tasks` contem exatamente 1 `TaskSpec` no modelo atual.
- `task_factory` recebe `mission_id`.

## 6.1 Admissao de missao

Durante `_admit`, `Ego`:

1. ignora proposta em cooldown
2. ignora proposta ja em execucao
3. aplica threat gate (`domain != DEFENSE` sob urgencia alta)
4. aplica preempcao para dominios singleton
5. seleciona e claima unidades (se houver requisitos)
6. instancia task, faz bind de missao e registra commitment

## 6.2 Execucao e encerramento

Durante `_execute`, `Ego`:

- encerra expiradas (`reason=expired`)
- executa `task.step(...)`
- em `FAILED`: aplica cooldown e encerra
- em `DONE`: encerra
- em `RUNNING/NOOP`: mantem ativa e registra `mission_step`

## 6.3 Leases e ownership

`UnitLeases` garante exclusividade por `mission_id` com TTL:

- `claim(...)`
- `touch(...)`
- `release_mission(...)`
- mapeamento de `domain -> UnitRole`

Invariante:

- unidade claimada nao pode ser usada por outra missao sem release/expiracao.

---

## 7. Estado e Memoria (`Awareness.mem`)

Catalogo detalhado: [`_docs/attention_awareness.md`](_docs/attention_awareness.md).

Resumo de namespaces:

- `ops:*`: estado de missoes e cooldowns
- `intel:*`: bookkeeping de scout/scan
- `enemy:*`: inferencia de abertura inimiga
- `macro:*`: housekeeping e controles auxiliares

Politica de TTL/staleness:

- fatos inferidos com meia-vida curta usam `ttl` (ex.: enemy opening confidence)
- bookkeeping estrutural usa `ttl=None`
- consumidores devem considerar staleness (`age`, `is_stale`, `max_age`) quando relevante

---

## 8. Observabilidade e Debug

Implementacao principal em [`bot/devlog.py`](bot/devlog.py).

Formato:

- JSONL consolidado por run
- JSONL por modulo (`attention`, `planner`, `ego`, `runtime`, etc.)
- JSONL por componente
- trilhas de tick por modulo para eventos `*_tick`

Eventos-chave para diagnostico:

- Churn de missao: `mission_started`/`mission_ended`
- Cooldown e falhas: `mission_ended` com `status=FAILED` + reason
- Pressao de combate: `attention_tick` (`threatened`, `defense_urgency`)
- Decisao de planner: `planner_proposed` e eventos especificos de planner

Fluxo minimo de triagem:

1. validar `attention_tick` para contexto do jogo
2. validar `planner_proposed` para candidatas
3. validar `mission_started`/`mission_ended` para churn/preempcao
4. validar eventos de task (`*_tick`, success/fail)

---

## 9. Invariantes Operacionais

1. `Attention` nao persiste estado entre ticks.
2. `Intel` nao emite comandos de unidade.
3. `Planners` nao executam micro.
4. `Ego` decide admissao e ownership.
5. `Task` retorna `TaskResult` valido em todo `on_step`.
6. `Awareness` registra inicio/fim de toda missao admitida.
7. Leases de unidades devem ser liberados no fim de missao.

---

## 10. Limites Atuais (MVP) e Roadmap

Limites atuais:

- Enemy build intel ainda heuristico (regras fixas, sem aprendizado online).
- Ausencia de dominios completos de `Harass` e `MapControl` no runtime atual.
- Parte da macro ainda sensivel a churn de missao em cenarios especificos.
- Cobertura de testes focada no framework; modulo `bot` ainda precisa ampliar testes.

Roadmap sugerido:

1. Estabilizar lifecycle de missoes longas (reduzir churn em defesa/macro/scan).
2. Consolidar dominio de manutencao separado de macro principal.
3. Adicionar planners/tasks de `Harass` e `MapControl` com contratos iguais.
4. Introduzir KPIs de runtime (uptime por missao, preempcao por dominio, taxa de falha).
5. Expandir testes de `bot` para contracts de Ego/Planner/Task.

---

## 11. Mapa de Arquivos de Referencia

- [`bot/mind/self.py`](bot/mind/self.py)
- [`bot/mind/attention.py`](bot/mind/attention.py)
- [`bot/mind/awareness.py`](bot/mind/awareness.py)
- [`bot/intel/enemy_build_intel.py`](bot/intel/enemy_build_intel.py)
- [`bot/mind/ego.py`](bot/mind/ego.py)
- [`bot/mind/body.py`](bot/mind/body.py)
- [`bot/planners/proposals.py`](bot/planners/proposals.py)
- [`_docs/attention_awareness.md`](_docs/attention_awareness.md)

---

## 12. Status do Documento

Este arquivo substitui o modelo legado como referencia oficial.
Atualizacoes futuras devem acompanhar mudancas em contratos de `Attention/Awareness/Intel/Planner/Ego/Task`.
```
