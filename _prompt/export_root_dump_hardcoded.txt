===== EXPORT META =====
generated_at_utc: 2026-02-26T06:36:09.544738+00:00
repo_root: C:\Users\Asus\Documents\projetos\sc2bot\ares\ares-sc2-bot-template
hardcoded_bot_policy:
- bot/ares_wrapper: FULL
- bot/intel: FULL
- bot/mind: FULL
- bot/planners: FULL
- bot/sensors: FULL
- bot/tasks: FULL
- bot/<top-level *.py>: FULL

===== ROOT PROMPT =====
Voce e meu parceiro tecnico para evoluir um bot de StarCraft II em Python.
Vou enviar um dump do repositorio gerado por _prompt/export_prompt_root.py.

PRIORIDADES
1. Consistencia de contrato (Task, Planner, Proposal, Ego, Body, Awareness, Attention, Self)
2. Diagnostico por evidencias (logs e codigo atual)
3. Mudanca minima com impacto claro

REGRAS
- Nao invente contratos, campos, enums ou assinaturas fora do dump.
- Fonte da verdade: somente esta conversa e os arquivos enviados.
- Se faltar contexto, peca somente o trecho minimo necessario.

MODO DE RESPOSTA
- [PATCH]: mudanca pequena, resposta curta.
- [FILE]: um arquivo inteiro.
- [MULTI]: varios arquivos inteiros.
Se eu nao indicar modo, use [PATCH].

ENTREGA
- Em [FILE] e [MULTI], cada .py deve começar com comentario de caminho.
  Exemplo: # bot/mind/ego.py

COMPORTAMENTO ESPERADO DO AGENTE
1. Ler o dump e validar contratos atuais
2. Apontar inconsistencias criticas primeiro
3. Propor/codar correcao com menor risco
4. Sugerir teste funcional objetivo (logs esperados + efeito esperado)

FORMATO DO DUMP
- PROJECT TREE (estrutura completa)
- BOT SNAPSHOT
  - algumas pastas com conteudo completo
  - outras apenas com lista de arquivos (structure-only)
- ROOT CONFIGS
- opcional: LOG SUMMARY

NOTA
O exportador usa selecao hardcoded por pasta do bot.
Se uma pasta estiver em structure-only, use os caminhos listados para pedir apenas os arquivos necessarios.

===== PROJECT TREE =====
.
|-- .github
|   `-- workflows
|       |-- build_windows_exe.yaml
|       `-- ladder_zip.yml
|-- _docs
|-- _prompt
|   |-- export_prompt_root.py
|   |-- root.txt
|   `-- view_devlog.py
|-- bot
|   |-- ares_wrapper
|   |   |-- __init__.py
|   |   |-- map.py
|   |   `-- roles.py
|   |-- intel
|   |   `-- enemy_build_intel.py
|   |-- mind
|   |   |-- __init__.py
|   |   |-- attention.py
|   |   |-- awareness.py
|   |   |-- body.py
|   |   |-- ego.py
|   |   `-- self.py
|   |-- planners
|   |   |-- defense_planner.py
|   |   |-- intel_planner.py
|   |   |-- macro_planner.py
|   |   `-- proposals.py
|   |-- sensors
|   |   |-- __init__.py
|   |   |-- economy_sensor.py
|   |   |-- enemy_build_sensor.py
|   |   |-- macro_sensor.py
|   |   |-- orbital_sensor.py
|   |   `-- threat_sensor.py
|   |-- tasks
|   |   |-- macro
|   |   |   |-- rush_defend
|   |   |   |   |-- __init__.py
|   |   |   |   `-- rush_defense.py
|   |   |   |-- __init__.py
|   |   |   |-- ares_plan.py
|   |   |   |-- bio_standard.py
|   |   |   |-- macro_task.py
|   |   |   `-- opening.py
|   |   |-- __init__.py
|   |   |-- base_task.py
|   |   |-- defend_task.py
|   |   |-- scan_task.py
|   |   `-- scout_task.py
|   |-- __init__.py
|   |-- devlog.py
|   `-- main.py
|-- logs
|   |-- devlog_20260226_061140.jsonl
|   |-- devlog_20260226_062812.jsonl
|   `-- devlog_20260226_063404.jsonl
|-- scripts
|   |-- create_ladder_zip.py
|   |-- create_pyinstaller_exe.py
|   |-- update_ares.py
|   `-- upload_to_ai_arena.py
|-- .env
|-- .gitignore
|-- .gitmodules
|-- ARCHITECTURE.md
|-- config.yml
|-- ladder.py
|-- LICENSE
|-- poetry.lock
|-- protoss_builds.yml
|-- pyproject.toml
|-- README.md
|-- run.py
`-- terran_builds.yml

===== BOT SNAPSHOT =====
## bot/<top-level *.py> (full)
# bot/__init__.py
```python

```
# bot/devlog.py
```python
#bot/devlog.py
from __future__ import annotations

import json
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Dict, Optional


@dataclass
class DevLogger:
    """
    Logger JSONL simples (1 evento por linha).
    Objetivo: você conseguir auditar decisões ("flags") pós-partida.
    """

    log_dir: str = "logs"
    filename: Optional[str] = None
    enabled: bool = True

    def _ensure_dir(self) -> None:
        os.makedirs(self.log_dir, exist_ok=True)

    def set_file(self, filename: str) -> None:
        self.filename = filename

    def emit(self, event: str, payload: Optional[Dict[str, Any]] = None, *, meta: Optional[Dict[str, Any]] = None) -> None:
        if not self.enabled:
            return
        if not self.filename:
            # Se esquecer de setar, não explode o jogo.
            return

        self._ensure_dir()
        row = {
            "ts_utc": datetime.now(timezone.utc).isoformat(),
            "event": event,
            "payload": payload or {},
            "meta": meta or {},
        }
        path = os.path.join(self.log_dir, self.filename)
        try:
            with open(path, "a", encoding="utf-8") as f:
                f.write(json.dumps(row, ensure_ascii=False) + "\n")
        except Exception:
            # logging nunca pode matar o bot
            pass
```
# bot/main.py
```python
# bot/main.py
from __future__ import annotations

from typing import Optional

from ares import AresBot
from sc2.data import Result

from bot.ares_wrapper import AresWrapper
from bot.devlog import DevLogger
from bot.mind.self import RuntimeApp


class MyBot(AresBot):
    def __init__(self, game_step_override: Optional[int] = None, *, debug: bool = True):
        super().__init__(game_step_override)
        self.debug = debug

        # logger pode ficar aqui (infra), mas runtime decide como usar
        self.log = DevLogger(enabled=True)

        # wrapper do engine (opcional ficar aqui; pode migrar pro runtime depois)
        self.ares = AresWrapper(self)

        # runtime é a única "inteligência" conectada ao main
        self.rt = RuntimeApp.build(log=self.log, debug=debug)

    async def on_start(self) -> None:
        await super().on_start()

        # ensure DevLogger has a filename; otherwise emit() is a no-op
        if self.log and not getattr(self.log, "filename", None):
            from datetime import datetime, timezone
            self.log.set_file(f"devlog_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.jsonl")

        await self.rt.on_start(self)

    async def on_step(self, iteration: int) -> None:
        await super().on_step(iteration)
        await self.rt.on_step(self, iteration=iteration)

    async def on_end(self, game_result: Result) -> None:
        await super().on_end(game_result)
        await self.rt.on_end(self, game_result=game_result)
```
## bot/ares_wrapper (full)
# bot/ares_wrapper/__init__.py
```python
#bot/ares_wrapper/__init__.py
from __future__ import annotations

from dataclasses import dataclass

from bot.ares_wrapper.map import Map
from bot.ares_wrapper.roles import Roles


@dataclass(frozen=True)
class AresWrapper:
    """
    Camada de adaptação ao Ares/python-sc2.

    Regra:
      - Pode chamar bot.mediator, bot.game_info, etc.
      - NÃO contém decisão estratégica e NÃO contém state machine de missão.
    """
    bot: object

    @property
    def roles(self) -> Roles:
        return Roles(self.bot)

    @property
    def map(self) -> Map:
        return Map(self.bot)
```
# bot/ares_wrapper/map.py
```python
# bot/ares_wrapper/map.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Literal, Tuple

from sc2.position import Point2


EnemyMainSource = Literal["ENEMY_START"]


@dataclass(frozen=True)
class Map:
    bot: object

    def enemy_main(self) -> Tuple[Point2, EnemyMainSource]:
        """
        Strict contract: no fallbacks.
        If the engine cannot provide enemy_start_locations, crash to expose wiring issues.
        """
        locs = getattr(self.bot, "enemy_start_locations", None)
        if not locs or len(locs) == 0:
            raise RuntimeError("Map.enemy_main() requires bot.enemy_start_locations[0]")
        return locs[0], "ENEMY_START"
```
# bot/ares_wrapper/roles.py
```python
#bot/ares_wrapper/roles.py
from __future__ import annotations

from dataclasses import dataclass

from ares.consts import UnitRole
from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2
from sc2.unit import Unit


@dataclass(frozen=True)
class Roles:
    bot: object  # AresBot / BotAI

    def assign(self, *, unit: Unit, role: UnitRole, remove_from_squad: bool = True) -> None:
        self.bot.mediator.assign_role(tag=unit.tag, role=role, remove_from_squad=remove_from_squad)

    def get_scout_workers(self):
        return self.bot.mediator.get_units_from_role(role=UnitRole.BUILD_RUNNER_SCOUT, unit_type=U.SCV)

    def request_worker_scout(self, *, target_position: Point2) -> Unit:
        worker: Unit = self.bot.mediator.select_worker(target_position=target_position)
        self.assign(unit=worker, role=UnitRole.BUILD_RUNNER_SCOUT, remove_from_squad=True)
        return worker
```
## bot/intel (full)
# bot/intel/enemy_build_intel.py
```python
# bot/intel/enemy_build_intel.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Tuple

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.mind.awareness import Awareness, K
from bot.mind.attention import Attention


@dataclass(frozen=True)
class EnemyBuildIntelConfig:
    """
    MVP heuristic config.
    You can tune later without changing contract.
    """
    ttl_s: float = 12.0

    # timing thresholds
    early_s: float = 210.0     # ~3:30 window for "early aggression" classification
    greedy_s: float = 165.0    # ~2:45 window for "fast expand" classification

    # aggression signals
    rush_units_near_bases: int = 6
    rush_confidence_min: float = 0.65


def _count_enemy_bases(enemy_structures: Dict[U, int]) -> int:
    # Townhalls by race (visible only)
    return int(
        enemy_structures.get(U.HATCHERY, 0)
        + enemy_structures.get(U.LAIR, 0)
        + enemy_structures.get(U.HIVE, 0)
        + enemy_structures.get(U.NEXUS, 0)
        + enemy_structures.get(U.COMMANDCENTER, 0)
        + enemy_structures.get(U.ORBITALCOMMAND, 0)
        + enemy_structures.get(U.PLANETARYFORTRESS, 0)
    )


def _sum_units(enemy_units: Dict[U, int], types: Tuple[U, ...]) -> int:
    return int(sum(int(enemy_units.get(t, 0)) for t in types))


def derive_enemy_build_intel(
    bot,
    *,
    awareness: Awareness,
    attention: Attention,
    now: float,
    cfg: EnemyBuildIntelConfig = EnemyBuildIntelConfig(),
) -> None:
    """
    EnemyBuildIntel (inference -> Awareness):
      - reads Attention.enemy_build (tick facts)
      - infers enemy opening: GREEDY / NORMAL / AGGRESSIVE
      - writes to Awareness with TTL (belief/state, not tick fact)

    Rule: may write to Awareness; must not issue commands.
    """
    eb = attention.enemy_build
    enemy_units: Dict[U, int] = eb.enemy_units
    enemy_structs: Dict[U, int] = eb.enemy_structures

    enemy_bases = _count_enemy_bases(enemy_structs)

    # Signals we can use right now (MVP)
    near_bases = int(attention.combat.enemy_count_near_bases)
    threatened = bool(attention.combat.threatened)

    lings = _sum_units(enemy_units, (U.ZERGLING,))
    marines = _sum_units(enemy_units, (U.MARINE,))
    reapers = _sum_units(enemy_units, (U.REAPER,))
    zealots = _sum_units(enemy_units, (U.ZEALOT,))
    adepts = _sum_units(enemy_units, (U.ADEPT,))
    stalkers = _sum_units(enemy_units, (U.STALKER,))

    early = float(now) <= float(cfg.early_s)
    greedy_window = float(now) <= float(cfg.greedy_s)

    kind = "NORMAL"
    conf = 0.40

    # Natural visibility signal (new, from sensor)
    nat_on_ground = bool(getattr(eb, "enemy_natural_on_ground", False))

    # 1) Aggressive/Rush: strong immediate combat signals near our bases early.
    if early and (near_bases >= int(cfg.rush_units_near_bases) or (threatened and near_bases >= 3)):
        kind = "AGGRESSIVE"
        conf = min(0.95, 0.55 + 0.05 * float(near_bases))
        if (lings + marines + reapers + zealots + adepts + stalkers) >= 6:
            conf = min(0.98, conf + 0.10)

    # 2) Greedy: visible fast 2nd base in a greedy timing window and not much pressure.
    # Upgraded: use natural townhall visibility if we have it.
    elif greedy_window and (nat_on_ground or enemy_bases >= 2) and near_bases <= 1 and not threatened:
        kind = "GREEDY"
        conf = 0.75

    # else NORMAL

    # First-time "we saw anything meaningful" marker (permanent).
    # This is useful for planners that want to react on first scout info.
    first_seen = awareness.mem.get(K("enemy", "opening", "first_seen_t"), now=now, default=None)
    saw_anything = (len(enemy_units) > 0) or (len(enemy_structs) > 0)
    if first_seen is None and saw_anything:
        awareness.mem.set(K("enemy", "opening", "first_seen_t"), value=float(now), now=now, ttl=None)

    signals = {
        "t": round(float(now), 2),
        "early": bool(early),
        "greedy_window": bool(greedy_window),
        "enemy_bases_visible": int(enemy_bases),
        "enemy_near_our_bases": int(near_bases),
        "threatened": bool(threatened),
        "natural_on_ground": bool(nat_on_ground),
        "natural_townhall_progress": float(getattr(eb, "enemy_natural_townhall_progress", 0.0) or 0.0),
        "natural_townhall_type": str(getattr(eb, "enemy_natural_townhall_type", None)),
        "seen_units": {
            "lings": int(lings),
            "marines": int(marines),
            "reapers": int(reapers),
            "zealots": int(zealots),
            "adepts": int(adepts),
            "stalkers": int(stalkers),
        },
        # New sensor payload for debugging + future heuristics:
        "main_units": dict(getattr(eb, "enemy_units_main", {}) or {}),
        "main_structures": dict(getattr(eb, "enemy_structures_main", {}) or {}),
        "structures_progress": dict(getattr(eb, "enemy_structures_progress", {}) or {}),
    }

    awareness.mem.set(K("enemy", "opening", "kind"), value=str(kind), now=now, ttl=float(cfg.ttl_s))
    awareness.mem.set(K("enemy", "opening", "confidence"), value=float(conf), now=now, ttl=float(cfg.ttl_s))
    awareness.mem.set(K("enemy", "opening", "signals"), value=signals, now=now, ttl=float(cfg.ttl_s))
    awareness.mem.set(K("enemy", "opening", "last_update_t"), value=float(now), now=now, ttl=None)
```
## bot/mind (full)
# bot/mind/__init__.py
```python

```
# bot/mind/attention.py
```python
# bot/mind/attention.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

from sc2.position import Point2

from bot.mind.awareness import Awareness
from bot.sensors.threat_sensor import Threat, ThreatReport


@dataclass(frozen=True)
class EconomySnapshot:
    units_ready: dict
    supply_left: int
    minerals: int
    gas: int


@dataclass(frozen=True)
class CombatSnapshot:
    threatened: bool
    defense_urgency: int
    threat_pos: Optional[Point2]
    enemy_count_near_bases: int


@dataclass(frozen=True)
class IntelSnapshot:
    orbital_ready_to_scan: bool
    orbital_energy: float


@dataclass(frozen=True)
class MacroSnapshot:
    opening_done: bool


@dataclass(frozen=True)
class EnemyBuildSnapshot:
    """
    Tick facts only.

    Backwards-compatible fields:
      - enemy_units: counts of enemy units currently visible anywhere
      - enemy_structures: counts of enemy structures currently visible anywhere

    Extended fields (MVP for scouting + completion state):
      - enemy_main_pos: engine-provided enemy main (strict: enemy_start_locations[0])
      - enemy_natural_pos: inferred from expansion locations (2nd closest to enemy main)
      - enemy_units_main: counts of enemy units visible within main_radius of enemy_main_pos
      - enemy_structures_main: counts of enemy structures visible within main_radius of enemy_main_pos

      - enemy_structures_progress:
          per-structure-type stats of build_progress for currently visible enemy structures, e.g.
          {
            UnitTypeId.SPAWNINGPOOL: {
              "count": 1,
              "ready": 0,
              "incomplete": 1,
              "min": 0.42,
              "max": 0.42,
              "avg": 0.42,
            },
            ...
          }

      - enemy_natural_on_ground:
          True if a visible enemy townhall is on/near the enemy natural location.
      - enemy_natural_townhall_progress:
          max build_progress among visible townhalls near natural (None if not seen)
      - enemy_natural_townhall_type:
          type_id of the most-progressed townhall near natural (None if not seen)
    """
    enemy_units: dict
    enemy_structures: dict

    enemy_main_pos: Optional[Point2] = None
    enemy_natural_pos: Optional[Point2] = None

    enemy_units_main: dict = None
    enemy_structures_main: dict = None

    enemy_structures_progress: dict = None

    enemy_natural_on_ground: bool = False
    enemy_natural_townhall_progress: Optional[float] = None
    enemy_natural_townhall_type: Optional[object] = None  # UnitTypeId, but keep loose to avoid typing friction


@dataclass(frozen=True)
class Attention:
    """
    Tick snapshot (read-only).
    - immutable
    - derived each tick
    - history/inference belongs in Awareness
    """
    economy: EconomySnapshot
    combat: CombatSnapshot
    intel: IntelSnapshot
    macro: MacroSnapshot
    enemy_build: EnemyBuildSnapshot
    time: float = 0.0


def derive_attention(bot, *, awareness: Awareness, threat: Threat) -> Attention:
    """
    Derive tick snapshot from sensors.
    Rule: no side-effects.

    Note:
      - imports for sensors are local to avoid circular imports
        (sensors reference snapshot dataclasses from this module).
    """
    from bot.sensors.economy_sensor import derive_economy_snapshot
    from bot.sensors.enemy_build_sensor import derive_enemy_build_sensor
    from bot.sensors.macro_sensor import derive_macro_snapshot
    from bot.sensors.orbital_sensor import derive_orbital_snapshot

    now = float(getattr(bot, "time", 0.0) or 0.0)

    thr: ThreatReport = threat.evaluate(bot)

    economy = derive_economy_snapshot(bot)
    intel = derive_orbital_snapshot(bot)
    macro = derive_macro_snapshot(bot)
    enemy_build = derive_enemy_build_sensor(bot)

    combat = CombatSnapshot(
        threatened=bool(thr.threatened),
        defense_urgency=int(thr.urgency),
        threat_pos=thr.threat_pos,
        enemy_count_near_bases=int(thr.enemy_count),
    )

    return Attention(
        economy=economy,
        combat=combat,
        intel=intel,
        macro=macro,
        enemy_build=enemy_build,
        time=float(now),
    )
```
# bot/mind/awareness.py
```python
# bot/mind/awareness.py
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Tuple


Key = Tuple[str, ...]


@dataclass(frozen=True)
class Fact:
    value: Any
    t: float
    confidence: float = 1.0
    ttl: Optional[float] = None


@dataclass
class MemoryStore:
    _facts: Dict[Key, Fact] = field(default_factory=dict)

    def set(
        self,
        key: Key,
        *,
        value: Any,
        now: float,
        ttl: Optional[float] = None,
        confidence: float = 1.0,
    ) -> None:
        self._facts[key] = Fact(value=value, t=float(now), confidence=float(confidence), ttl=ttl)

    def get(self, key: Key, *, now: float, default: Any = None, max_age: Optional[float] = None) -> Any:
        f = self._facts.get(key)
        if f is None:
            return default
        age = float(now) - float(f.t)
        if age < 0:
            # clock skew / weirdness: treat as fresh
            age = 0.0
        if max_age is not None and age > float(max_age):
            return default
        if f.ttl is not None and age > float(f.ttl):
            return default
        return f.value

    def age(self, key: Key, *, now: float) -> Optional[float]:
        f = self._facts.get(key)
        if f is None:
            return None
        return max(0.0, float(now) - float(f.t))

    def is_stale(self, key: Key, *, now: float, max_age: float) -> bool:
        a = self.age(key, now=now)
        if a is None:
            return True
        return a > float(max_age)

    def has(self, key: Key, *, now: float, max_age: Optional[float] = None) -> bool:
        sentinel = object()
        return self.get(key, now=now, default=sentinel, max_age=max_age) is not sentinel

    def keys(self) -> Iterable[Key]:
        return self._facts.keys()

    def snapshot(self, *, now: float, prefix: Optional[Key] = None, max_age: Optional[float] = None) -> Dict[str, Any]:
        """
        Returns a JSON-friendly dict of { "a:b:c": {value,t,age,ttl,confidence} }
        filtered by optional prefix and optional max_age.
        """
        out: Dict[str, Any] = {}
        for k, f in self._facts.items():
            if prefix is not None and k[: len(prefix)] != prefix:
                continue
            age = max(0.0, float(now) - float(f.t))
            if max_age is not None and age > float(max_age):
                continue
            if f.ttl is not None and age > float(f.ttl):
                continue
            sk = ":".join(k)
            out[sk] = {
                "value": f.value,
                "t": round(float(f.t), 2),
                "age": round(float(age), 2),
                "ttl": f.ttl,
                "confidence": round(float(f.confidence), 2),
            }
        return out


def K(*parts: str) -> Key:
    return tuple(parts)


@dataclass
class Awareness:
    """
    Persistent world memory.
    - Use mem for generic facts (keyed, timestamped, TTL-aware)
    - Keep only a few structured helpers where it buys clarity/perf.
    """

    mem: MemoryStore = field(default_factory=MemoryStore)

    # ring buffer style event log (debug/audit)
    _events: List[Dict[str, Any]] = field(default_factory=list)
    _events_cap: int = 200

    # -----------------------
    # Logging / events
    # -----------------------
    def emit(self, name: str, *, now: float, data: Optional[Dict[str, Any]] = None) -> None:
        evt = {"t": round(float(now), 2), "name": str(name)}
        if data:
            evt["data"] = data
        self._events.append(evt)
        if len(self._events) > self._events_cap:
            self._events = self._events[-self._events_cap :]

    def tail_events(self, n: int = 10) -> List[Dict[str, Any]]:
        if n <= 0:
            return []
        return self._events[-n:]

    # -----------------------
    # Ops / mission helpers
    # -----------------------
    def ops_proposal_running(self, *, proposal_id: str, now: float) -> bool:
        """
        Returns True if there is an active mission with this proposal_id and status == RUNNING.

        This is intentionally implemented without extra indexes: we scan mem facts
        looking for ops:mission:<id>:proposal_id facts, then check status.
        """
        if not isinstance(proposal_id, str) or not proposal_id:
            raise ValueError("proposal_id must be a non-empty string")

        # Find missions that match this proposal_id
        for k, f in self.mem._facts.items():
            if len(k) < 4:
                continue
            if k[0] != "ops" or k[1] != "mission":
                continue
            if k[-1] != "proposal_id":
                continue
            if f.value != proposal_id:
                continue

            mission_id = k[2]
            st = str(self.mem.get(K("ops", "mission", mission_id, "status"), now=now, default=""))
            if st == "RUNNING":
                return True

        return False

    # -----------------------
    # Convenience “intel” API
    # (minimal wrappers so the rest of the bot stays clean)
    # -----------------------
    _K_SCV_DISPATCHED = K("intel", "scv", "dispatched")
    _K_SCV_ARRIVED_MAIN = K("intel", "scv", "arrived_main")
    _K_SCAN_ENEMY_MAIN = K("intel", "scan", "enemy_main")
    _K_LAST_SCV_DISPATCH_AT = K("intel", "scv", "last_dispatch_at")
    _K_LAST_SCAN_AT = K("intel", "scan", "last_scan_at")

    def intel_scv_dispatched(self, *, now: float) -> bool:
        return bool(self.mem.get(self._K_SCV_DISPATCHED, now=now, default=False))

    def intel_scv_arrived_main(self, *, now: float) -> bool:
        return bool(self.mem.get(self._K_SCV_ARRIVED_MAIN, now=now, default=False))

    def intel_scanned_enemy_main(self, *, now: float) -> bool:
        return bool(self.mem.get(self._K_SCAN_ENEMY_MAIN, now=now, default=False))

    def intel_last_scv_dispatch_at(self, *, now: float) -> float:
        return float(self.mem.get(self._K_LAST_SCV_DISPATCH_AT, now=now, default=0.0))

    def intel_last_scan_at(self, *, now: float) -> float:
        return float(self.mem.get(self._K_LAST_SCAN_AT, now=now, default=0.0))

    def mark_scv_dispatched(self, *, now: float) -> None:
        self.mem.set(self._K_SCV_DISPATCHED, value=True, now=now, ttl=None)
        self.mem.set(self._K_LAST_SCV_DISPATCH_AT, value=float(now), now=now, ttl=None)

    def mark_scv_arrived_main(self, *, now: float, ttl: Optional[float] = None) -> None:
        self.mem.set(self._K_SCV_ARRIVED_MAIN, value=True, now=now, ttl=ttl)

    def mark_scanned_enemy_main(self, *, now: float) -> None:
        self.mem.set(self._K_SCAN_ENEMY_MAIN, value=True, now=now, ttl=None)
        self.mem.set(self._K_LAST_SCAN_AT, value=float(now), now=now, ttl=None)
```
# bot/mind/body.py
```python
# bot/mind/body.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Optional, Set

from ares.consts import UnitRole


@dataclass
class Lease:
    owner: str  # mission_id
    role: UnitRole
    expires_at: float


class UnitLeases:
    """
    Unit ownership with TTL and reverse index.
    """

    def __init__(self, *, default_ttl: float = 8.0):
        self.default_ttl = float(default_ttl)
        self._leases: Dict[int, Lease] = {}      # unit_tag -> Lease
        self._by_owner: Dict[str, Set[int]] = {} # mission_id -> {unit_tag}

    def reset(self) -> None:
        self._leases.clear()
        self._by_owner.clear()

    def reap(self, *, now: float) -> None:
        expired: List[int] = [tag for tag, lease in self._leases.items() if lease.expires_at <= now]
        for tag in expired:
            self._remove_tag(tag)

    def _remove_tag(self, unit_tag: int) -> None:
        lease = self._leases.pop(unit_tag, None)
        if lease is None:
            return
        s = self._by_owner.get(lease.owner)
        if s:
            s.discard(unit_tag)
            if not s:
                del self._by_owner[lease.owner]

    # ---------------- Queries ----------------

    def owner_of(self, unit_tag: int, *, now: float) -> Optional[str]:
        self.reap(now=now)
        lease = self._leases.get(unit_tag)
        return lease.owner if lease else None

    def units_of(self, task_id: str, *, now: float) -> Set[int]:
        self.reap(now=now)
        return set(self._by_owner.get(task_id, set()))

    def can_claim(self, unit_tag: int, *, now: float) -> bool:
        self.reap(now=now)
        return unit_tag not in self._leases

    # ---------------- Claim API ----------------

    def claim(
        self,
        *,
        task_id: str,
        unit_tag: int,
        role: UnitRole,
        now: float,
        ttl: Optional[float] = None,
        force: bool = False,
    ) -> bool:
        self.reap(now=now)

        if (not force) and unit_tag in self._leases:
            return False

        if unit_tag in self._leases:
            self._remove_tag(unit_tag)

        t = float(ttl) if ttl is not None else self.default_ttl
        self._leases[unit_tag] = Lease(owner=task_id, role=role, expires_at=now + t)
        self._by_owner.setdefault(task_id, set()).add(unit_tag)
        return True

    def try_acquire(
        self,
        task_id: str,
        *,
        unit_tag: int,
        role: UnitRole,
        now: float,
        ttl: Optional[float] = None,
        force: bool = False,
    ) -> bool:
        return self.claim(
            task_id=task_id,
            unit_tag=unit_tag,
            role=role,
            now=now,
            ttl=ttl,
            force=force,
        )

    def touch(self, *, task_id: str, unit_tag: int, now: float, ttl: Optional[float] = None) -> None:
        self.reap(now=now)
        lease = self._leases.get(unit_tag)
        if not lease or lease.owner != task_id:
            return
        t = float(ttl) if ttl is not None else self.default_ttl
        lease.expires_at = now + t

    def release(self, *, unit_tag: int) -> None:
        self._remove_tag(unit_tag)

    def release_owner(self, *, task_id: str) -> None:
        tags = list(self._by_owner.get(task_id, []))
        for tag in tags:
            self._remove_tag(tag)

    def release_mission(self, *, mission_id: str) -> None:
        self.release_owner(task_id=mission_id)

    def snapshot(self, *, now: float) -> dict:
        self.reap(now=now)
        return {
            "total_leases": len(self._leases),
            "by_owner": {owner: len(tags) for owner, tags in self._by_owner.items()},
        }

    # -----------------------
    # Role mapping
    # -----------------------
    def _role_for_domain(self, domain: str) -> UnitRole:
        d = domain.upper()
        if d == "DEFENSE":
            return UnitRole.DEFENDING
        if d in ("HARASS", "DROP"):
            return UnitRole.HARASSING
        if d in ("SCOUT", "INTEL"):
            return UnitRole.SCOUTING
        return UnitRole.IDLE
```
# bot/mind/ego.py
```python
# bot/mind/ego.py
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Sequence, Tuple

from bot.mind.attention import Attention
from bot.mind.awareness import Awareness, K
from bot.mind.body import UnitLeases
from bot.planners.proposals import Proposal, TaskSpec, UnitRequirement
from bot.tasks.base_task import Task, TaskTick, TaskResult


@dataclass
class Commitment:
    mission_id: str
    proposal_id: str
    domain: str
    task: Task
    started_at: float
    expires_at: Optional[float]
    non_preemptible_until: float
    assigned_tags: List[int] = field(default_factory=list)

    def is_expired(self, now: float) -> bool:
        return self.expires_at is not None and float(now) >= float(self.expires_at)


@dataclass(frozen=True)
class EgoConfig:
    threat_block_start_at: int = 70
    threat_force_preempt_at: int = 90
    non_preemptible_grace_s: float = 2.5
    default_failure_cooldown_s: float = 8.0
    singleton_domains: frozenset[str] = frozenset({"MACRO"})


class Ego:
    def __init__(self, *, body: UnitLeases, log: Any = None, cfg: EgoConfig = EgoConfig()):
        self.body = body
        self.log = log
        self.cfg = cfg

        self._planners: List[Any] = []
        self._active: Dict[str, Commitment] = {}
        self._active_by_domain: Dict[str, List[str]] = {}

    def register_planners(self, planners: Sequence[Any]) -> None:
        self._planners = list(planners)

    async def tick(self, bot, *, tick: TaskTick, attention: Attention, awareness: Awareness) -> None:
        now = float(tick.time)

        self.body.reap(now=now)
        self._reap_commitments(now=now, awareness=awareness)

        proposals: List[Proposal] = []
        for planner in self._planners:
            proposals.extend(planner.propose(bot, awareness=awareness, attention=attention) or [])

        for prop in proposals:
            prop.validate()

        proposals.sort(key=lambda p: int(p.score), reverse=True)

        await self._admit(bot, now=now, attention=attention, awareness=awareness, proposals=proposals)
        await self._execute(bot, tick=tick, attention=attention, awareness=awareness)

    async def _admit(
        self,
        bot,
        *,
        now: float,
        attention: Attention,
        awareness: Awareness,
        proposals: List[Proposal],
    ) -> None:
        threatened = bool(attention.combat.threatened)
        urgency = int(attention.combat.defense_urgency)

        for prop in proposals:
            if self._is_in_cooldown(awareness, now=now, proposal_id=prop.proposal_id):
                continue

            domain = str(prop.domain)

            # Never admit the same proposal while one is already running.
            # This is the key guard that prevents many parallel scout missions.
            if self._is_proposal_running(prop.proposal_id):
                continue

            if threatened and urgency >= self.cfg.threat_block_start_at and domain != "DEFENSE":
                continue

            if domain in self.cfg.singleton_domains:
                self._preempt_domain(now=now, awareness=awareness, domain=domain, reason=f"preempted_by:{prop.proposal_id}")

            mission_id = f"{prop.proposal_id}:{int(now * 1000)}"
            spec: TaskSpec = prop.task()

            ok, tags, fail_reason = self._select_and_claim_units(
                bot,
                now=now,
                attention=attention,
                spec=spec,
                proposal=prop,
                mission_id=mission_id,
            )
            if not ok:
                self._set_cooldown(
                    awareness,
                    now=now,
                    proposal_id=prop.proposal_id,
                    seconds=float(prop.cooldown_s),
                    reason=fail_reason,
                )
                continue

            task_obj = spec.task_factory(mission_id)
            self._validate_task(task_obj, spec=spec)
            task_obj.bind_mission(mission_id=mission_id, assigned_tags=list(tags))

            ttl = spec.lease_ttl if spec.lease_ttl is not None else prop.lease_ttl
            expires_at = None if ttl is None else (float(now) + float(ttl))

            c = Commitment(
                mission_id=mission_id,
                proposal_id=prop.proposal_id,
                domain=domain,
                task=task_obj,
                started_at=float(now),
                expires_at=expires_at,
                non_preemptible_until=float(now) + float(self.cfg.non_preemptible_grace_s),
                assigned_tags=list(tags),
            )
            self._active[mission_id] = c
            self._active_by_domain.setdefault(domain, []).append(mission_id)

            self._awareness_start_mission(awareness, now=now, c=c)
            awareness.emit(
                "mission_started",
                now=now,
                data={
                    "mission_id": mission_id,
                    "proposal_id": prop.proposal_id,
                    "domain": domain,
                    "tags": len(tags),
                    "ttl": ttl,
                },
            )
            if self.log is not None:
                self.log.emit(
                    "mission_started",
                    {
                        "time": round(now, 2),
                        "mission_id": mission_id,
                        "proposal_id": prop.proposal_id,
                        "domain": domain,
                        "tags": len(tags),
                        "ttl": ttl,
                    },
                )

    async def _execute(self, bot, *, tick: TaskTick, attention: Attention, awareness: Awareness) -> None:
        now = float(tick.time)

        for mission_id, c in list(self._active.items()):
            if c.is_expired(now):
                self._finish_mission(awareness, now=now, c=c, status="DONE", reason="expired")
                continue

            self._touch_leases_for_commitment(now=now, c=c)

            res = await c.task.step(bot, tick, attention)
            if not isinstance(res, TaskResult):
                raise TypeError(f"Task {type(c.task).__name__} returned non-TaskResult: {type(res)!r}")

            if res.status == "FAILED":
                cooldown = float(res.retry_after_s) if float(res.retry_after_s) > 0 else float(self.cfg.default_failure_cooldown_s)
                self._set_cooldown(awareness, now=now, proposal_id=c.proposal_id, seconds=cooldown, reason=res.reason)
                self._finish_mission(awareness, now=now, c=c, status="FAILED", reason=res.reason)
                continue

            if res.status == "DONE":
                self._finish_mission(awareness, now=now, c=c, status="DONE", reason=res.reason)
                continue

            awareness.emit(
                "mission_step",
                now=now,
                data={"mission_id": c.mission_id, "domain": c.domain, "status": res.status, "reason": res.reason},
            )

    def _reap_commitments(self, *, now: float, awareness: Awareness) -> None:
        for mission_id, c in list(self._active.items()):
            if c.is_expired(now):
                self._finish_mission(awareness, now=now, c=c, status="DONE", reason="expired")

    def _finish_mission(self, awareness: Awareness, *, now: float, c: Commitment, status: str, reason: str) -> None:
        self.body.release_mission(mission_id=c.mission_id)

        self._active.pop(c.mission_id, None)
        ids = self._active_by_domain.get(c.domain)
        if ids is not None:
            try:
                ids.remove(c.mission_id)
            except ValueError:
                pass
            if not ids:
                self._active_by_domain.pop(c.domain, None)

        self._awareness_end_mission(awareness, now=now, mission_id=c.mission_id, status=status, reason=reason)
        awareness.emit(
            "mission_ended",
            now=now,
            data={"mission_id": c.mission_id, "proposal_id": c.proposal_id, "domain": c.domain, "status": status, "reason": reason},
        )
        if self.log is not None:
            self.log.emit(
                "mission_ended",
                {
                    "time": round(now, 2),
                    "mission_id": c.mission_id,
                    "proposal_id": c.proposal_id,
                    "domain": c.domain,
                    "status": status,
                    "reason": reason,
                },
            )

    def _is_proposal_running(self, proposal_id: str) -> bool:
        return any(c.proposal_id == proposal_id for c in self._active.values())

    def _preempt_domain(self, *, now: float, awareness: Awareness, domain: str, reason: str) -> None:
        mids = list(self._active_by_domain.get(domain, []))
        for mid in mids:
            c = self._active.get(mid)
            if c is None:
                continue
            self._finish_mission(awareness, now=now, c=c, status="DONE", reason=reason)

    def _validate_task(self, task_obj: Any, *, spec: TaskSpec) -> None:
        if not isinstance(task_obj, Task):
            raise TypeError(f"Task factory for {spec.task_id} returned non-Task: {type(task_obj)!r}")

    def _select_and_claim_units(
        self,
        bot,
        *,
        now: float,
        attention: Attention,
        spec: TaskSpec,
        proposal: Proposal,
        mission_id: str,
    ) -> Tuple[bool, List[int], str]:
        reqs: List[UnitRequirement] = list(spec.unit_requirements)
        if not reqs:
            return True, [], ""

        units_ready = attention.economy.units_ready
        selected: List[int] = []

        for req in reqs:
            utype = req.unit_type
            need = int(req.count)

            if int(units_ready.get(utype, 0)) <= 0:
                return False, [], f"no_{utype.name.lower()}"

            candidates: List[int] = []
            for u in bot.units.of_type(utype).ready:
                tag = int(u.tag)
                if self.body.can_claim(tag, now=now):
                    candidates.append(tag)

            if len(candidates) < need:
                return False, [], f"insufficient_free_{utype.name.lower()}"

            selected.extend(candidates[:need])

        ttl_for_claim = spec.lease_ttl if spec.lease_ttl is not None else proposal.lease_ttl
        if ttl_for_claim is None:
            ttl_for_claim = self.body.default_ttl

        role = self.body._role_for_domain(str(proposal.domain))

        for tag in selected:
            ok = self.body.claim(task_id=mission_id, unit_tag=tag, role=role, now=now, ttl=float(ttl_for_claim), force=False)
            if not ok:
                self.body.release_mission(mission_id=mission_id)
                return False, [], "claim_failed"

        return True, selected, ""

    def _touch_leases_for_commitment(self, *, now: float, c: Commitment) -> None:
        if not c.assigned_tags:
            return

        if c.expires_at is None:
            ttl = self.body.default_ttl
        else:
            remaining = float(c.expires_at) - float(now)
            if remaining <= 0.0:
                return
            ttl = max(0.25, min(8.0, remaining))

        for tag in c.assigned_tags:
            self.body.touch(task_id=c.mission_id, unit_tag=int(tag), now=now, ttl=ttl)

    def _is_in_cooldown(self, awareness: Awareness, *, now: float, proposal_id: str) -> bool:
        until = awareness.mem.get(K("ops", "cooldown", proposal_id, "until"), now=now, default=None)
        if until is None:
            return False
        return float(now) < float(until)

    def _set_cooldown(self, awareness: Awareness, *, now: float, proposal_id: str, seconds: float, reason: str) -> None:
        if seconds <= 0:
            return
        awareness.mem.set(K("ops", "cooldown", proposal_id, "until"), value=float(now) + float(seconds), now=now, ttl=None)
        awareness.mem.set(K("ops", "cooldown", proposal_id, "reason"), value=str(reason), now=now, ttl=None)

    def _awareness_start_mission(self, awareness: Awareness, *, now: float, c: Commitment) -> None:
        awareness.mem.set(K("ops", "mission", c.mission_id, "status"), value="RUNNING", now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", c.mission_id, "domain"), value=c.domain, now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", c.mission_id, "proposal_id"), value=c.proposal_id, now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", c.mission_id, "started_at"), value=float(c.started_at), now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", c.mission_id, "expires_at"), value=c.expires_at, now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", c.mission_id, "assigned_tags"), value=list(c.assigned_tags), now=now, ttl=None)

    def _awareness_end_mission(self, awareness: Awareness, *, now: float, mission_id: str, status: str, reason: str) -> None:
        awareness.mem.set(K("ops", "mission", mission_id, "status"), value=str(status), now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", mission_id, "reason"), value=str(reason), now=now, ttl=None)
        awareness.mem.set(K("ops", "mission", mission_id, "ended_at"), value=float(now), now=now, ttl=None)
```
# bot/mind/self.py
```python
# bot/mind/self.py
from __future__ import annotations

from dataclasses import dataclass

from sc2.data import Result

from bot.devlog import DevLogger
from bot.sensors.threat_sensor import Threat
from bot.intel.enemy_build_intel import EnemyBuildIntelConfig, derive_enemy_build_intel
from bot.mind.attention import derive_attention
from bot.mind.awareness import Awareness
from bot.mind.body import UnitLeases
from bot.mind.ego import Ego, EgoConfig
from bot.tasks.base_task import TaskTick

from bot.tasks.defend_task import Defend
from bot.tasks.scout_task import Scout
from bot.tasks.macro import MacroAresBioStandardTick, MacroAresRushDefenseTick, MacroOpeningTick

from bot.planners.defense_planner import DefensePlanner
from bot.planners.intel_planner import IntelPlanner
from bot.planners.macro_planner import MacroPlanner


@dataclass
class RuntimeApp:
    log: DevLogger
    awareness: Awareness
    threat: Threat
    body: UnitLeases
    ego: Ego
    enemy_build_cfg: EnemyBuildIntelConfig
    debug: bool = True

    @classmethod
    def build(cls, *, log: DevLogger, debug: bool = True) -> "RuntimeApp":
        awareness = Awareness()
        threat = Threat(defend_radius=22.0, min_enemy=1)
        body = UnitLeases(default_ttl=8.0)

        ego = Ego(
            body=body,
            log=log,
            cfg=EgoConfig(
                singleton_domains=frozenset({"MACRO"}),  # only one active MACRO mission at a time
                threat_block_start_at=70,
                threat_force_preempt_at=90,
                non_preemptible_grace_s=2.5,
                default_failure_cooldown_s=8.0,
            ),
        )

        defend_task = Defend(log=log, log_every_iters=11)

        scout_task = Scout(
            awareness=awareness,
            log=log,
            trigger_time=25.0,
            log_every=6.0,
            see_radius=14.0,
        )

        opening_macro_task = MacroOpeningTick(log=log, log_every_iters=22, scv_cap=60)

        bio_standard_task = MacroAresBioStandardTick(
            log=log,
            scv_cap=66,
            target_bases=2,
            log_every_iters=22,
        )

        rush_defense_task = MacroAresRushDefenseTick(
            log=log,
            scv_cap=40,
            target_bases=1,
            log_every_iters=22,
        )

        defense_planner = DefensePlanner(defend_task=defend_task)
        intel_planner = IntelPlanner(awareness=awareness, log=log, scout_task=scout_task)

        macro_planner = MacroPlanner(
            opening_task=opening_macro_task,
            bio_task=bio_standard_task,
            rush_defense_task=rush_defense_task,
            backoff_urgency=60,
        )

        ego.register_planners([defense_planner, intel_planner, macro_planner])

        return cls(
            log=log,
            awareness=awareness,
            threat=threat,
            body=body,
            ego=ego,
            enemy_build_cfg=EnemyBuildIntelConfig(),
            debug=bool(debug),
        )

    async def on_start(self, bot) -> None:
        try:
            self.body.reset()
        except Exception:
            pass
        if self.log:
            self.log.emit("runtime_start", {})

    async def on_step(self, bot, *, iteration: int) -> None:
        now = float(getattr(bot, "time", 0.0))

        attention = derive_attention(bot, awareness=self.awareness, threat=self.threat)

        derive_enemy_build_intel(
            bot,
            awareness=self.awareness,
            attention=attention,
            now=now,
            cfg=self.enemy_build_cfg,
        )

        tick = TaskTick(iteration=int(iteration), time=now)
        await self.ego.tick(bot, tick=tick, attention=attention, awareness=self.awareness)

    async def on_end(self, bot, game_result: Result) -> None:
        if self.log:
            self.log.emit("game_end", {"result": str(game_result)})
```
## bot/planners (full)
# bot/planners/defense_planner.py
```python
# bot/planners/defense_planner.py
from __future__ import annotations

from dataclasses import dataclass

from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.planners.proposals import Proposal, TaskSpec
from bot.tasks.defend_task import Defend


@dataclass
class DefensePlanner:
    """
    Planner reativo de defesa.
    """
    planner_id: str = "defense_planner"
    defend_task: Defend = None  # template instance

    def _pid_defend(self) -> str:
        return f"{self.planner_id}:defend:bases"

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        if (not bool(attention.combat.threatened)) or (not attention.combat.threat_pos):
            return []

        urg = int(attention.combat.defense_urgency)
        score = max(80, min(100, 60 + urg))

        if self.defend_task is None:
            raise TypeError("DefensePlanner requires defend_task template instance")

        def _factory(mission_id: str) -> Defend:
            return self.defend_task.spawn()

        return [
            Proposal(
                proposal_id=self._pid_defend(),
                domain="DEFENSE",
                score=score,
                tasks=[TaskSpec(task_id="defend_bases", task_factory=_factory, unit_requirements=[])],
                lease_ttl=6.0,
                cooldown_s=0.0,
                risk_level=0,
                allow_preempt=True,
            )
        ]
```
# bot/planners/intel_planner.py
```python
# bot/planners/intel_planner.py
from __future__ import annotations

from dataclasses import dataclass

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.planners.proposals import Proposal, TaskSpec, UnitRequirement
from bot.tasks.scan_task import ScanAt
from bot.tasks.scout_task import Scout


@dataclass
class IntelPlanner:
    planner_id: str = "intel_planner"

    awareness: Awareness = None  # injected
    log: DevLogger | None = None
    scout_task: Scout = None  # template instance
    scout_min_dispatch_interval_s: float = 120.0
    scout_lease_ttl_s: float = 120.0

    def _pid_scout(self) -> str:
        return f"{self.planner_id}:scout:scv_early"

    def _pid_scan(self, label: str) -> str:
        return f"{self.planner_id}:scan:{label}"

    def _enemy_main(self, bot) -> Point2:
        # strict: no fallbacks here; if engine doesn't provide, crash to expose wiring bug
        return bot.enemy_start_locations[0]

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        now = float(attention.time)
        proposals: list[Proposal] = []

        if self.awareness is None:
            raise TypeError("IntelPlanner requires awareness injected")
        if self.scout_task is None:
            raise TypeError("IntelPlanner requires scout_task template instance")

        # 1) SCV scout early (planner decides WHEN; task must not time-gate)
        pid = self._pid_scout()

        # only start after trigger time (decision is planner-only)
        if now >= float(getattr(self.scout_task, "trigger_time", 0.0)):
            # stop forever once we got the success signal
            if not awareness.intel_scv_arrived_main(now=now):
                # avoid burning multiple SCVs too early
                last_dispatch = awareness.intel_last_scv_dispatch_at(now=now)
                if last_dispatch > 0.0 and (now - float(last_dispatch)) < float(self.scout_min_dispatch_interval_s):
                    return proposals
                # don't spam: if there's already a RUNNING mission for this proposal_id, do nothing
                if not awareness.ops_proposal_running(proposal_id=pid, now=now):

                    def _scout_factory(mission_id: str) -> Scout:
                        return self.scout_task.spawn()

                    proposals.append(
                        Proposal(
                            proposal_id=pid,
                            domain="INTEL",
                            score=35,
                            tasks=[
                                TaskSpec(
                                    task_id="scout_scv",
                                    task_factory=_scout_factory,
                                    unit_requirements=[UnitRequirement(unit_type=U.SCV, count=1)],
                                )
                            ],
                            lease_ttl=float(self.scout_lease_ttl_s),
                            cooldown_s=8.0,
                            risk_level=1,
                            allow_preempt=True,
                        )
                    )

        # 2) Scan when threatened and orbital ready
        if bool(attention.combat.threatened) and bool(attention.intel.orbital_ready_to_scan):
            target = self._enemy_main(bot)
            label = "enemy_main"

            def _scan_factory(mission_id: str) -> ScanAt:
                return ScanAt(awareness=awareness, target=target, label=label, cooldown=20.0, log=self.log)

            proposals.append(
                Proposal(
                    proposal_id=self._pid_scan(label),
                    domain="INTEL",
                    score=55,
                    tasks=[TaskSpec(task_id="scan_at", task_factory=_scan_factory, unit_requirements=[])],
                    lease_ttl=5.0,
                    cooldown_s=20.0,
                    risk_level=1,
                    allow_preempt=True,
                )
            )

        return proposals
```
# bot/planners/macro_planner.py
```python
# =========================
# FILE: bot/planners/macro_planner.py
# =========================
from __future__ import annotations

from dataclasses import dataclass

from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.planners.proposals import Proposal, TaskSpec
from bot.tasks.macro import (
    MacroAresBioStandardTick as MacroBio2BaseTick,
    MacroAresRushDefenseTick as MacroRushDefenseTick,
    MacroOpeningTick,
)


@dataclass
class MacroPlanner:
    planner_id: str = "macro_planner"
    score: int = 50
    backoff_urgency: int = 85

    opening_task: MacroOpeningTick = None        # injected template
    bio_task: MacroBio2BaseTick = None           # injected template
    rush_defense_task: MacroRushDefenseTick = None  # injected template

    def _pid_opening(self) -> str:
        return f"{self.planner_id}:macro_opening"

    def _pid_bio(self) -> str:
        return f"{self.planner_id}:macro_bio_2base"

    def _pid_rush_def(self) -> str:
        return f"{self.planner_id}:macro_rush_defense"

    def _want_rush_defense(self, *, awareness: Awareness, attention: Attention) -> bool:
        # keep your logic; placeholder strictness: must exist in your code
        return bool(attention.combat.threatened) and int(attention.combat.defense_urgency) >= 70

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        now = float(attention.time)

        if self.opening_task is None or self.bio_task is None or self.rush_defense_task is None:
            raise TypeError("MacroPlanner requires opening_task, bio_task, rush_defense_task")

        # global backoff (you had this)
        if bool(attention.combat.threatened) and int(attention.combat.defense_urgency) >= int(self.backoff_urgency):
            return []

        opening_done = bool(attention.macro.opening_done)
        want_rush = self._want_rush_defense(awareness=awareness, attention=attention)

        # OPENING (non-expiring; ends when task ends OR preempted by another macro mode)
        if not opening_done:
            pid = self._pid_opening()

            def _factory(mission_id: str) -> MacroOpeningTick:
                return self.opening_task.spawn()

            return [
                Proposal(
                    proposal_id=pid,
                    domain="MACRO",
                    score=int(self.score),
                    tasks=[TaskSpec(task_id="macro_opening", task_factory=_factory, unit_requirements=[], lease_ttl=None)],
                    lease_ttl=None,     # IMPORTANT: no autonomous death
                    cooldown_s=0.0,
                    risk_level=0,
                    allow_preempt=True,
                )
            ]

        # RUSH DEFENSE macro (also non-expiring; ends/preempted explicitly)
        if want_rush:
            pid = self._pid_rush_def()

            def _factory(mission_id: str) -> MacroRushDefenseTick:
                return self.rush_defense_task.spawn()

            return [
                Proposal(
                    proposal_id=pid,
                    domain="MACRO",
                    score=int(self.score) + 20,  # higher than normal to ensure selection
                    tasks=[TaskSpec(task_id="macro_rush_defense", task_factory=_factory, unit_requirements=[], lease_ttl=None)],
                    lease_ttl=None,
                    cooldown_s=0.0,
                    risk_level=1,
                    allow_preempt=True,
                )
            ]

        # NORMAL macro (bio 2base)
        pid = self._pid_bio()

        def _factory(mission_id: str) -> MacroBio2BaseTick:
            return self.bio_task.spawn()

        return [
            Proposal(
                proposal_id=pid,
                domain="MACRO",
                score=int(self.score),
                tasks=[TaskSpec(task_id="macro_bio_2base", task_factory=_factory, unit_requirements=[], lease_ttl=None)],
                lease_ttl=None,
                cooldown_s=0.0,
                risk_level=0,
                allow_preempt=True,
            )
        ]
```
# bot/planners/proposals.py
```python
# bot/planners/proposals.py
from __future__ import annotations

from dataclasses import dataclass, field
import inspect
from typing import Callable, List, Optional

from sc2.ids.unit_typeid import UnitTypeId


@dataclass(frozen=True)
class UnitRequirement:
    unit_type: UnitTypeId
    count: int

    def validate(self) -> None:
        if not isinstance(self.unit_type, UnitTypeId):
            raise TypeError(f"UnitRequirement.unit_type must be UnitTypeId, got {type(self.unit_type)!r}")
        if not isinstance(self.count, int):
            raise TypeError(f"UnitRequirement.count must be int, got {type(self.count)!r}")
        if self.count <= 0:
            raise ValueError("UnitRequirement.count must be > 0")


@dataclass(frozen=True)
class TaskSpec:
    """
    One atomic task inside a proposal.

    lease_ttl:
      - None => no time-based mission expiry
      - float => mission expires when ttl elapses
    """

    task_id: str
    task_factory: Callable[[str], object]
    unit_requirements: List[UnitRequirement] = field(default_factory=list)
    lease_ttl: Optional[float] = None

    def validate(self) -> None:
        if not isinstance(self.task_id, str) or not self.task_id.strip():
            raise ValueError("TaskSpec.task_id must be a non-empty string")
        if not callable(self.task_factory):
            raise TypeError("TaskSpec.task_factory must be callable")

        try:
            sig = inspect.signature(self.task_factory)
        except (TypeError, ValueError) as e:
            raise TypeError(f"TaskSpec.task_factory must have an inspectable signature: {e}") from e

        params = list(sig.parameters.values())
        if len(params) != 1:
            raise TypeError("TaskSpec.task_factory must accept exactly 1 parameter: mission_id")

        for r in self.unit_requirements:
            if not isinstance(r, UnitRequirement):
                raise TypeError(f"TaskSpec.unit_requirements must contain UnitRequirement, got {type(r)!r}")
            r.validate()

        if self.lease_ttl is not None:
            if not isinstance(self.lease_ttl, (int, float)):
                raise TypeError("TaskSpec.lease_ttl must be a number")
            if float(self.lease_ttl) <= 0.0:
                raise ValueError("TaskSpec.lease_ttl must be > 0")


@dataclass(frozen=True)
class Proposal:
    proposal_id: str
    domain: str
    score: int

    tasks: List[TaskSpec] = field(default_factory=list)

    lease_ttl: Optional[float] = 30.0
    cooldown_s: float = 10.0
    risk_level: int = 1
    allow_preempt: bool = True

    def __post_init__(self) -> None:
        self.validate()

    def validate(self) -> None:
        if not isinstance(self.proposal_id, str) or not self.proposal_id.strip():
            raise ValueError("Proposal.proposal_id must be a non-empty string")
        if not isinstance(self.domain, str) or not self.domain.strip():
            raise ValueError("Proposal.domain must be a non-empty string")
        if not isinstance(self.score, int):
            raise TypeError("Proposal.score must be int")

        if not isinstance(self.tasks, list) or len(self.tasks) != 1:
            raise ValueError("Proposal.tasks must contain exactly 1 TaskSpec")

        t0 = self.tasks[0]
        if not isinstance(t0, TaskSpec):
            raise TypeError(f"Proposal.tasks[0] must be TaskSpec, got {type(t0)!r}")
        t0.validate()

        if self.lease_ttl is not None:
            if not isinstance(self.lease_ttl, (int, float)):
                raise TypeError("Proposal.lease_ttl must be a number or None")
            if float(self.lease_ttl) <= 0.0:
                raise ValueError("Proposal.lease_ttl must be > 0 when provided")

        if not isinstance(self.cooldown_s, (int, float)):
            raise TypeError("Proposal.cooldown_s must be a number")
        if float(self.cooldown_s) < 0.0:
            raise ValueError("Proposal.cooldown_s must be >= 0")

        if not isinstance(self.risk_level, int):
            raise TypeError("Proposal.risk_level must be int")
        if self.risk_level < 0:
            raise ValueError("Proposal.risk_level must be >= 0")

        if not isinstance(self.allow_preempt, bool):
            raise TypeError("Proposal.allow_preempt must be bool")

    def task(self) -> TaskSpec:
        return self.tasks[0]
```
## bot/sensors (full)
# bot/sensors/__init__.py
```python

```
# bot/sensors/economy_sensor.py
```python
# bot/sensors/economy_sensor.py
from __future__ import annotations

from dataclasses import dataclass
from collections import Counter

from bot.mind.attention import EconomySnapshot


def derive_economy_snapshot(bot) -> EconomySnapshot:
    """
    Economy intel module:
    - units_ready histogram
    - supply_left / minerals / gas

    Rule: no side-effects.
    """
    units_ready = Counter()
    try:
        for u in bot.units.ready:
            units_ready[u.type_id] += 1
    except Exception:
        # keep module resilient (intel should never crash the whole bot)
        pass

    try:
        supply_left = int(getattr(bot, "supply_left", 0) or 0)
        minerals = int(getattr(bot, "minerals", 0) or 0)
        gas = int(getattr(bot, "vespene", 0) or 0)
    except Exception:
        supply_left, minerals, gas = 0, 0, 0

    return EconomySnapshot(
        units_ready=dict(units_ready),
        supply_left=supply_left,
        minerals=minerals,
        gas=gas,
    )
```
# bot/sensors/enemy_build_sensor.py
```python
# bot/sensors/enemy_build_sensor.py
from __future__ import annotations

from collections import Counter, defaultdict
from dataclasses import dataclass
from typing import Dict, Optional, Tuple

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2

from bot.mind.attention import EnemyBuildSnapshot


_TOWNHALL_TYPES: Tuple[U, ...] = (
    U.HATCHERY,
    U.LAIR,
    U.HIVE,
    U.NEXUS,
    U.COMMANDCENTER,
    U.ORBITALCOMMAND,
    U.PLANETARYFORTRESS,
)


def _enemy_main_strict(bot) -> Point2:
    locs = getattr(bot, "enemy_start_locations", None)
    if not locs or len(locs) == 0:
        raise RuntimeError("EnemyBuildSensor requires bot.enemy_start_locations[0]")
    return locs[0]


def _enemy_natural_from_expansions(bot, enemy_main: Point2) -> Optional[Point2]:
    exps = getattr(bot, "expansion_locations_list", None)
    if not exps or len(exps) < 2:
        return None
    # nearest to enemy main is usually the main expansion; second nearest is natural
    ordered = sorted(exps, key=lambda p: p.distance_to(enemy_main))
    return ordered[1] if len(ordered) >= 2 else None


def _progress_stats(values: list[float]) -> dict:
    if not values:
        return {"count": 0, "ready": 0, "incomplete": 0, "min": 0.0, "max": 0.0, "avg": 0.0}
    c = len(values)
    ready = sum(1 for v in values if v >= 0.999)
    incomplete = c - ready
    mn = min(values)
    mx = max(values)
    avg = sum(values) / float(c)
    return {
        "count": int(c),
        "ready": int(ready),
        "incomplete": int(incomplete),
        "min": float(round(mn, 4)),
        "max": float(round(mx, 4)),
        "avg": float(round(avg, 4)),
    }


def derive_enemy_build_sensor(bot) -> EnemyBuildSnapshot:
    """
    EnemyBuildSensor (tick facts -> Attention):
      - counts enemy UNITS and STRUCTURES we currently see this tick
      - also extracts "what's in enemy main" and structure build_progress stats
      - detects whether enemy natural townhall is on the ground (visible)

    Rule: no side-effects. Strict positioning sources (no fallbacks).
    """
    enemy_main = _enemy_main_strict(bot)
    enemy_nat = _enemy_natural_from_expansions(bot, enemy_main)

    # radii are deliberately "loose" so we don't miss mineral line / tech placements
    main_radius = 26.0
    natural_radius = 10.0

    units_all = Counter()
    structs_all = Counter()
    units_main = Counter()
    structs_main = Counter()

    progress_by_type: Dict[U, list[float]] = defaultdict(list)

    # enemy units currently visible
    for u in bot.enemy_units:
        try:
            tid = u.type_id
            units_all[tid] += 1
            if u.position.distance_to(enemy_main) <= main_radius:
                units_main[tid] += 1
        except Exception:
            continue

    # enemy structures currently visible (+ progress stats)
    for s in bot.enemy_structures:
        try:
            tid = s.type_id
            structs_all[tid] += 1

            # build_progress is meaningful for "ongoing vs ready"
            prog = float(getattr(s, "build_progress", 1.0))
            # clamp for sanity
            if prog < 0.0:
                prog = 0.0
            if prog > 1.0:
                prog = 1.0
            progress_by_type[tid].append(prog)

            if s.position.distance_to(enemy_main) <= main_radius:
                structs_main[tid] += 1
        except Exception:
            continue

    # natural townhall visibility
    natural_on_ground = False
    nat_best_prog: Optional[float] = None
    nat_best_type: Optional[U] = None
    if enemy_nat is not None:
        for s in bot.enemy_structures:
            try:
                if s.type_id not in _TOWNHALL_TYPES:
                    continue
                if s.position.distance_to(enemy_nat) <= natural_radius:
                    natural_on_ground = True
                    prog = float(getattr(s, "build_progress", 1.0))
                    if nat_best_prog is None or prog > nat_best_prog:
                        nat_best_prog = prog
                        nat_best_type = s.type_id
            except Exception:
                continue

    progress_stats = {tid: _progress_stats(vals) for tid, vals in progress_by_type.items()}

    return EnemyBuildSnapshot(
        enemy_units=dict(units_all),
        enemy_structures=dict(structs_all),
        enemy_main_pos=enemy_main,
        enemy_natural_pos=enemy_nat,
        enemy_units_main=dict(units_main),
        enemy_structures_main=dict(structs_main),
        enemy_structures_progress=progress_stats,
        enemy_natural_on_ground=bool(natural_on_ground),
        enemy_natural_townhall_progress=float(nat_best_prog) if nat_best_prog is not None else None,
        enemy_natural_townhall_type=nat_best_type,
    )
```
# bot/sensors/macro_sensor.py
```python
# bot/sensors/macro_sensor.py
from __future__ import annotations

from bot.mind.attention import MacroSnapshot


def _opening_done(bot) -> bool:
    """
    Opening state estimation.
    Rule: no side-effects.

    Strict mode:
      - Opening ends only when Ares BuildRunner reports build_completed.
    """
    bor = getattr(bot, "build_order_runner", None)
    if bor is None:
        # bootstrap guard: runner not ready yet this tick
        return False
    if not hasattr(bor, "build_completed"):
        raise AttributeError("Macro sensor requires build_order_runner.build_completed")

    return bool(bor.build_completed)


def derive_macro_snapshot(bot) -> MacroSnapshot:
    return MacroSnapshot(opening_done=bool(_opening_done(bot)))
```
# bot/sensors/orbital_sensor.py
```python
# bot/sensors/orbital_sensor.py
from __future__ import annotations

from typing import Tuple

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.mind.attention import IntelSnapshot


def _orbital_scan_status(bot) -> Tuple[bool, float]:
    """
    Returns (ready_to_scan, energy).
    Rule: no side-effects.
    """
    try:
        orbitals = bot.structures(U.ORBITALCOMMAND).ready
        if orbitals.amount == 0:
            return False, 0.0
        oc = orbitals.first
        energy = float(getattr(oc, "energy", 0.0) or 0.0)
        return (energy >= 50.0), energy
    except Exception:
        return False, 0.0


def derive_orbital_snapshot(bot) -> IntelSnapshot:
    ready, energy = _orbital_scan_status(bot)
    return IntelSnapshot(
        orbital_ready_to_scan=bool(ready),
        orbital_energy=float(energy),
    )
```
# bot/sensors/threat_sensor.py
```python
# bot/sensors/threat_sensor.py
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional, Tuple

from sc2.position import Point2
from sc2.unit import Unit


@dataclass(frozen=True)
class ThreatReport:
    threatened: bool
    threat_pos: Optional[Point2]
    enemy_count: int
    radius: float
    urgency: int  # 0..100


class Threat:
    """
    Intelligence-only:
      - Detecta inimigos perto de townhalls
      - Produz threat_pos + enemy_count + urgency
    """

    def __init__(self, *, defend_radius: float = 22.0, min_enemy: int = 1):
        self.defend_radius = float(defend_radius)
        self.min_enemy = int(min_enemy)

    def _townhalls(self, bot) -> List[Unit]:
        try:
            return list(bot.townhalls)
        except Exception:
            return []

    def evaluate(self, bot) -> ThreatReport:
        ths = self._townhalls(bot)
        if not ths:
            return ThreatReport(False, None, 0, self.defend_radius, 0)

        enemies = bot.enemy_units
        if not enemies:
            return ThreatReport(False, None, 0, self.defend_radius, 0)

        best: Tuple[int, Optional[Point2]] = (0, None)
        for th in ths:
            near = enemies.closer_than(self.defend_radius, th.position)
            c = int(near.amount)
            if c > best[0]:
                best = (c, th.position)

        threatened = best[0] >= self.min_enemy
        enemy_count = int(best[0])

        # urgência simples (MVP): ameaça => 50 + 10*count, cap 100
        urgency = 0
        if threatened:
            urgency = min(100, 50 + 10 * enemy_count)

        return ThreatReport(threatened, best[1], enemy_count, self.defend_radius, int(urgency))
```
## bot/tasks (full)
# bot/tasks/__init__.py
```python

```
# bot/tasks/base_task.py
```python
# bot/tasks/base_task.py
from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import Optional, Protocol, runtime_checkable
import copy

from bot.mind.attention import Attention


class TaskStatus(str, Enum):
    """
    Task lifecycle. Keep values stable because logs/debug will depend on this.
    """
    IDLE = "IDLE"
    ACTIVE = "ACTIVE"
    PAUSED = "PAUSED"
    DONE = "DONE"
    ABORTED = "ABORTED"


@dataclass(frozen=True)
class TaskTick:
    iteration: int
    time: float


@dataclass(frozen=True)
class TaskResult:
    """
    Execution feedback (task -> Ego). STRICT contract: tasks must return TaskResult.

    status:
      - RUNNING: task continues as active mission
      - DONE: task completed successfully (mission can end)
      - FAILED: task failed (mission should end; Ego applies cooldown etc.)
      - NOOP: task chose to do nothing this tick (still running)
    """
    status: str  # RUNNING | DONE | FAILED | NOOP
    reason: str = ""
    retry_after_s: float = 0.0
    telemetry: Optional[dict] = None

    @staticmethod
    def running(reason: str = "", telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="RUNNING", reason=str(reason), telemetry=telemetry)

    @staticmethod
    def done(reason: str = "", telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="DONE", reason=str(reason), telemetry=telemetry)

    @staticmethod
    def failed(reason: str = "", retry_after_s: float = 0.0, telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="FAILED", reason=str(reason), retry_after_s=float(retry_after_s), telemetry=telemetry)

    @staticmethod
    def noop(reason: str = "", telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="NOOP", reason=str(reason), telemetry=telemetry)


@runtime_checkable
class Task(Protocol):
    """
    Contract required by Ego + planners.

    Notes:
    - domain is a string slot key (e.g. "DEFENSE", "INTEL")
    - step() returns TaskResult (STRICT)
    """
    task_id: str
    domain: str
    commitment: int

    def status(self) -> TaskStatus: ...
    def is_done(self) -> bool: ...
    def evaluate(self, bot, attention: Attention) -> int: ...
    def bind_mission(self, *, mission_id: str, assigned_tags: list[int]) -> None: ...
    async def step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult: ...
    async def pause(self, bot, reason: str) -> None: ...
    async def abort(self, bot, reason: str) -> None: ...
    def last_reason(self) -> str: ...
    def last_step_time(self) -> float: ...
    def spawn(self) -> "BaseTask": ...


@dataclass
class BaseTask:
    """
    Convenience base class.

    Policy:
      - NO legacy bool returns. on_step MUST return TaskResult.
      - Mission binding is explicit via bind_mission(); no setattr fallbacks.
    """
    task_id: str
    domain: str
    commitment: int  # NOTE: required (no default) to avoid dataclass field-order issues in subclasses

    # mission binding (set by Ego)
    mission_id: Optional[str] = field(default=None, init=False)
    assigned_tags: list[int] = field(default_factory=list, init=False)

    # internal state
    _status: TaskStatus = field(default=TaskStatus.IDLE, init=False)
    _last_reason: str = field(default="", init=False)
    _last_step_t: float = field(default=0.0, init=False)

    # -----------------------
    # Core contract
    # -----------------------
    def status(self) -> TaskStatus:
        return self._status

    def is_done(self) -> bool:
        return self._status in (TaskStatus.DONE, TaskStatus.ABORTED)

    def evaluate(self, bot, attention: Attention) -> int:
        return 0

    def bind_mission(self, *, mission_id: str, assigned_tags: list[int]) -> None:
        if not isinstance(mission_id, str) or not mission_id:
            raise ValueError("mission_id must be a non-empty string")
        self.mission_id = mission_id
        self.assigned_tags = [int(x) for x in (assigned_tags or [])]

    async def step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        if self.is_done():
            return TaskResult.noop("already_done")

        if self._status == TaskStatus.IDLE:
            self._status = TaskStatus.ACTIVE

        self._last_step_t = float(tick.time)

        out = await self.on_step(bot, tick, attention)

        if not isinstance(out, TaskResult):
            raise TypeError(f"{self.__class__.__name__}.on_step must return TaskResult, got {type(out)!r}")

        return out

    async def pause(self, bot, reason: str) -> None:
        if self.is_done():
            return
        self._status = TaskStatus.PAUSED
        self._last_reason = str(reason)

    async def abort(self, bot, reason: str) -> None:
        if self.is_done():
            return
        self._status = TaskStatus.ABORTED
        self._last_reason = str(reason)

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        raise NotImplementedError

    # -----------------------
    # Helpers (optional)
    # -----------------------
    def _done(self, reason: str = "") -> None:
        self._status = TaskStatus.DONE
        self._last_reason = str(reason)

    def _active(self, reason: str = "") -> None:
        self._status = TaskStatus.ACTIVE
        if reason:
            self._last_reason = str(reason)

    def _paused(self, reason: str = "") -> None:
        self._status = TaskStatus.PAUSED
        if reason:
            self._last_reason = str(reason)

    def last_reason(self) -> str:
        return self._last_reason

    def last_step_time(self) -> float:
        return float(self._last_step_t)

    def spawn(self) -> "BaseTask":
        """
        Create a fresh instance of this task (for multiple missions using same script).
        This is a deep copy + reset of lifecycle and mission binding.
        """
        t: BaseTask = copy.deepcopy(self)
        t._status = TaskStatus.IDLE
        t._last_reason = ""
        t._last_step_t = 0.0
        t.mission_id = None
        t.assigned_tags = []
        return t
```
# bot/tasks/defend_task.py
```python
# bot/tasks/defend_task.py
from __future__ import annotations

from dataclasses import dataclass

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class Defend(BaseTask):
    """
    Defesa reativa das bases.
    """
    log: DevLogger | None = None
    log_every_iters: int = 11

    def __init__(self, *, log: DevLogger | None = None, log_every_iters: int = 11):
        super().__init__(task_id="defend_bases", domain="DEFENSE", commitment=90)
        self.log = log
        self.log_every_iters = int(log_every_iters)

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        if (not attention.combat.threatened) or (not attention.combat.threat_pos):
            self._paused("no_threat")
            return TaskResult.noop("no_threat")

        defenders = bot.units.of_type(
            {
                U.MARINE,
                U.MARAUDER,
                U.SIEGETANK,
                U.SIEGETANKSIEGED,
                U.HELLION,
                U.CYCLONE,
                U.THOR,
                U.THORAP,
                U.MEDIVAC,
            }
        )
        if defenders.amount == 0:
            self._paused("no_defenders")
            return TaskResult.noop("no_defenders")

        local = defenders.closer_than(45, attention.combat.threat_pos)
        if local.amount == 0:
            local = defenders

        medivacs = local(U.MEDIVAC)
        army = local - medivacs

        issued = False

        for u in army:
            if u.is_idle:
                u.attack(attention.combat.threat_pos)
                issued = True

        for m in medivacs:
            if m.is_idle:
                m.move(attention.combat.threat_pos.towards(bot.start_location, 6))
                issued = True

        if issued:
            self._active("defending")
            if self.log and (tick.iteration % self.log_every_iters == 0):
                self.log.emit(
                    "defend_tick",
                    {
                        "iteration": int(tick.iteration),
                        "time": round(float(getattr(bot, "time", 0.0)), 2),
                        "enemy_count": int(attention.combat.enemy_count_near_bases),
                        "urgency": int(attention.combat.defense_urgency),
                        "pos": [round(attention.combat.threat_pos.x, 1), round(attention.combat.threat_pos.y, 1)],
                    },
                )
            return TaskResult.running("defending")
        else:
            self._active("defending_no_orders")
            return TaskResult.noop("defending_no_orders")
```
# bot/tasks/macro/__init__.py
```python
from bot.tasks.macro.bio_standard import MacroAresBioStandardTick
from bot.tasks.macro.opening import MacroOpeningTick
from bot.tasks.macro.rush_defend import MacroAresRushDefenseTick

__all__ = [
    "MacroOpeningTick",
    "MacroAresBioStandardTick",
    "MacroAresRushDefenseTick",
]
```
# bot/tasks/macro/ares_plan.py
```python
# bot/tasks/macro/ares_plan.py
from __future__ import annotations

from bot.devlog import DevLogger
from bot.tasks.base_task import TaskTick


def register_macro_plan(bot, plan, *, log: DevLogger | None, tick: TaskTick, label: str, log_every_iters: int = 22) -> None:
    """
    Strict: requires AresBot.register_behavior to exist.
    This helper stays inside tasks layer; planners/ego remain unaware of Ares internals.
    """
    bot.register_behavior(plan)

    if log and (int(tick.iteration) % int(log_every_iters) == 0):
        log.emit(
            "macro_ares_plan",
            {"iter": int(tick.iteration), "t": round(float(tick.time), 2), "label": str(label)},
        )
```
# bot/tasks/macro/bio_standard.py
```python
# bot/tasks/macro/bio_standard.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult
from bot.tasks.macro.ares_plan import register_macro_plan


@dataclass
class MacroAresBioStandardTick(BaseTask):
    """
    Standard macro (BIO-ish) using Ares MacroPlan behaviors.

    Goal: "never stalls" macro:
      - autosupply
      - continuous workers (to scv_cap)
      - expand to target_bases
      - basic production + spawn loop
    """
    log: DevLogger | None = None
    scv_cap: int = 66
    target_bases: int = 2
    log_every_iters: int = 22

    def __init__(self, *, log: DevLogger | None = None, scv_cap: int = 66, target_bases: int = 2, log_every_iters: int = 22):
        super().__init__(task_id="macro_ares_bio_standard", domain="MACRO", commitment=15)
        self.log = log
        self.scv_cap = int(scv_cap)
        self.target_bases = int(target_bases)
        self.log_every_iters = int(log_every_iters)

    def _army_comp(self) -> Dict[U, int]:
        # Weights (not caps). Keep simple & robust.
        return {
            U.MARINE: 10,
            U.MEDIVAC: 2,
        }

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        from ares.behaviors.macro import (
            AutoSupply,
            BuildWorkers,
            ExpansionController,
            GasBuildingController,
            MacroPlan,
            ProductionController,
            SpawnController,
        )

        plan = MacroPlan()
        plan.add(AutoSupply(base_location=bot.start_location))
        plan.add(BuildWorkers(to_count=int(self.scv_cap)))
        plan.add(GasBuildingController())
        plan.add(ExpansionController(to_base_count=int(self.target_bases)))
        plan.add(ProductionController())
        plan.add(SpawnController(army_composition_dict=self._army_comp()))

        register_macro_plan(bot, plan, log=self.log, tick=tick, label="BIO_STANDARD", log_every_iters=self.log_every_iters)
        self._active("ares_macro_standard")
        return TaskResult.running("ares_macro_standard")
```
# bot/tasks/macro/macro_task.py
```python
# bot/tasks/macro_task.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class MacroOpeningTick(BaseTask):
    """
    Opening macro minimalista:
      - SCV contínuo até scv_cap

    (Mantido propositalmente simples. O build runner/YML pode cuidar do resto do opening.)
    """
    log: DevLogger | None = None
    log_every_iters: int = 22
    scv_cap: int = 60

    def __init__(self, *, log: DevLogger | None = None, log_every_iters: int = 22, scv_cap: int = 60):
        super().__init__(task_id="macro_opening_scv_only", domain="MACRO", commitment=10)
        self.log = log
        self.log_every_iters = int(log_every_iters)
        self.scv_cap = int(scv_cap)

    def _workers(self, bot) -> int:
        return int(bot.workers.amount)

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        ths = bot.townhalls.ready
        if ths.amount == 0:
            self._paused("no_townhalls")
            return TaskResult.noop("no_townhalls")

        if int(bot.supply_left) <= 0:
            self._paused("no_supply")
            return TaskResult.noop("no_supply")

        if self._workers(bot) >= self.scv_cap:
            self._active("scv_cap")
            return TaskResult.noop("scv_cap")

        if not bot.can_afford(U.SCV):
            self._paused("cant_afford_scv")
            return TaskResult.noop("cant_afford_scv")

        idle_ths = ths.idle
        if idle_ths.amount == 0:
            self._active("townhalls_busy")
            return TaskResult.noop("townhalls_busy")

        idle_ths.first.train(U.SCV)
        self._active("training_scv_opening")

        if self.log and (tick.iteration % self.log_every_iters == 0):
            self.log.emit(
                "macro_opening",
                {"iter": int(tick.iteration), "t": round(float(tick.time), 2), "action": "train_scv"},
            )

        return TaskResult.running("train_scv")


# ---------------------------
# Ares-powered macro builds
# ---------------------------

def _register_macro_plan(bot, plan, *, log: DevLogger | None, tick: TaskTick, label: str) -> None:
    """
    Strict: relies on AresBot.register_behavior existing.
    This is inside macro task, not planner/ego.
    """
    bot.register_behavior(plan)
    if log and (tick.iteration % 22 == 0):
        log.emit("macro_ares_plan", {"iter": int(tick.iteration), "t": round(float(tick.time), 2), "label": str(label)})


@dataclass
class MacroAresBioStandardTick(BaseTask):
    """
    Standard macro (BIO-ish) using Ares MacroPlan behaviors.

    Goal: "never stalls" macro:
      - autosupply
      - continuous workers (to scv_cap)
      - expand to 2 bases (can bump later)
      - basic production + spawn loop (marines + occasional medivac)
    """
    log: DevLogger | None = None
    scv_cap: int = 66
    target_bases: int = 2

    def __init__(self, *, log: DevLogger | None = None, scv_cap: int = 66, target_bases: int = 2):
        super().__init__(task_id="macro_ares_bio_standard", domain="MACRO", commitment=15)
        self.log = log
        self.scv_cap = int(scv_cap)
        self.target_bases = int(target_bases)

    def _army_comp(self) -> Dict[U, int]:
        # Weights (not absolute caps). Keep simple & robust.
        return {
            U.MARINE: 10,
            U.MEDIVAC: 2,
        }

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        # Ares imports are strict (no fallback/compat layers)
        from ares.behaviors.macro import (
            AutoSupply,
            BuildWorkers,
            ExpansionController,
            GasBuildingController,
            MacroPlan,
            ProductionController,
            SpawnController,
        )

        plan = MacroPlan()

        # Priority order matters: MacroPlan executes behaviors sequentially and stops after a successful one.
        plan.add(AutoSupply(base_location=bot.start_location))
        plan.add(BuildWorkers(to_count=int(self.scv_cap)))
        plan.add(GasBuildingController())  # lets Ares decide sensible refinery timing
        plan.add(ExpansionController(to_base_count=int(self.target_bases)))
        plan.add(ProductionController())
        plan.add(SpawnController(army_composition_dict=self._army_comp()))

        _register_macro_plan(bot, plan, log=self.log, tick=tick, label="BIO_STANDARD")
        self._active("ares_macro_standard")
        return TaskResult.running("ares_macro_standard")


@dataclass
class MacroAresRushDefenseTick(BaseTask):
    """
    Rush-defense macro using Ares MacroPlan behaviors.

    Philosophy:
      - DO NOT expand
      - Keep workers going (but lower cap)
      - Spend on immediate army
      - Keep supply safe
    """
    log: DevLogger | None = None
    scv_cap: int = 40
    target_bases: int = 1

    def __init__(self, *, log: DevLogger | None = None, scv_cap: int = 40, target_bases: int = 1):
        super().__init__(task_id="macro_ares_rush_defense", domain="MACRO", commitment=20)
        self.log = log
        self.scv_cap = int(scv_cap)
        self.target_bases = int(target_bases)

    def _army_comp(self) -> Dict[U, int]:
        # Pure "don't die" comp. You can enrich later (marauder, bunker logic, etc).
        return {
            U.MARINE: 14,
        }

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        from ares.behaviors.macro import (
            AutoSupply,
            BuildWorkers,
            ExpansionController,
            MacroPlan,
            ProductionController,
            SpawnController,
        )

        plan = MacroPlan()
        plan.add(AutoSupply(base_location=bot.start_location))
        plan.add(BuildWorkers(to_count=int(self.scv_cap)))
        plan.add(ExpansionController(to_base_count=int(self.target_bases)))  # locks at 1
        plan.add(ProductionController())
        plan.add(SpawnController(army_composition_dict=self._army_comp()))

        _register_macro_plan(bot, plan, log=self.log, tick=tick, label="RUSH_DEFENSE")
        self._active("ares_macro_rush_defense")
        return TaskResult.running("ares_macro_rush_defense")
```
# bot/tasks/macro/opening.py
```python
# bot/tasks/macro/opening.py
from __future__ import annotations

from dataclasses import dataclass

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class MacroOpeningTick(BaseTask):
    """
    Opening macro minimalista:
      - SCV contínuo até scv_cap

    Mantido simples de propósito. (BuildRunner/YML pode cuidar do resto do opening.)
    """
    log: DevLogger | None = None
    log_every_iters: int = 22
    scv_cap: int = 60

    def __init__(self, *, log: DevLogger | None = None, log_every_iters: int = 22, scv_cap: int = 60):
        super().__init__(task_id="macro_opening_scv_only", domain="MACRO", commitment=10)
        self.log = log
        self.log_every_iters = int(log_every_iters)
        self.scv_cap = int(scv_cap)

    def _workers(self, bot) -> int:
        return int(bot.workers.amount)

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        ths = bot.townhalls.ready
        if ths.amount == 0:
            self._paused("no_townhalls")
            return TaskResult.noop("no_townhalls")

        if int(bot.supply_left) <= 0:
            self._paused("no_supply")
            return TaskResult.noop("no_supply")

        if self._workers(bot) >= self.scv_cap:
            self._active("scv_cap")
            return TaskResult.noop("scv_cap")

        if not bot.can_afford(U.SCV):
            self._paused("cant_afford_scv")
            return TaskResult.noop("cant_afford_scv")

        idle_ths = ths.idle
        if idle_ths.amount == 0:
            self._active("townhalls_busy")
            return TaskResult.noop("townhalls_busy")

        idle_ths.first.train(U.SCV)
        self._active("training_scv_opening")

        if self.log and (tick.iteration % self.log_every_iters == 0):
            self.log.emit(
                "macro_opening",
                {"iter": int(tick.iteration), "t": round(float(tick.time), 2), "action": "train_scv"},
            )

        return TaskResult.running("train_scv")
```
# bot/tasks/macro/rush_defend/__init__.py
```python
# bot/tasks/macro/rush_defend/__init__.py
from __future__ import annotations

from bot.tasks.macro.rush_defend.rush_defense import MacroAresRushDefenseTick

__all__ = ["MacroAresRushDefenseTick"]
```
# bot/tasks/macro/rush_defend/rush_defense.py
```python
# bot/tasks/macro/rush_defend/rush_defense.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult
from bot.tasks.macro.ares_plan import register_macro_plan


@dataclass
class MacroAresRushDefenseTick(BaseTask):
    """
    Rush-defense macro using Ares MacroPlan behaviors.

    Philosophy:
      - DO NOT expand
      - Keep workers going (but lower cap)
      - Spend on immediate army
      - Keep supply safe
    """
    log: DevLogger | None = None
    scv_cap: int = 40
    target_bases: int = 1
    log_every_iters: int = 22

    def __init__(self, *, log: DevLogger | None = None, scv_cap: int = 40, target_bases: int = 1, log_every_iters: int = 22):
        super().__init__(task_id="macro_ares_rush_defense", domain="MACRO", commitment=20)
        self.log = log
        self.scv_cap = int(scv_cap)
        self.target_bases = int(target_bases)
        self.log_every_iters = int(log_every_iters)

    def _army_comp(self) -> Dict[U, int]:
        return {U.MARINE: 14}

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        from ares.behaviors.macro import (
            AutoSupply,
            BuildWorkers,
            ExpansionController,
            MacroPlan,
            ProductionController,
            SpawnController,
        )

        plan = MacroPlan()
        plan.add(AutoSupply(base_location=bot.start_location))
        plan.add(BuildWorkers(to_count=int(self.scv_cap)))
        plan.add(ExpansionController(to_base_count=int(self.target_bases)))  # locks at 1
        plan.add(ProductionController())
        plan.add(SpawnController(army_composition_dict=self._army_comp()))

        register_macro_plan(bot, plan, log=self.log, tick=tick, label="RUSH_DEFENSE", log_every_iters=self.log_every_iters)
        self._active("ares_macro_rush_defense")
        return TaskResult.running("ares_macro_rush_defense")
```
# bot/tasks/scan_task.py
```python
# bot/tasks/scan_task.py
from __future__ import annotations

from dataclasses import dataclass, field

from sc2.ids.ability_id import AbilityId
from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class ScanAt(BaseTask):
    # required deps first (avoid dataclass non-default-after-default errors)
    awareness: Awareness
    target: object
    label: str

    # config
    cooldown: float = 20.0
    log: DevLogger | None = None

    # internal state
    _last_scan_t: float = field(default=0.0, init=False)

    def __init__(self, *, awareness: Awareness, target, label: str, cooldown: float = 20.0, log: DevLogger | None = None):
        super().__init__(task_id="scan_at", domain="INTEL", commitment=5)
        self.awareness = awareness
        self.target = target
        self.label = str(label)
        self.cooldown = float(cooldown)
        self.log = log
        self._last_scan_t = 0.0

    def evaluate(self, bot, attention: Attention) -> int:
        now = float(attention.time)

        # if no orbital energy, don't propose high
        if not bool(attention.intel.orbital_ready_to_scan):
            return 0

        # cooldown
        if now - float(self._last_scan_t) < float(self.cooldown):
            return 0

        # if already scanned enemy main, reduce need
        if self.label == "enemy_main" and self.awareness.intel_scanned_enemy_main(now=now):
            return 0

        return 40

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        now = float(tick.time)

        if not bool(attention.intel.orbital_ready_to_scan):
            self._paused("no_orbital_energy")
            return TaskResult.noop("no_orbital_energy")

        if now - float(self._last_scan_t) < float(self.cooldown):
            self._paused("cooldown")
            return TaskResult.noop("cooldown")

        try:
            orbitals = bot.structures(U.ORBITALCOMMAND).ready
            if orbitals.amount == 0:
                self._paused("no_orbital")
                return TaskResult.noop("no_orbital")

            oc = orbitals.first
            target = self.target

            oc(AbilityId.SCANNERSWEEP_SCAN, target)
            self._last_scan_t = float(now)

            if self.label == "enemy_main":
                self.awareness.mark_scanned_enemy_main(now=now)

            if self.log:
                self.log.emit("scan_cast", {"t": round(float(now), 2), "label": str(self.label)})

            self._active("scan_cast")
            return TaskResult.running("scan_cast")

        except Exception:
            self._paused("scan_failed")
            return TaskResult.failed("scan_failed", retry_after_s=6.0)
```
# bot/tasks/scout_task.py
```python
# bot/tasks/scout_task.py
from __future__ import annotations

from dataclasses import dataclass, field

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class Scout(BaseTask):
    """
    Single SCV scout to enemy main.

    IMPORTANT POLICY:
      - This task MUST NOT decide if it's "time" to start scouting.
        That decision belongs to the planner.
      - This task MUST ONLY use the unit(s) assigned by Ego via bind_mission().
        Never request/select a new worker by itself (otherwise you end up with ALL SCVs scouting).
    """

    # required deps first (avoid dataclass non-default-after-default errors)
    awareness: Awareness

    # config
    log: DevLogger | None = None
    trigger_time: float = 25.0  # kept for planner to read; task does NOT gate on it
    log_every: float = 6.0
    see_radius: float = 14.0
    arrived_ttl: float = 120.0

    # internal state
    _last_log_t: float = field(default=0.0, init=False)

    def __init__(
        self,
        *,
        awareness: Awareness,
        log: DevLogger | None = None,
        trigger_time: float = 25.0,
        log_every: float = 6.0,
        see_radius: float = 14.0,
        arrived_ttl: float = 120.0,
    ):
        super().__init__(task_id="scout_scv", domain="INTEL", commitment=3)
        self.awareness = awareness
        self.log = log
        self.trigger_time = float(trigger_time)
        self.log_every = float(log_every)
        self.see_radius = float(see_radius)
        self.arrived_ttl = float(arrived_ttl)
        self._last_log_t = 0.0

    def evaluate(self, bot, attention: Attention) -> int:
        now = float(attention.time)

        # If already succeeded, this task is not needed.
        if self.awareness.intel_scv_arrived_main(now=now):
            return 0

        # Don't time-gate here; planner decides. Keep a modest baseline.
        return 20

    def _log_tick(self, *, now: float, reason: str, tag: int, dist: float) -> None:
        if not self.log:
            return
        if (now - float(self._last_log_t)) < float(self.log_every):
            return
        self._last_log_t = float(now)
        self.log.emit(
            "scout_tick",
            {
                "t": round(float(now), 2),
                "mission_id": str(self.mission_id or ""),
                "tag": int(tag),
                "reason": str(reason),
                "dist": round(float(dist), 2),
            },
        )

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        now = float(tick.time)

        if not isinstance(self.mission_id, str) or not self.mission_id:
            return TaskResult.failed("unbound_mission")

        if not isinstance(self.assigned_tags, list) or len(self.assigned_tags) != 1:
            return TaskResult.failed("expected_exactly_1_assigned_tag")

        tag = int(self.assigned_tags[0])

        # mark dispatch the first time the mission actually runs
        if not self.awareness.intel_scv_dispatched(now=now):
            self.awareness.mark_scv_dispatched(now=now)

        # Fetch the assigned SCV (do NOT request/select a new one)
        scv = bot.units.find_by_tag(tag)
        if scv is None:
            return TaskResult.failed("assigned_unit_missing")

        if scv.type_id != U.SCV:
            return TaskResult.failed("assigned_unit_not_scv")

        target = bot.enemy_start_locations[0]  # strict: engine must provide
        dist = float(scv.distance_to(target))

        # success condition: got close enough to enemy main
        if dist <= float(self.see_radius):
            self.awareness.mark_scv_arrived_main(now=now, ttl=self.arrived_ttl)
            # release the worker back to economy after scout success
            if bot.mineral_field.amount > 0:
                scv.gather(bot.mineral_field.closest_to(bot.start_location))
            else:
                scv.move(bot.start_location)
            if self.log:
                self.log.emit(
                    "scout_success",
                    {
                        "t": round(float(now), 2),
                        "mission_id": str(self.mission_id),
                        "tag": int(tag),
                        "dist": round(float(dist), 2),
                    },
                )
            self._done("arrived_enemy_main")
            return TaskResult.done("arrived_enemy_main")

        # otherwise keep moving
        scv.move(target)
        self._active("moving_to_enemy_main")
        self._log_tick(now=now, reason="moving", tag=tag, dist=dist)
        return TaskResult.running("moving_to_enemy_main")
```

===== ROOT CONFIGS =====
# terran_builds.yml
```yaml
UseData: False
BuildSelection: Cycle
MinGamesWinrateBased: 3

BuildChoices:
  Protoss:
    BotName: MyBot
    Cycle: [Default]
  Terran:
    BotName: MyBot
    Cycle: [Default]
  Zerg:
    BotName: MyBot
    Cycle: [Default]
  Random:
    BotName: MyBot
    Cycle: [Default]

Builds:
  Default:
    # Do not set AutoSupplyAtSupply to 0, or it may place depots in bad spots.
    # Enable it only after the basic wall is in place.
    AutoSupplyAtSupply: 20
    ConstantWorkerProductionTill: 32
    OpeningBuildOrder:
      - 14 supply @ ramp
      - 16 barracks @ ramp
      - 16 gas
      - 0 orbital
      # Second wall depot (prevents autosupply from breaking the wall-off)
      - 19 supply @ ramp
      - 19 expand
      - 21 factory
      - 21 barracksreactor
      - 21 gas
      - 21 starport
      - 21 addonswap starport barracksreactor
      - 23 marine *4

  DefensiveOpening:
    AutoSupplyAtSupply: 20
    ConstantWorkerProductionTill: 28
    OpeningBuildOrder:
      - 14 supply @ ramp
      - 16 barracks @ ramp
      - 16 gas
      - 0 orbital
      - 19 supply @ ramp
      - 20 marine *3
      - 21 factory
      - 21 gas
      - 21 starport
      - 23 marine *4

```
# config.yml
```yaml
# Check `ares-sc2/src/ares/config.yml` for valid config options
# Use this to override those values
# Can add own unique config options here if desired

# Set custom values here for your bot
MyBotName: MyBot
MyBotRace: Terran
# setting ture allows auto upload to aiareana (https://aiarena.net/) on push to `main` branch
# see tutorial on readme before setting to True
AutoUploadToAiarena: False
BotZipPubliclyDownloadable: False
BotDataPubliclyDownloadable: False
BotDataEnabled: True
########################

UseData: False
Debug: False
GameStep: 2
DebugGameStep: 2

# Turn ares features on/off for performance reasons
Features:
    # this grid is useful for disruptor balls and maybe some other uses
    # off by default to save computation
    TacticalGroundGrid: False

DebugOptions:
    # one of: Air, AirVsGround, Ground, GroundAvoidance, AirAvoidance
    ActiveGrid: TacticalGround
    ChatDebug: True
    DebugSpawn: False
    ShowPathingCost: True
    ResourceDebug: False
    ShowBuildingFormation: False
```
# run.py
```python
#run.py
import random
import sys
from os import path
from pathlib import Path
import platform
from typing import List
from loguru import logger

from sc2 import maps
from sc2.data import AIBuild, Difficulty, Race
from sc2.main import run_game
from sc2.player import Bot, Computer

sys.path.append("ares-sc2/src/ares")
sys.path.append("ares-sc2/src")
sys.path.append("ares-sc2")

import yaml

from bot.main import MyBot
from ladder import run_ladder_game

plt = platform.system()
if plt == "Windows":
    MAPS_PATH: str = "C:\\Program Files (x86)\\StarCraft II\\Maps"
elif plt == "Darwin":
    MAPS_PATH: str = "/Applications/StarCraft II/Maps"
elif plt == "Linux":
    MAPS_PATH: str = (
        "~/<username>/Games/battlenet/drive_c/Program Files (x86)/StarCraft II/Maps"
    )
else:
    logger.error(f"{plt} not supported")
    sys.exit()

CONFIG_FILE: str = "config.yml"
MAP_FILE_EXT: str = "SC2Map"
MY_BOT_NAME: str = "MyBotName"
MY_BOT_RACE: str = "MyBotRace"


def main():
    bot_name: str = "MyBot"

    # ✅ não deixe Random aqui, sua build order é Terran
    race: Race = Race.Terran

    __user_config_location__: str = path.abspath(".")
    user_config_path: str = path.join(__user_config_location__, CONFIG_FILE)

    # opcional: permitir override por config.yml, mas valida
    if path.isfile(user_config_path):
        with open(user_config_path) as config_file:
            config: dict = yaml.safe_load(config_file) or {}
            if MY_BOT_NAME in config:
                bot_name = config[MY_BOT_NAME]
            if MY_BOT_RACE in config:
                cfg_race = str(config[MY_BOT_RACE]).title()
                try:
                    race = Race[cfg_race]
                except Exception:
                    logger.warning(f"Invalid {MY_BOT_RACE}='{cfg_race}', forcing Terran.")
                    race = Race.Terran

    # ✅ se alguém colocar Random no config, ainda assim trava tudo.
    # então aqui eu garanto Terran:
    race = Race.Terran

    bot1 = Bot(race, MyBot(), bot_name)

    if "--LadderServer" in sys.argv:
        print("Starting ladder game...")
        result, opponentid = run_ladder_game(bot1)
        print(result, " against opponent ", opponentid)
    else:
        map_list: List[str] = [
            p.name.replace(f".{MAP_FILE_EXT}", "")
            for p in Path(MAPS_PATH).glob(f"*.{MAP_FILE_EXT}")
            if p.is_file()
        ]
        if len(map_list) == 0:
            logger.error(f"Can't find maps, please check `MAPS_PATH` in `run.py'")
            logger.info("Trying back up option")
            map_list = [
                "PylonAIE_v4",
                "PersephoneAIE_v4",
                "TorchesAIE_v4",
                "IncorporealAIE_v4",
                "MagannathaAIE_v2",
                "UltraloveAIE_v2",
            ]

        random_race = random.choice([Race.Zerg, Race.Terran, Race.Protoss])
        print("Starting local game...")
        run_game(
            maps.get(random.choice(map_list)),
            [
                bot1,
                Computer(random_race, Difficulty.VeryEasy, ai_build=AIBuild.Macro),
            ],
            realtime=False,
        )


if __name__ == "__main__":
    main()
```
# ARCHITECTURE.md
```markdown
# ARES STRATEGIC ARCHITECTURE

## 1. Visão Geral

Esta arquitetura define uma camada estratégica acima do Ares.

Objetivos:

- Separar decisão de execução
- Permitir preempção limpa (ex: cancelar drop para defender)
- Manter macro estável sob pressão
- Ser auditável via logs
- Escalar para adaptação estatística futura
- Não reinventar funcionalidades já fornecidas pelo Ares

Ares continua responsável por:
- Pathfinding
- Unit control básico
- Worker selection
- Build order execution
- Placement
- Squad system

Nossa arquitetura controla:
- Decisão estratégica
- Prioridades
- Seleção de missões
- Preempção
- Orquestração de domínios

---

## 2. Princípios Fundamentais

1. Policy calcula. Não executa.
2. Director orquestra. Não microgerencia.
3. Mission executa com lifecycle formal.
4. Coordinator arbitra conflitos.
5. Macro é serviço contínuo, não entra em leilão.
6. Ownership de unidades é explícito via roles.
7. Toda missão possui abort protocol.
8. Toda decisão relevante é logável.

---

## 3. Componentes do Sistema

### 3.1 Policies (Avaliação Pura)

Características:
- Stateless ou quase.
- Não emitem comandos.
- Produzem sinais derivados do estado.

Principais Policies:

#### ThreatPolicy
Produz:
- ThreatZones
- ThreatIntent (harass / push / all-in)
- DefenseUrgency (por base)

#### StrategicPolicy
Produz:
- StrategicState (AHEAD / EVEN / BEHIND)
- Confidence

#### BudgetPolicy
Produz:
- ScanBudget
- HarassBudget
- RiskTolerance

---

### 3.2 Directors (Orquestradores Stateful)

Características:
- Mantêm estado local
- Propõem missões candidatas
- Aplicam cooldowns
- Não definem modo global

Domínios:

#### StrategyDirector
- Define modo atual
- Define pesos por domínio
- Define budgets
- Define política de preempção

Não cria missões diretamente.

#### DefenseDirector
Propõe:
- HoldBaseMission
- StaticDefenseMission
- PullWorkersEmergencyMission

#### IntelDirector
Propõe:
- WorkerScoutMission
- TacticalScanMission
- SpotterMission

#### MapControlDirector
Propõe:
- ScreenLaneMission
- CreepDenyMission
- ExpansionCheckMission

#### HarassDirector
Propõe:
- DropMission
- RunbyMission
- MultiProngMission (futuro)

#### ProductionDirector
Não usa missões.
Produz:
- ProductionGoals
- CompositionTargets
- TransitionRequests

---

### 3.3 Coordinator

Responsável por:

1. Receber missões candidatas
2. Aplicar pesos definidos pelo StrategyDirector
3. Selecionar missões ativas
4. Resolver conflitos de unidades (roles)
5. Aplicar preempção
6. Garantir mínimos globais

Não decide estratégia.
Não executa micro.

---

## 4. Mission Model

### 4.1 Estrutura

Toda missão possui:

- mission_id
- domain
- priority_base
- commitment_level (LOW / MED / HIGH)
- required_roles
- timeout
- cooldown
- pause_capable
- abort_protocol
- report_schema

---

### 4.2 Lifecycle

Estados:

- PLANNING
- ACTIVE
- PAUSED
- ABORTING
- DONE

---

### 4.3 Commitment Levels

LOW:
- Scout
- Map control
Sempre preemptável.

MED:
- Harass em trânsito
Preemptável dependendo da urgência.

HIGH:
- Engage ativo
- All-in commit
Abortável apenas sob urgência crítica.

---

### 4.4 Abort Protocol

Toda missão deve definir:

- Como liberar roles
- Como dissolver squad
- Para onde redirecionar unidades
- Como reportar motivo de término

---

### 4.5 Mission Report

Toda missão gera:

- start_time
- end_time
- outcome (success / abort / timeout)
- resources_used
- units_lost
- damage_done
- intel_gained

Permite adaptação futura.

---

## 5. State Global (Blackboard + Signals)

### 5.1 IntelState

- LastKnownEnemyArmyPosition
- KnownEnemyTechFlags
- KnownEnemyBases
- Staleness
- Confidence

---

### 5.2 ThreatZones

Para cada base/região:

- enemy_count
- enemy_power_estimate
- severity_score

---

### 5.3 DefenseUrgency

Para cada base:

- severity (0–100)
- time_to_impact
- threat_type
- confidence

---

### 5.4 StrategicState

- AHEAD
- EVEN
- BEHIND
- confidence

---

## 6. Modos Globais

### OPENING
- BuildRunner dominante
- Defense médio
- Harass baixo

### SAFE_MACRO
- Growth ativo
- MapControl médio
- Harass moderado

### PRESSURE
- Harass alto
- MapControl alto
- Defense médio

### DEFEND
- Defense alto
- Harass baixo
- MapControl reduzido

### EMERGENCY_DEFENSE
- Defense máximo
- Harass pausado
- MapControl mínimo
- Preempção agressiva

### CLOSE_OUT (futuro)
- Negar bases
- Conter inimigo
- Finalizar jogo

Cada modo define:
- Pesos por domínio
- Budgets
- Política de preempção

---

## 7. Macro Model

Macro é contínua e dividida em camadas.

### Vital Loop (sempre ativo)
- Supply safety
- Worker mínimo
- Estruturas essenciais

### Growth Loop
- Expandir
- Saturar
- Upgrades

### Greed Loop
- Expansão agressiva
- Tech pesado

Modos podem desabilitar Growth/Greed.
Vital nunca é totalmente desativado.

---

## 8. Preempção

### Soft Preempt
- Pausa missão
- Reavalia quando urgência cair

### Hard Preempt
- Aborta missão
- Libera roles
- Ativa defesa

### Sem Preempção
- Defesa local suficiente disponível

---

## 9. Integração com Ares

Não reimplementar:

- Pathfinding
- Worker selection
- Unit grouping
- Build order logic
- Placement

Missões devem:

- Usar UnitRole para ownership
- Usar squads do Ares
- Usar mediator
- Usar BuildRunner

---

## 10. Logging Obrigatório

Registrar:

- Modo atual
- DefenseUrgency
- Top mission candidates (score)
- Missões selecionadas
- Preempções
- Motivo de término de missão

---

## 11. Ordem Recomendada de Implementação

1. MissionRegistry + Coordinator + DefenseUrgency
2. DefenseDirector MVP
3. IntelDirector MVP
4. MapControlDirector MVP
5. HarassDirector MVP
6. Production refinement
7. Adaptação estatística
```

===== LOG SUMMARY =====
file: devlog_20260226_063404.jsonl
events_total: 26
top_events:
- scout_tick: 16
- mission_started: 4
- scout_success: 2
- mission_ended: 2
- runtime_start: 1
- game_end: 1
recent_events:
- 2026-02-26T06:34:04.727808+00:00 runtime_start {}
- 2026-02-26T06:34:04.768826+00:00 mission_started {'time': 0.0, 'mission_id': 'macro_planner:macro_opening:0', 'proposal_id': 'macro_planner:macro_opening', 'domain': 'MACRO', 'tags': 0, 'ttl': None}
- 2026-02-26T06:34:15.661268+00:00 mission_started {'time': 25.0, 'mission_id': 'intel_planner:scout:scv_early:25000', 'proposal_id': 'intel_planner:scout:scv_early', 'domain': 'INTEL', 'tags': 1, 'ttl': 120.0}
- 2026-02-26T06:34:15.664021+00:00 scout_tick {'t': 25.0, 'mission_id': 'intel_planner:scout:scv_early:25000', 'tag': 4347396097, 'reason': 'moving', 'dist': 145.73}
- 2026-02-26T06:34:18.221090+00:00 scout_tick {'t': 31.07, 'mission_id': 'intel_planner:scout:scv_early:25000', 'tag': 4347396097, 'reason': 'moving', 'dist': 125.55}
- 2026-02-26T06:34:20.891414+00:00 scout_tick {'t': 37.14, 'mission_id': 'intel_planner:scout:scv_early:25000', 'tag': 4347396097, 'reason': 'moving', 'dist': 107.05}
- 2026-02-26T06:34:23.185776+00:00 scout_tick {'t': 43.21, 'mission_id': 'intel_planner:scout:scv_early:25000', 'tag': 4347396097, 'reason': 'moving', 'dist': 83.18}
- 2026-02-26T06:34:25.605216+00:00 scout_tick {'t': 49.29, 'mission_id': 'intel_planner:scout:scv_early:25000', 'tag': 4347396097, 'reason': 'moving', 'dist': 59.56}
- 2026-02-26T06:34:28.183833+00:00 scout_tick {'t': 55.36, 'mission_id': 'intel_planner:scout:scv_early:25000', 'tag': 4347396097, 'reason': 'moving', 'dist': 40.24}
- 2026-02-26T06:34:30.822641+00:00 scout_tick {'t': 61.43, 'mission_id': 'intel_planner:scout:scv_early:25000', 'tag': 4347396097, 'reason': 'moving', 'dist': 21.65}
- 2026-02-26T06:34:31.856088+00:00 scout_success {'t': 63.66, 'mission_id': 'intel_planner:scout:scv_early:25000', 'tag': 4347396097, 'dist': 13.76}
- 2026-02-26T06:34:31.857085+00:00 mission_ended {'time': 63.66, 'mission_id': 'intel_planner:scout:scv_early:25000', 'proposal_id': 'intel_planner:scout:scv_early', 'domain': 'INTEL', 'status': 'DONE', 'reason': 'arrived_enemy_main'}
- 2026-02-26T06:34:31.901622+00:00 mission_started {'time': 63.75, 'mission_id': 'intel_planner:scout:scv_early:63750', 'proposal_id': 'intel_planner:scout:scv_early', 'domain': 'INTEL', 'tags': 1, 'ttl': 120.0}
- 2026-02-26T06:34:31.902586+00:00 scout_tick {'t': 63.75, 'mission_id': 'intel_planner:scout:scv_early:63750', 'tag': 4342939649, 'reason': 'moving', 'dist': 144.93}
- 2026-02-26T06:34:34.578337+00:00 scout_tick {'t': 69.82, 'mission_id': 'intel_planner:scout:scv_early:63750', 'tag': 4342939649, 'reason': 'moving', 'dist': 124.45}
- 2026-02-26T06:34:37.643580+00:00 scout_tick {'t': 75.89, 'mission_id': 'intel_planner:scout:scv_early:63750', 'tag': 4342939649, 'reason': 'moving', 'dist': 110.05}
- 2026-02-26T06:34:40.264683+00:00 scout_tick {'t': 81.96, 'mission_id': 'intel_planner:scout:scv_early:63750', 'tag': 4342939649, 'reason': 'moving', 'dist': 86.18}
- 2026-02-26T06:34:42.831345+00:00 scout_tick {'t': 88.04, 'mission_id': 'intel_planner:scout:scv_early:63750', 'tag': 4342939649, 'reason': 'moving', 'dist': 62.52}
- 2026-02-26T06:34:45.532735+00:00 scout_tick {'t': 94.11, 'mission_id': 'intel_planner:scout:scv_early:63750', 'tag': 4342939649, 'reason': 'moving', 'dist': 42.22}
- 2026-02-26T06:34:48.287890+00:00 scout_tick {'t': 100.18, 'mission_id': 'intel_planner:scout:scv_early:63750', 'tag': 4342939649, 'reason': 'moving', 'dist': 24.57}
- 2026-02-26T06:34:49.657977+00:00 scout_success {'t': 103.12, 'mission_id': 'intel_planner:scout:scv_early:63750', 'tag': 4342939649, 'dist': 13.95}
- 2026-02-26T06:34:49.659481+00:00 mission_ended {'time': 103.12, 'mission_id': 'intel_planner:scout:scv_early:63750', 'proposal_id': 'intel_planner:scout:scv_early', 'domain': 'INTEL', 'status': 'DONE', 'reason': 'arrived_enemy_main'}
- 2026-02-26T06:34:49.695561+00:00 mission_started {'time': 103.21, 'mission_id': 'intel_planner:scout:scv_early:103214', 'proposal_id': 'intel_planner:scout:scv_early', 'domain': 'INTEL', 'tags': 1, 'ttl': 120.0}
- 2026-02-26T06:34:49.696596+00:00 scout_tick {'t': 103.21, 'mission_id': 'intel_planner:scout:scv_early:103214', 'tag': 4348968961, 'reason': 'moving', 'dist': 144.93}
- 2026-02-26T06:34:52.454194+00:00 scout_tick {'t': 109.29, 'mission_id': 'intel_planner:scout:scv_early:103214', 'tag': 4348968961, 'reason': 'moving', 'dist': 124.53}
- 2026-02-26T06:34:52.487823+00:00 game_end {'result': 'Result.Defeat'}
