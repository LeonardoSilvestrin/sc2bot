# bot/tasks/scout_task.py

# bot/tasks/scout_task.py
from __future__ import annotations

from dataclasses import dataclass, field

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.devlog import DevLogger
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.tasks.base_task import BaseTask, TaskTick, TaskResult


@dataclass
class Scout(BaseTask):
    """
    Single SCV scout to enemy main.

    IMPORTANT POLICY:
      - This task MUST NOT decide if it's "time" to start scouting.
        That decision belongs to the planner.
      - This task MUST ONLY use the unit(s) assigned by Ego via bind_mission().
        Never request/select a new worker by itself (otherwise you end up with ALL SCVs scouting).
    """

    # required deps first (avoid dataclass non-default-after-default errors)
    awareness: Awareness

    # config
    log: DevLogger | None = None
    trigger_time: float = 25.0  # kept for planner to read; task does NOT gate on it
    log_every: float = 6.0
    see_radius: float = 14.0
    arrived_ttl: float = 120.0

    # internal state
    _last_log_t: float = field(default=0.0, init=False)

    def __init__(
        self,
        *,
        awareness: Awareness,
        log: DevLogger | None = None,
        trigger_time: float = 25.0,
        log_every: float = 6.0,
        see_radius: float = 14.0,
        arrived_ttl: float = 120.0,
    ):
        super().__init__(task_id="scout_scv", domain="INTEL", commitment=3)
        self.awareness = awareness
        self.log = log
        self.trigger_time = float(trigger_time)
        self.log_every = float(log_every)
        self.see_radius = float(see_radius)
        self.arrived_ttl = float(arrived_ttl)
        self._last_log_t = 0.0

    def evaluate(self, bot, attention: Attention) -> int:
        now = float(attention.time)

        # If already succeeded, this task is not needed.
        if self.awareness.intel_scv_arrived_main(now=now):
            return 0

        # Don't time-gate here; planner decides. Keep a modest baseline.
        return 20

    def _log_tick(self, *, now: float, reason: str, tag: int, dist: float) -> None:
        if not self.log:
            return
        if (now - float(self._last_log_t)) < float(self.log_every):
            return
        self._last_log_t = float(now)
        self.log.emit(
            "scout_tick",
            {
                "t": round(float(now), 2),
                "mission_id": str(self.mission_id or ""),
                "tag": int(tag),
                "reason": str(reason),
                "dist": round(float(dist), 2),
            },
        )

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        now = float(tick.time)

        if not isinstance(self.mission_id, str) or not self.mission_id:
            return TaskResult.failed("unbound_mission")

        if not isinstance(self.assigned_tags, list) or len(self.assigned_tags) != 1:
            return TaskResult.failed("expected_exactly_1_assigned_tag")

        tag = int(self.assigned_tags[0])

        # mark dispatch the first time the mission actually runs
        if not self.awareness.intel_scv_dispatched(now=now):
            self.awareness.mark_scv_dispatched(now=now)

        # Fetch the assigned SCV (do NOT request/select a new one)
        scv = bot.units.find_by_tag(tag)
        if scv is None:
            return TaskResult.failed("assigned_unit_missing")

        if scv.type_id != U.SCV:
            return TaskResult.failed("assigned_unit_not_scv")

        target = bot.enemy_start_locations[0]  # strict: engine must provide
        dist = float(scv.distance_to(target))

        # success condition: got close enough to enemy main
        if dist <= float(self.see_radius):
            self.awareness.mark_scv_arrived_main(now=now, ttl=self.arrived_ttl)
            # release the worker back to economy after scout success
            if bot.mineral_field.amount > 0:
                scv.gather(bot.mineral_field.closest_to(bot.start_location))
            else:
                scv.move(bot.start_location)
            if self.log:
                self.log.emit(
                    "scout_success",
                    {
                        "t": round(float(now), 2),
                        "mission_id": str(self.mission_id),
                        "tag": int(tag),
                        "dist": round(float(dist), 2),
                    },
                )
            self._done("arrived_enemy_main")
            return TaskResult.done("arrived_enemy_main")

        # otherwise keep moving
        scv.move(target)
        self._active("moving_to_enemy_main")
        self._log_tick(now=now, reason="moving", tag=tag, dist=dist)
        return TaskResult.running("moving_to_enemy_main")
