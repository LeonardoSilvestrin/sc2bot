# bot/tasks/base_task.py

# bot/tasks/base_task.py
from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import Optional, Protocol, runtime_checkable
import copy

from bot.mind.attention import Attention


class TaskStatus(str, Enum):
    """
    Task lifecycle. Keep values stable because logs/debug will depend on this.
    """
    IDLE = "IDLE"
    ACTIVE = "ACTIVE"
    PAUSED = "PAUSED"
    DONE = "DONE"
    ABORTED = "ABORTED"


@dataclass(frozen=True)
class TaskTick:
    iteration: int
    time: float


@dataclass(frozen=True)
class TaskResult:
    """
    Execution feedback (task -> Ego). STRICT contract: tasks must return TaskResult.

    status:
      - RUNNING: task continues as active mission
      - DONE: task completed successfully (mission can end)
      - FAILED: task failed (mission should end; Ego applies cooldown etc.)
      - NOOP: task chose to do nothing this tick (still running)
    """
    status: str  # RUNNING | DONE | FAILED | NOOP
    reason: str = ""
    retry_after_s: float = 0.0
    telemetry: Optional[dict] = None

    @staticmethod
    def running(reason: str = "", telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="RUNNING", reason=str(reason), telemetry=telemetry)

    @staticmethod
    def done(reason: str = "", telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="DONE", reason=str(reason), telemetry=telemetry)

    @staticmethod
    def failed(reason: str = "", retry_after_s: float = 0.0, telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="FAILED", reason=str(reason), retry_after_s=float(retry_after_s), telemetry=telemetry)

    @staticmethod
    def noop(reason: str = "", telemetry: Optional[dict] = None) -> "TaskResult":
        return TaskResult(status="NOOP", reason=str(reason), telemetry=telemetry)


@runtime_checkable
class Task(Protocol):
    """
    Contract required by Ego + planners.

    Notes:
    - domain is a string slot key (e.g. "DEFENSE", "INTEL")
    - step() returns TaskResult (STRICT)
    """
    task_id: str
    domain: str
    commitment: int

    def status(self) -> TaskStatus: ...
    def is_done(self) -> bool: ...
    def evaluate(self, bot, attention: Attention) -> int: ...
    def bind_mission(self, *, mission_id: str, assigned_tags: list[int]) -> None: ...
    async def step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult: ...
    async def pause(self, bot, reason: str) -> None: ...
    async def abort(self, bot, reason: str) -> None: ...
    def last_reason(self) -> str: ...
    def last_step_time(self) -> float: ...
    def spawn(self) -> "BaseTask": ...


@dataclass
class BaseTask:
    """
    Convenience base class.

    Policy:
      - NO legacy bool returns. on_step MUST return TaskResult.
      - Mission binding is explicit via bind_mission(); no setattr fallbacks.
    """
    task_id: str
    domain: str
    commitment: int  # NOTE: required (no default) to avoid dataclass field-order issues in subclasses

    # mission binding (set by Ego)
    mission_id: Optional[str] = field(default=None, init=False)
    assigned_tags: list[int] = field(default_factory=list, init=False)

    # internal state
    _status: TaskStatus = field(default=TaskStatus.IDLE, init=False)
    _last_reason: str = field(default="", init=False)
    _last_step_t: float = field(default=0.0, init=False)

    # -----------------------
    # Core contract
    # -----------------------
    def status(self) -> TaskStatus:
        return self._status

    def is_done(self) -> bool:
        return self._status in (TaskStatus.DONE, TaskStatus.ABORTED)

    def evaluate(self, bot, attention: Attention) -> int:
        return 0

    def bind_mission(self, *, mission_id: str, assigned_tags: list[int]) -> None:
        if not isinstance(mission_id, str) or not mission_id:
            raise ValueError("mission_id must be a non-empty string")
        self.mission_id = mission_id
        self.assigned_tags = [int(x) for x in (assigned_tags or [])]

    async def step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        if self.is_done():
            return TaskResult.noop("already_done")

        if self._status == TaskStatus.IDLE:
            self._status = TaskStatus.ACTIVE

        self._last_step_t = float(tick.time)

        out = await self.on_step(bot, tick, attention)

        if not isinstance(out, TaskResult):
            raise TypeError(f"{self.__class__.__name__}.on_step must return TaskResult, got {type(out)!r}")

        return out

    async def pause(self, bot, reason: str) -> None:
        if self.is_done():
            return
        self._status = TaskStatus.PAUSED
        self._last_reason = str(reason)

    async def abort(self, bot, reason: str) -> None:
        if self.is_done():
            return
        self._status = TaskStatus.ABORTED
        self._last_reason = str(reason)

    async def on_step(self, bot, tick: TaskTick, attention: Attention) -> TaskResult:
        raise NotImplementedError

    # -----------------------
    # Helpers (optional)
    # -----------------------
    def _done(self, reason: str = "") -> None:
        self._status = TaskStatus.DONE
        self._last_reason = str(reason)

    def _active(self, reason: str = "") -> None:
        self._status = TaskStatus.ACTIVE
        if reason:
            self._last_reason = str(reason)

    def _paused(self, reason: str = "") -> None:
        self._status = TaskStatus.PAUSED
        if reason:
            self._last_reason = str(reason)

    def last_reason(self) -> str:
        return self._last_reason

    def last_step_time(self) -> float:
        return float(self._last_step_t)

    def spawn(self) -> "BaseTask":
        """
        Create a fresh instance of this task (for multiple missions using same script).
        This is a deep copy + reset of lifecycle and mission binding.
        """
        t: BaseTask = copy.deepcopy(self)
        t._status = TaskStatus.IDLE
        t._last_reason = ""
        t._last_step_t = 0.0
        t.mission_id = None
        t.assigned_tags = []
        return t
