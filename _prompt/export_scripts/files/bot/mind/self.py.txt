# bot/mind/self.py

# bot/mind/self.py
from __future__ import annotations

from dataclasses import asdict, dataclass, is_dataclass
from enum import Enum
from pathlib import Path
from typing import Any

from sc2.data import Result

from bot.devlog import DevLogger
from bot.sensors.threat_sensor import Threat
from bot.intel.enemy_build_intel import EnemyBuildIntelConfig, derive_enemy_build_intel
from bot.intel.my_army_composition_intel import MyArmyCompositionConfig, derive_my_army_composition_intel
from bot.mind.attention import derive_attention
from bot.mind.awareness import Awareness
from bot.mind.body import UnitLeases
from bot.mind.ego import Ego, EgoConfig
from bot.tasks.base_task import TaskTick

from bot.tasks.defend_task import Defend
from bot.tasks.scout_task import Scout
from bot.tasks.macro.opening import MacroOpeningTick

from bot.planners.defense_planner import DefensePlanner
from bot.planners.intel_planner import IntelPlanner

from bot.planners.production_planner import ProductionPlanner
from bot.planners.spending_planner import SpendingPlanner
from bot.planners.housekeeping_planner import HousekeepingPlanner
from bot.planners.depot_control_planner import DepotControlPlanner


def _jsonable(value: Any) -> Any:
    if value is None or isinstance(value, (str, int, float, bool)):
        return value

    if isinstance(value, Enum):
        return str(value.name)

    if is_dataclass(value):
        return _jsonable(asdict(value))

    if isinstance(value, dict):
        out: dict[str, Any] = {}
        for k, v in value.items():
            out[str(k)] = _jsonable(v)
        return out

    if isinstance(value, (list, tuple, set, frozenset)):
        return [_jsonable(v) for v in value]

    if hasattr(value, "x") and hasattr(value, "y"):
        try:
            return {"x": float(getattr(value, "x")), "y": float(getattr(value, "y"))}
        except Exception:
            return str(value)

    return str(value)


@dataclass
class RuntimeApp:
    log: DevLogger
    awareness: Awareness
    threat: Threat
    body: UnitLeases
    ego: Ego
    enemy_build_cfg: EnemyBuildIntelConfig
    my_comp_cfg: MyArmyCompositionConfig
    debug: bool = True
    attention_full_every_iters: int = 25
    awareness_full_every_iters: int = 50
    full_snapshots_default: bool = False
    full_snapshots_flag_path: str = "_prompt/full_snapshots.flag"
    bo_diag_every_iters: int = 25
    bo_stall_warn_s: float = 25.0
    _bo_last_step_idx: int = -1
    _bo_last_step_t: float = 0.0

    @classmethod
    def build(cls, *, log: DevLogger, debug: bool = True) -> "RuntimeApp":
        awareness = Awareness(log=None)
        threat = Threat(defend_radius=22.0, min_enemy=1)
        body = UnitLeases(default_ttl=8.0)

        ego = Ego(
            body=body,
            log=log,
            cfg=EgoConfig(
                # New singleton macro domains: allow spending+production+housekeeping concurrently,
                # without changing Ego internals.
                singleton_domains=frozenset({"MACRO_SPENDING", "MACRO_PRODUCTION", "MACRO_HOUSEKEEPING", "MACRO_DEPOT_CONTROL"}),
                threat_block_start_at=70,
                threat_force_preempt_at=90,
                non_preemptible_grace_s=2.5,
                default_failure_cooldown_s=8.0,
            ),
        )

        defend_task = Defend(log=log, log_every_iters=11)

        scout_task = Scout(
            awareness=awareness,
            log=log,
            trigger_time=25.0,
            log_every=6.0,
            see_radius=14.0,
        )

        # Opening remains a tiny SCV-only macro while BuildRunner/YML does the rest.
        opening_macro_task = MacroOpeningTick(log=log, log_every_iters=22, scv_cap=60)

        defense_planner = DefensePlanner(defend_task=defend_task, log=log)
        intel_planner = IntelPlanner(awareness=awareness, log=log, scout_task=scout_task)

        spending_planner = SpendingPlanner(
            target_bases_default=2,
            flood_m=800,
            flood_hi_m=1400,
            flood_hold_s=12.0,
            log=log,
        )

        production_planner = ProductionPlanner(
            scv_cap=66,
            log=log,
        )

        housekeeping_planner = HousekeepingPlanner(
            interval_s=35.0,
            cooldown_s=6.0,
            lease_ttl_s=12.0,
            score=18,
            log=log,
        )

        depot_control_planner = DepotControlPlanner(
            interval_s=1.5,
            cooldown_s=0.0,
            score=24,
            log=log,
        )

        # Keep opening as a "pre-macro" handled by its own planner? (MVP: reuse ProductionPlanner gate.)
        # For now: register opening via a tiny planner-inline shim inside runtime:
        # We keep it as a planner to respect the architecture.
        from bot.planners.proposals import Proposal, TaskSpec

        @dataclass
        class OpeningPlanner:
            planner_id: str = "opening_planner"
            score: int = 60
            log: DevLogger | None = None
            opening_task: MacroOpeningTick = None

            def _pid(self) -> str:
                return f"{self.planner_id}:macro_opening"

            def propose(self, bot, *, awareness: Awareness, attention) -> list[Proposal]:
                now = float(attention.time)
                # If BuildOrderRunner exists, let it own opening execution.
                if getattr(bot, "build_order_runner", None) is not None:
                    return []
                if bool(attention.macro.opening_done):
                    return []
                pid = self._pid()
                if awareness.ops_proposal_running(proposal_id=pid, now=now):
                    return []

                def _factory(mission_id: str) -> MacroOpeningTick:
                    return self.opening_task.spawn()

                out = [
                    Proposal(
                        proposal_id=pid,
                        domain="MACRO_PRODUCTION",  # opening shares the production lane
                        score=int(self.score),
                        tasks=[TaskSpec(task_id="macro_opening", task_factory=_factory, unit_requirements=[], lease_ttl=None)],
                        lease_ttl=None,
                        cooldown_s=0.0,
                        risk_level=0,
                        allow_preempt=True,
                    )
                ]
                if self.log:
                    self.log.emit(
                        "planner_proposed",
                        {"planner": self.planner_id, "count": len(out), "mode": "opening"},
                        meta={"module": "planner", "component": f"planner.{self.planner_id}"},
                    )
                return out

        opening_planner = OpeningPlanner(opening_task=opening_macro_task, log=log)

        ego.register_planners(
            [
                defense_planner,
                intel_planner,
                opening_planner,
                spending_planner,
                production_planner,
                housekeeping_planner,
                depot_control_planner,
            ]
        )

        return cls(
            log=log,
            awareness=awareness,
            threat=threat,
            body=body,
            ego=ego,
            enemy_build_cfg=EnemyBuildIntelConfig(),
            my_comp_cfg=MyArmyCompositionConfig(),
            debug=bool(debug),
        )

    async def on_start(self, bot) -> None:
        try:
            self.body.reset()
        except Exception:
            pass
        if self.log:
            self.log.emit("runtime_start", {})

    async def on_step(self, bot, *, iteration: int) -> None:
        now = float(getattr(bot, "time", 0.0))

        attention = derive_attention(bot, awareness=self.awareness, threat=self.threat, log=None)

        derive_enemy_build_intel(
            bot,
            awareness=self.awareness,
            attention=attention,
            now=now,
            cfg=self.enemy_build_cfg,
        )

        # New: strategy reference (mode + proportions)
        derive_my_army_composition_intel(
            awareness=self.awareness,
            attention=attention,
            now=now,
            cfg=self.my_comp_cfg,
        )

        self._emit_build_order_diagnostics(bot, now=now, iteration=int(iteration))

        if self.log and self._full_snapshots_enabled():
            if int(iteration) % max(1, int(self.attention_full_every_iters)) == 0:
                self.log.emit(
                    "attention_full",
                    _jsonable(attention),
                    meta={"module": "attention", "component": "attention.full"},
                )
            if int(iteration) % max(1, int(self.awareness_full_every_iters)) == 0:
                self.log.emit(
                    "awareness_full",
                    {
                        "mem": _jsonable(self.awareness.mem.snapshot(now=now)),
                        "events_tail": _jsonable(self.awareness.tail_events(80)),
                    },
                    meta={"module": "awareness", "component": "awareness.full"},
                )

        tick = TaskTick(iteration=int(iteration), time=now)
        await self.ego.tick(bot, tick=tick, attention=attention, awareness=self.awareness)

    async def on_end(self, bot, game_result: Result) -> None:
        if self.log:
            self.log.emit("game_end", {"result": str(game_result)})

    def _full_snapshots_enabled(self) -> bool:
        if bool(self.full_snapshots_default):
            return True
        try:
            return Path(self.full_snapshots_flag_path).exists()
        except Exception:
            return False

    def _emit_build_order_diagnostics(self, bot, *, now: float, iteration: int) -> None:
        if self.log is None:
            return

        bor = getattr(bot, "build_order_runner", None)
        if bor is None:
            return

        build_order = list(getattr(bor, "build_order", []) or [])
        total_steps = len(build_order)
        step_idx = int(getattr(bor, "build_step", 0) or 0)
        temp_step_idx = int(getattr(bor, "_temporary_build_step", -1) or -1)
        build_completed = bool(getattr(bor, "build_completed", False))
        chosen_opening = str(getattr(bor, "chosen_opening", ""))
        current_step_started = bool(getattr(bor, "current_step_started", False))
        current_step_complete = bool(getattr(bor, "current_step_complete", False))

        if step_idx != self._bo_last_step_idx:
            self._bo_last_step_idx = int(step_idx)
            self._bo_last_step_t = float(now)
        stall_s = max(0.0, float(now) - float(self._bo_last_step_t))

        command_name = ""
        start_at_supply = None
        target = None
        start_condition_ok = None
        end_condition_ok = None

        if 0 <= step_idx < total_steps:
            step = build_order[step_idx]
            command_name = getattr(step.command, "name", str(step.command))
            start_at_supply = int(getattr(step, "start_at_supply", 0) or 0)
            target = _jsonable(getattr(step, "target", None))
            try:
                start_condition_ok = bool(step.start_condition())
            except Exception as e:
                start_condition_ok = f"error:{type(e).__name__}"
            try:
                end_condition_ok = bool(step.end_condition())
            except Exception as e:
                end_condition_ok = f"error:{type(e).__name__}"

        if int(iteration) % max(1, int(self.bo_diag_every_iters)) == 0:
            self.log.emit(
                "build_order_status",
                {
                    "iter": int(iteration),
                    "t": round(float(now), 2),
                    "chosen_opening": chosen_opening,
                    "build_completed": bool(build_completed),
                    "step_idx": int(step_idx),
                    "total_steps": int(total_steps),
                    "temp_step_idx": int(temp_step_idx),
                    "current_step_started": bool(current_step_started),
                    "current_step_complete": bool(current_step_complete),
                    "command": command_name,
                    "start_at_supply": start_at_supply,
                    "target": target,
                    "start_condition_ok": start_condition_ok,
                    "end_condition_ok": end_condition_ok,
                    "supply_used": float(getattr(bot, "supply_used", 0.0) or 0.0),
                    "minerals": int(getattr(bot, "minerals", 0) or 0),
                    "vespene": int(getattr(bot, "vespene", 0) or 0),
                    "stall_s_on_step": round(float(stall_s), 2),
                },
                meta={"module": "macro", "component": "build_order.runner"},
            )

        if (
            not build_completed
            and total_steps > 0
            and stall_s >= float(self.bo_stall_warn_s)
            and int(iteration) % max(1, int(self.bo_diag_every_iters)) == 0
        ):
            self.log.emit(
                "build_order_stall",
                {
                    "iter": int(iteration),
                    "t": round(float(now), 2),
                    "chosen_opening": chosen_opening,
                    "step_idx": int(step_idx),
                    "total_steps": int(total_steps),
                    "command": command_name,
                    "start_at_supply": start_at_supply,
                    "start_condition_ok": start_condition_ok,
                    "end_condition_ok": end_condition_ok,
                    "current_step_started": bool(current_step_started),
                    "current_step_complete": bool(current_step_complete),
                    "stall_s_on_step": round(float(stall_s), 2),
                },
                meta={"module": "macro", "component": "build_order.runner"},
            )
