# Project tree (export)
.
├── bot
│   ├── __init__.py
│   ├── behaviors
│   │   ├── base.py
│   │   ├── combat.py
│   │   ├── drop.py
│   │   ├── macro.py
│   │   ├── main_wall.py
│   │   ├── orchestrator.py
│   │   ├── plan.py
│   │   ├── supply.py
│   │   └── wall.py
│   ├── core
│   │   ├── logger.py
│   │   ├── state.py
│   │   └── unit_manager.py
│   ├── engine
│   │   ├── builder.py
│   │   ├── economy.py
│   │   ├── expansion_finder.py
│   │   ├── locations.py
│   │   ├── placement.py
│   │   └── wall.py
│   ├── strategy
│   │   ├── loader.py
│   │   ├── plan_executor.py
│   │   └── schema.py
│   ├── strats
│   │   ├── default.json
│   │   └── future.json
│   └── terran_bot.py
└── run.py

# =====================
# Files (export)
# =====================

# ---------- bot/__init__.py ----------
#bot/__init__.py
# __init__.py
from __future__ import annotations

from sc2.data import Race

from .terran_bot import TerranBot


class CompetitiveBot(TerranBot):
    NAME = "Boi Bandido"
    RACE = Race.Terran

    # Estratégia fixa do build (não de CLI)
    STRATEGY = "default"

    def __init__(self, *, debug: bool = True):
        super().__init__(strat_name=self.STRATEGY, debug=debug)

# ---------- bot/behaviors/base.py ----------
#bot/behaviors/base.py
# behaviors/base.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Protocol


@dataclass
class TickBudget:
    remaining: int = 1

    def spend(self, n: int = 1) -> bool:
        if self.remaining < n:
            return False
        self.remaining -= n
        return True


class Behavior(Protocol):
    """Contrato único. Config NÃO fica no __init__."""
    name: str

    async def step(self, budget: TickBudget, cfg: Any) -> bool:
        """
        Retorna True se emitiu ação relevante (normalmente gasta budget).
        """
        ...

# ---------- bot/behaviors/combat.py ----------
#bot/behaviors/combat.py
from __future__ import annotations

from typing import Any

from .base import TickBudget


class CombatBehavior:
    name = "combat"

    def __init__(self, bot: Any, ctx: Any, logger: Any | None = None, debug: bool = True):
        self.bot = bot
        self.ctx = ctx
        self.log = logger
        self.debug = debug

    async def step(self, budget: TickBudget, cfg: dict) -> bool:
        combat_cfg = cfg["combat"]
        if not combat_cfg.enabled:
            return False
        # ainda vazio
        return False

# ---------- bot/behaviors/drop.py ----------
#bot/behaviors/drop.py
#bot/behaviors/drop.py
from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Optional, List, Dict

import inspect

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.ids.ability_id import AbilityId as A
from sc2.position import Point2

from .base import TickBudget


class DropPhase(str, Enum):
    WAIT = "wait"
    PREP = "prep"
    LOAD = "load"
    MOVE = "move"
    DROP = "drop"
    FIGHT = "fight"
    DONE = "done"


@dataclass
class DropRuntime:
    phase: DropPhase = DropPhase.WAIT
    pickup: Optional[Point2] = None
    staging: Optional[Point2] = None
    target: Optional[Point2] = None
    next_loop: int = 0

    medivac_tag: Optional[int] = None
    marine_tags: List[int] = field(default_factory=list)

    fight_until_time: float = 0.0

    stuck: Dict[int, tuple[float, int]] = field(default_factory=dict)

    loaded_count: int = 0
    pending_load_until_loop: Dict[int, int] = field(default_factory=dict)


class DropBehavior:
    name = "drop"

    def __init__(
        self,
        bot: Any,
        ctx: Any,
        unit_manager: Any,
        *,
        drop_id: str,
        logger: Any | None = None,
        debug: bool = True,
    ):
        self.bot = bot
        self.ctx = ctx
        self.um = unit_manager
        self.log = logger
        self.debug = debug

        self.drop_id = (str(drop_id).strip() or "drop").replace(" ", "_")
        self.owner = f"drop:{self.drop_id}"
        self.key = self.drop_id

        self.rt = DropRuntime()

    def _loop(self) -> int:
        st = getattr(self.bot, "state", None)
        gl = getattr(st, "game_loop", None)
        if gl is not None:
            return int(gl)
        it = getattr(self.ctx, "iteration", None)
        return int(it) if it is not None else 0

    def _time(self) -> float:
        t = getattr(self.bot, "time", None)
        try:
            return float(t)
        except Exception:
            return 0.0

    def _emit(self, event: str, payload: dict):
        if self.log:
            meta = {"iter": int(getattr(self.ctx, "iteration", 0)), "drop": self.owner}
            self.log.emit(event, payload, meta=meta)

    async def _do(self, cmd) -> bool:
        fn = getattr(self.bot, "do", None)
        if fn is None:
            return False
        res = fn(cmd)
        if inspect.isawaitable(res):
            await res
            return True
        if isinstance(res, bool):
            return res
        return True

    # -------- points (CENTRALIZADO) --------
    def _loc(self):
        # TerranBot.locations.loc (MapLocations)
        svc = getattr(self.bot, "locations", None)
        return getattr(svc, "loc", None) if svc is not None else None

    def _enemy_main(self) -> Optional[Point2]:
        loc = self._loc()
        p = getattr(loc, "enemy_main", None) if loc is not None else None
        if p is not None:
            return p
        # fallback: start location do inimigo
        locs = getattr(self.bot, "enemy_start_locations", None)
        return locs[0] if locs else None

    def _enemy_natural(self) -> Optional[Point2]:
        loc = self._loc()
        p = getattr(loc, "enemy_natural", None) if loc is not None else None
        return p

    def _my_main(self) -> Optional[Point2]:
        loc = self._loc()
        p = getattr(loc, "my_main", None) if loc is not None else None
        if p is not None:
            return p
        return getattr(self.bot, "start_location", None)

    def _my_natural(self) -> Optional[Point2]:
        loc = self._loc()
        p = getattr(loc, "my_natural", None) if loc is not None else None
        return p

    def _point_by_key(self, key: str) -> Optional[Point2]:
        k = str(key).strip().upper()
        if k == "ENEMY_MAIN":
            return self._enemy_main()
        if k == "ENEMY_NATURAL":
            return self._enemy_natural() or self._enemy_main()
        if k == "MY_MAIN":
            return self._my_main()
        if k == "MY_NATURAL":
            return self._my_natural() or self._my_main()
        return None

    def _resolve_points(self, drop_cfg) -> tuple[Optional[Point2], Optional[Point2], Optional[Point2]]:
        enemy_main = self._enemy_main()
        my_main = self._my_main()
        if enemy_main is None or my_main is None:
            return None, None, None

        pickup_key = str(getattr(drop_cfg, "pickup", None) or "MY_MAIN")
        staging_key = str(getattr(drop_cfg, "staging", None) or "ENEMY_NATURAL")
        target_key = str(getattr(drop_cfg, "target", None) or "ENEMY_MAIN")

        pickup = self._point_by_key(pickup_key)
        staging_anchor = self._point_by_key(staging_key)
        target = self._point_by_key(target_key)

        if pickup is None or staging_anchor is None or target is None:
            return None, None, None

        dist = float(getattr(drop_cfg, "staging_dist", 18.0))
        staging = staging_anchor.towards(my_main, dist)
        return pickup, staging, target

    # ---- alive helpers etc (resto igual) ----
    def _alive_medivac(self, tag: int):
        meds = self.bot.units(U.MEDIVAC) if hasattr(self.bot, "units") else None
        if not meds:
            return None
        return meds.find_by_tag(int(tag))

    def _alive_marine(self, tag: int):
        ms = self.bot.units(U.MARINE) if hasattr(self.bot, "units") else None
        if not ms:
            return None
        return ms.find_by_tag(int(tag))

    def _mark_stuck(self, tag: int, dist: float, *, eps: float = 0.25) -> int:
        tag = int(tag)
        d = float(dist)
        last = self.rt.stuck.get(tag)
        if last is None:
            self.rt.stuck[tag] = (d, 0)
            return 0
        last_d, cnt = last
        if d >= float(last_d) - float(eps):
            cnt += 1
        else:
            cnt = 0
        self.rt.stuck[tag] = (d, cnt)
        return cnt

    def _forget_stuck(self, tag: int) -> None:
        self.rt.stuck.pop(int(tag), None)

    def _cargo_used(self, med: Any) -> int:
        for attr in ("cargo_used", "cargo_space_used", "cargo_space_taken", "cargo_space"):
            v = getattr(med, attr, None)
            if v is None:
                continue
            try:
                iv = int(v)
                if iv >= 0:
                    return iv
            except Exception:
                pass

        p = getattr(med, "passengers", None)
        if p is not None:
            try:
                return int(len(p))
            except Exception:
                pass

        return int(self.rt.loaded_count)

    async def step(self, budget: TickBudget, cfg: dict) -> bool:
        drop_cfg = cfg["drop"]
        if not drop_cfg.enabled:
            return False

        loop = self._loop()
        if loop < self.rt.next_loop or budget.remaining <= 0:
            return False

        start_loop = getattr(drop_cfg, "start_loop", None)
        start_time = getattr(drop_cfg, "start_time", None)

        if self.rt.phase == DropPhase.WAIT:
            if start_loop is not None and loop < int(start_loop):
                self._emit("drop_wait", {"reason": "waiting_start_loop", "start_loop": int(start_loop)})
                self.rt.next_loop = loop + 12
                return False
            if start_time is not None and self._time() < float(start_time):
                self._emit("drop_wait", {"reason": "waiting_start_time", "start_time": float(start_time)})
                self.rt.next_loop = loop + 12
                return False

        if self.rt.pickup is None or self.rt.staging is None or self.rt.target is None:
            pickup, staging, target = self._resolve_points(drop_cfg)
            self.rt.pickup, self.rt.staging, self.rt.target = pickup, staging, target
            if pickup is None or staging is None or target is None:
                self._emit("drop_wait", {"reason": "no_points"})
                self.rt.next_loop = loop + 12
                return False

        load_count = int(getattr(drop_cfg, "load_count", int(getattr(drop_cfg, "min_marines", 8))))
        move_eps = float(getattr(drop_cfg, "move_eps", 3.0))
        pickup_eps = float(getattr(drop_cfg, "pickup_eps", 6.0))
        load_range = float(getattr(drop_cfg, "load_range", 7.0))

        recruit_radius = float(getattr(drop_cfg, "recruit_radius", max(load_range + 2.0, 9.0)))
        stuck_limit = int(getattr(drop_cfg, "stuck_limit", 6))

        hard_gather = False
        if start_time is not None:
            hard_gather = (self._time() >= float(start_time) - 25.0)

        marine_select_maxd = float(getattr(drop_cfg, "marine_select_maxd", 120.0))
        gather_radius = float(getattr(drop_cfg, "gather_radius", max(14.0, pickup_eps + 8.0)))

        if self.rt.phase == DropPhase.WAIT:
            self._emit("drop_armed", {"load_count": int(load_count)})
            self.rt.phase = DropPhase.PREP
            self.rt.next_loop = loop + 1
            return False

        if self.rt.phase == DropPhase.PREP:
            group = await self.um.request_group(
                owner=self.owner,
                pickup=self.rt.pickup,
                requirements={U.MEDIVAC: 1, U.MARINE: int(load_count)},
                soft_gather=True,
                hard_gather=hard_gather,
                gather_radius=gather_radius,
                max_distance_by_type={U.MARINE: marine_select_maxd},
            )

            if not group.ready:
                self._emit("drop_prep", {"ready": False})
                self.rt.next_loop = loop + 10
                return False

            med_tags = group.assigned.get(U.MEDIVAC, [])
            mar_tags = group.assigned.get(U.MARINE, [])
            if not med_tags or len(mar_tags) < load_count:
                self._emit("drop_prep", {"ready": False, "reason": "incomplete"})
                self.rt.next_loop = loop + 10
                return False

            med = self._alive_medivac(int(med_tags[0]))
            if med is None:
                self._emit("drop_prep", {"ready": False, "reason": "medivac_missing"})
                self.um.release_owner(self.owner)
                self.rt.next_loop = loop + 10
                return False

            self.rt.medivac_tag = int(med.tag)
            self.rt.marine_tags = [int(x) for x in mar_tags]
            self.rt.stuck.clear()
            self.rt.loaded_count = 0
            self.rt.pending_load_until_loop.clear()

            if float(med.distance_to(self.rt.pickup)) > float(pickup_eps):
                ok = await self._do(med.move(self.rt.pickup))
                if ok:
                    budget.remaining -= 1
                    self._emit("drop_pickup_move", {"medivac_tag": int(med.tag)})
                    self.rt.next_loop = loop + 8
                    return True
                self.rt.next_loop = loop + 8
                return False

            self._emit("drop_ready_to_load", {"medivac_tag": int(med.tag), "marines": int(len(self.rt.marine_tags))})
            self.rt.phase = DropPhase.LOAD
            self.rt.next_loop = loop + 1
            return False

        if self.rt.phase == DropPhase.LOAD:
            med = self._alive_medivac(int(self.rt.medivac_tag or -1))
            if med is None:
                self._emit("drop_abort", {"reason": "medivac_dead"})
                self.um.release_owner(self.owner)
                self.rt.phase = DropPhase.DONE
                return False

            if float(med.distance_to(self.rt.pickup)) > float(pickup_eps):
                ok = await self._do(med.move(self.rt.pickup))
                if ok:
                    budget.remaining -= 1
                    self._emit("drop_loading_reposition", {})
                    self.rt.next_loop = loop + 8
                    return True
                self.rt.next_loop = loop + 8
                return False

            # (A) se o fork não expõe cargo, atualiza loaded_count pelo "sumiço" pós-load
            # marina some logo após LOAD -> considera carregado, não como morto
            for t in list(self.rt.marine_tags):
                if self._alive_marine(int(t)) is None:
                    deadline = int(self.rt.pending_load_until_loop.get(int(t), -1))
                    if deadline >= loop:
                        self.rt.loaded_count += 1
                        self.rt.marine_tags = [x for x in self.rt.marine_tags if int(x) != int(t)]
                        self.rt.pending_load_until_loop.pop(int(t), None)
                        try:
                            self.um.release_tags(self.owner, [int(t)])
                        except Exception:
                            pass

            cargo_used = self._cargo_used(med)
            if cargo_used >= load_count:
                self._emit("drop_loaded", {"cargo_used": int(cargo_used)})
                self.rt.phase = DropPhase.MOVE
                self.rt.next_loop = loop + 1
                return False

            needed = int(load_count - cargo_used)
            if needed > 0:
                newly = self.um.claim_nearby(
                    owner=self.owner,
                    unit_type=U.MARINE,
                    near=med.position,
                    radius=float(recruit_radius),
                    limit=int(needed),
                )
                if newly:
                    for t in newly:
                        if int(t) not in self.rt.marine_tags:
                            self.rt.marine_tags.append(int(t))
                    self._emit("drop_recruit", {"claimed": [int(x) for x in newly], "needed": int(needed)})

            # limpa mortos de verdade (sem pending load)
            alive_tags: List[int] = []
            for t in list(self.rt.marine_tags):
                m = self._alive_marine(int(t))
                if not m:
                    if int(self.rt.pending_load_until_loop.get(int(t), -1)) >= loop:
                        alive_tags.append(int(t))
                        continue
                    try:
                        self.um.release_tags(self.owner, [int(t)])
                    except Exception:
                        pass
                    self._forget_stuck(int(t))
                    continue
                alive_tags.append(int(t))
            self.rt.marine_tags = alive_tags

            if not self.rt.marine_tags:
                self._emit("drop_loading", {"reason": "no_reserved_alive"})
                self.um.release_owner(self.owner)
                self.rt.phase = DropPhase.DONE
                return False

            # tenta carregar alguém já no range
            in_range: List[tuple[float, Any]] = []
            for t in self.rt.marine_tags:
                m = self._alive_marine(int(t))
                if not m:
                    continue
                d = float(m.distance_to(med))
                if d <= float(load_range):
                    in_range.append((d, m))
            in_range.sort(key=lambda x: x[0])

            if in_range:
                _, m = in_range[0]
                ok = await self._do(med(A.LOAD, m))
                if ok:
                    budget.remaining -= 1
                    # marca janela onde "sumir" = loaded
                    self.rt.pending_load_until_loop[int(m.tag)] = loop + 20
                self._emit("drop_loading", {"marine": int(m.tag), "ok": bool(ok), "mode": "in_range"})
                self.rt.next_loop = loop + 4
                return bool(ok)

            # ninguém no range -> chama o mais próximo (anti-stuck)
            best = None
            best_d = 1e18
            for t in self.rt.marine_tags:
                m = self._alive_marine(int(t))
                if not m:
                    continue
                d = float(m.distance_to(med))
                if d < best_d:
                    best = m
                    best_d = d

            if best is None:
                self._emit("drop_loading", {"reason": "no_alive_after_scan"})
                self.um.release_owner(self.owner)
                self.rt.phase = DropPhase.DONE
                return False

            stuck_cnt = self._mark_stuck(int(best.tag), float(best_d))
            if stuck_cnt >= stuck_limit:
                self._emit("drop_marine_stuck", {"marine": int(best.tag), "dist": float(best_d), "stuck_cnt": int(stuck_cnt)})
                try:
                    self.um.release_tags(self.owner, [int(best.tag)])
                except Exception:
                    pass
                self.rt.marine_tags = [t for t in self.rt.marine_tags if int(t) != int(best.tag)]
                self._forget_stuck(int(best.tag))
                self.rt.next_loop = loop + 2
                return False

            ok = await self._do(best.move(med.position))
            if ok:
                budget.remaining -= 1
                self._emit("drop_call_marine", {"marine": int(best.tag), "dist": float(best_d), "to": "medivac_pos"})
                self.rt.next_loop = loop + 6
                return True

            self.rt.next_loop = loop + 6
            return False

        if self.rt.phase == DropPhase.MOVE:
            med = self._alive_medivac(int(self.rt.medivac_tag or -1))
            if med is None:
                self._emit("drop_abort", {"reason": "medivac_dead_move"})
                self.um.release_owner(self.owner)
                self.rt.phase = DropPhase.DONE
                return False

            if float(med.distance_to(self.rt.staging)) <= float(move_eps):
                self._emit("drop_at_staging", {})
                self.rt.phase = DropPhase.DROP
                self.rt.next_loop = loop + 1
                return False

            ok = await self._do(med.move(self.rt.staging))
            if ok:
                budget.remaining -= 1
                self._emit("drop_move", {})
                self.rt.next_loop = loop + 8
                return True
            self.rt.next_loop = loop + 8
            return False

        if self.rt.phase == DropPhase.DROP:
            med = self._alive_medivac(int(self.rt.medivac_tag or -1))
            if med is None:
                self._emit("drop_abort", {"reason": "medivac_dead_drop"})
                self.um.release_owner(self.owner)
                self.rt.phase = DropPhase.DONE
                return False

            if float(med.distance_to(self.rt.target)) > float(move_eps) * 2:
                ok = await self._do(med.move(self.rt.target))
                if ok:
                    budget.remaining -= 1
                    self._emit("drop_approach", {})
                    self.rt.next_loop = loop + 8
                    return True
                self.rt.next_loop = loop + 8
                return False

            ok = await self._do(med(A.UNLOADALLAT, self.rt.target))
            if ok:
                budget.remaining -= 1
                self._emit("drop_unload", {"target": [float(self.rt.target.x), float(self.rt.target.y)]})

                if self.rt.medivac_tag is not None:
                    self.um.release_tags(self.owner, [int(self.rt.medivac_tag)])

                self.rt.fight_until_time = float(self._time()) + 18.0
                self.rt.phase = DropPhase.FIGHT
                self.rt.next_loop = loop + 2
                return True

            self.rt.next_loop = loop + 6
            return False

        if self.rt.phase == DropPhase.FIGHT:
            issued = 0
            for t in list(self.rt.marine_tags):
                if budget.remaining <= 0:
                    break
                m = self._alive_marine(int(t))
                if not m:
                    continue
                if bool(getattr(m, "is_idle", True)) and float(m.distance_to(self.rt.target)) < 20.0:
                    ok = await self._do(m.attack(self.rt.target))
                    if ok:
                        budget.remaining -= 1
                        issued += 1

            if issued > 0:
                self._emit("drop_attack", {"issued": int(issued)})
                self.rt.next_loop = loop + 8
                return True

            if float(self._time()) >= float(self.rt.fight_until_time):
                self._emit("drop_fight_done", {})
                self.um.release_owner(self.owner)
                self.rt.phase = DropPhase.DONE
                return False

            self.rt.next_loop = loop + 10
            return False

        return False

# ---------- bot/behaviors/macro.py ----------
#bot/behaviors/macro.py
# behaviors/macro.py
from __future__ import annotations

from typing import Any

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.strategy.schema import EconomyCfg, MacroBehaviorCfg
from .base import TickBudget


class MacroBehavior:
    name = "macro"

    def __init__(
        self,
        bot: Any,
        econ: Any,
        builder: Any,
        ctx: Any,
        logger: Any | None = None,
        debug: bool = True,
    ):
        self.bot = bot
        self.econ = econ
        self.builder = builder
        self.ctx = ctx
        self.log = logger
        self.debug = debug
        self._supply_cooldown_until_iter = 0

    async def step(self, budget: TickBudget, cfg: dict) -> bool:
        """
        cfg esperado:
          { "econ": EconomyCfg, "macro": MacroBehaviorCfg }
        """
        econ_cfg: EconomyCfg = cfg["econ"]
        macro_cfg: MacroBehaviorCfg = cfg["macro"]

        if not macro_cfg.enabled:
            return False

        did_any = False

        if macro_cfg.auto_workers:
            await self.econ.step()

        if macro_cfg.auto_scv:
            await self.econ.train_scv(int(econ_cfg.scv_target))

        if macro_cfg.auto_supply and budget.remaining > 0:
            if await self._auto_supply(int(econ_cfg.depot_trigger_supply_left)):
                # supply é “ação” -> consome budget
                budget.spend(1)
                did_any = True

        return did_any

    async def _auto_supply(self, trigger: int) -> bool:
        bot = self.bot
        it = int(getattr(self.ctx, "iteration", 0))
        if it < self._supply_cooldown_until_iter:
            return False

        if bot.supply_left > trigger:
            return False

        if self.builder.pending(U.SUPPLYDEPOT) > 0:
            return False

        did = await self.builder.try_build(U.SUPPLYDEPOT)

        if self.log:
            self.log.emit(
                "macro_supply",
                {"did": bool(did), "supply_left": int(bot.supply_left), "trigger": int(trigger)},
                meta={"iter": it},
            )

        self._supply_cooldown_until_iter = it + 22
        return bool(did)

# ---------- bot/behaviors/main_wall.py ----------
#bot/behaviors/main_wall.py
#bot/behaviors/main_wall.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any

from sc2.ids.unit_typeid import UnitTypeId as U

from .base import TickBudget


@dataclass
class MainWallRuntime:
    complete: bool = False
    next_loop: int = 0


class MainWallOpenerBehavior:
    """
    Só serve quando você quer OVERRIDE (rush/force):
      - force 2 depots + 1 barracks ASAP, nos spots da MAIN wall.
    Se force=False, esse Behavior nem deve rodar (ver TerranBot._active_pairs).
    """

    name = "main_wall"

    def __init__(
        self,
        bot: Any,
        ctx: Any,
        builder: Any,
        placement: Any,
        *,
        logger: Any | None = None,
        debug: bool = True,
    ):
        self.bot = bot
        self.ctx = ctx
        self.builder = builder
        self.place = placement
        self.log = logger
        self.debug = debug
        self.rt = MainWallRuntime()

        # fase interna para não repetir build enquanto está pending/invisível
        self.ctx.owner_meta.setdefault("main_wall_force", {"phase": 0})

    def _iter(self) -> int:
        return int(getattr(self.ctx, "iteration", 0))

    def _loop(self) -> int:
        st = getattr(self.bot, "state", None)
        gl = getattr(st, "game_loop", None)
        if gl is not None:
            return int(gl)
        return self._iter()

    def _emit(self, event: str, payload: dict):
        if self.log:
            self.log.emit(event, payload, meta={"iter": self._iter()})

    def _phase(self) -> int:
        return int(self.ctx.owner_meta.get("main_wall_force", {}).get("phase", 0))

    def _set_phase(self, p: int) -> None:
        self.ctx.owner_meta.setdefault("main_wall_force", {})
        self.ctx.owner_meta["main_wall_force"]["phase"] = int(p)

    async def step(self, budget: TickBudget, cfg: dict) -> bool:
        loop = self._loop()
        if loop < int(self.rt.next_loop):
            return False
        if budget.remaining <= 0:
            self.rt.next_loop = loop + 8
            return False
        if self.rt.complete:
            return False

        phase = self._phase()

        # 0 -> build depot 1
        # 1 -> build depot 2
        # 2 -> build barracks 1
        # 3 -> done
        did = False
        if phase == 0:
            did = await self.builder.try_build(U.SUPPLYDEPOT, wall_pref="MAIN")
            self._emit("main_wall_force", {"phase": 0, "want": "DEPOT#1", "did": bool(did)})
            if did:
                self._set_phase(1)
        elif phase == 1:
            did = await self.builder.try_build(U.SUPPLYDEPOT, wall_pref="MAIN")
            self._emit("main_wall_force", {"phase": 1, "want": "DEPOT#2", "did": bool(did)})
            if did:
                self._set_phase(2)
        elif phase == 2:
            did = await self.builder.try_build(U.BARRACKS, wall_pref="MAIN")
            self._emit("main_wall_force", {"phase": 2, "want": "BARRACKS#1", "did": bool(did)})
            if did:
                self._set_phase(3)
        else:
            self.rt.complete = True
            self._emit("main_wall_force_complete", {"complete": True})
            return False

        if did:
            budget.spend(1)
            self.rt.next_loop = loop + 6
            return True

        self.rt.next_loop = loop + 10
        return False

# ---------- bot/behaviors/orchestrator.py ----------
#bot/behaviors/orchestrator.py
#bot/behaviors/orchestrator.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Iterable, List, Tuple, Optional

from .base import TickBudget


@dataclass
class ActiveBehavior:
    behavior: Any
    cfg: dict
    key: str  # id estável por behavior


class BehaviorOrchestrator:
    """
    Round-robin estável entre ticks.
    Agora usa uma chave estável se o behavior expõe .key (ex.: drops).
    """

    def __init__(self):
        self.active: List[ActiveBehavior] = []
        self._rr_index: int = 0
        self._last_keys: List[str] = []

    def _mk_key(self, behavior: Any) -> str:
        name = getattr(behavior, "name", behavior.__class__.__name__)
        stable = getattr(behavior, "key", None)
        if stable is not None:
            return f"{name}:{stable}"
        return f"{name}:{id(behavior)}"

    def set_active(self, pairs: Iterable[Tuple[Any, dict]]) -> None:
        new_active: List[ActiveBehavior] = []
        new_keys: List[str] = []

        for b, cfg in pairs:
            k = self._mk_key(b)
            new_active.append(ActiveBehavior(behavior=b, cfg=cfg, key=k))
            new_keys.append(k)

        if self._last_keys and new_keys and new_keys != self._last_keys:
            old_next_key: Optional[str] = None
            if 0 <= self._rr_index < len(self._last_keys):
                old_next_key = self._last_keys[self._rr_index]
            if old_next_key in new_keys:
                self._rr_index = new_keys.index(old_next_key)
            else:
                self._rr_index = 0

        self.active = new_active
        self._last_keys = new_keys

        if self._rr_index >= len(self.active):
            self._rr_index = 0

    async def step(self, *, budget_actions: int = 1) -> None:
        if not self.active:
            return

        budget = TickBudget(remaining=int(budget_actions))
        n = len(self.active)
        start = self._rr_index % n

        for i in range(n):
            if budget.remaining <= 0:
                break

            idx = (start + i) % n
            ab = self.active[idx]

            did = await ab.behavior.step(budget, ab.cfg)

            if did:
                self._rr_index = (idx + 1) % n

# ---------- bot/behaviors/plan.py ----------
#bot/behaviors/plan.py
# bot/behaviors/plan.py
from __future__ import annotations

from typing import Any

from .base import TickBudget


class PlanBehavior:
    name = "plan"

    def __init__(self, plan_executor: Any):
        self.plan = plan_executor

    async def step(self, budget: TickBudget, cfg: dict) -> bool:
        # o PlanExecutor já tem sua própria política de 1 ação por tick (do jeito que você escreveu)
        # então aqui, se não tem budget, nem roda.
        if budget.remaining <= 0:
            return False

        before = getattr(self.plan.builder, "last", None)
        await self.plan.step()

        # se o plan executou algo “relevante”, ele terá action_ok no logger,
        # mas pra consumir budget sem depender de log, usa heuristic simples:
        after = getattr(self.plan.builder, "last", None)
        did = bool(after is not None and after is not before and getattr(after, "reason", "") == "ok")

        if did:
            budget.spend(1)
        return did

# ---------- bot/behaviors/supply.py ----------
#bot/behaviors/supply.py
# behaviors/supply.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any

from sc2.ids.unit_typeid import UnitTypeId as U

from .base import Behavior, TickBudget


@dataclass
class SupplyCfg:
    enabled: bool = True
    trigger_supply_left: int = 2


class SupplyBehavior(Behavior):
    name = "supply"

    def __init__(self, bot: Any, builder: Any, cfg: SupplyCfg, ctx: Any, logger: Any | None = None, debug: bool = True):
        super().__init__(bot, ctx, logger=logger, debug=debug)
        self.builder = builder
        self.cfg = cfg

    async def step(self, budget: TickBudget) -> bool:
        if not self.cfg.enabled:
            return False

        if self.bot.supply_left > int(self.cfg.trigger_supply_left):
            return False

        # não gasta budget se não vai tentar
        if self.builder.pending(U.SUPPLYDEPOT) > 0:
            return False

        if not budget.spend(1):
            return False

        did = await self.builder.try_build(U.SUPPLYDEPOT)
        if self.log:
            self.log.emit(
                "behavior_supply",
                {"attempt": True, "did": bool(did), "supply_left": int(self.bot.supply_left)},
                meta={"iter": int(self.ctx.iteration)},
            )
        return bool(did)

# ---------- bot/behaviors/wall.py ----------
#bot/behaviors/wall.py
#bot/behaviors/wall.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Optional, List, Tuple

import inspect

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.ids.ability_id import AbilityId as A
from sc2.position import Point2

from .base import TickBudget


@dataclass
class WallRuntime:
    complete: bool = False
    last_open: Optional[bool] = None
    next_loop: int = 0


class WallBehavior:
    """
    Controla o "portão" (SupplyDepots) da wall:
    - OPEN por padrão (SCV desce).
    - CLOSE se inimigo terrestre perto da rampa.
    - Marca wall como 'complete' quando as peças principais estiverem prontas.
    """

    name = "wall"

    def __init__(self, bot: Any, ctx: Any, placement: Any, *, logger: Any | None = None, debug: bool = True):
        self.bot = bot
        self.ctx = ctx
        self.place = placement
        self.log = logger
        self.debug = debug
        self.rt = WallRuntime()

        # chave de meta
        self.meta_key = "wall:natural"

    def _loop(self) -> int:
        st = getattr(self.bot, "state", None)
        gl = getattr(st, "game_loop", None)
        if gl is not None:
            return int(gl)
        it = getattr(self.ctx, "iteration", None)
        return int(it) if it is not None else 0

    def _iter(self) -> int:
        return int(getattr(self.ctx, "iteration", 0))

    def _emit(self, event: str, payload: dict):
        if self.log:
            self.log.emit(event, payload, meta={"iter": self._iter()})

    async def _do(self, cmd) -> bool:
        fn = getattr(self.bot, "do", None)
        if fn is None:
            return False
        res = fn(cmd)
        if inspect.isawaitable(res):
            await res
            return True
        if isinstance(res, bool):
            return res
        return True

    # -------------------
    # helpers de matching
    # -------------------
    def _wall_planner(self):
        # Placement.wall = WallPlanner(...)
        return getattr(self.place, "wall", None)

    def _get_wall_spots(self) -> tuple[Optional[Point2], List[Point2]]:
        wp = self._wall_planner()
        if wp is None:
            return None, []

        anchor = wp.wall_anchor()
        depots = wp.wall_spots_for(U.SUPPLYDEPOT)
        depots = [p for p in depots if p is not None]
        return anchor, depots[:2]

    def _find_my_depot_near(self, pos: Point2, *, max_d: float = 1.0):
        if not hasattr(self.bot, "units"):
            return None
        depots = self.bot.units(U.SUPPLYDEPOT)
        if not depots:
            return None
        best = None
        best_d = 1e18
        for d in depots.ready:
            dist = float(d.distance_to(pos))
            if dist < best_d:
                best = d
                best_d = dist
        if best is not None and best_d <= float(max_d):
            return best
        return None

    def _depot_is_lowered(self, depot: Any) -> bool:
        # python-sc2 costuma expor is_lowered; se não tiver, assume False (conservador)
        v = getattr(depot, "is_lowered", None)
        if v is None:
            return False
        try:
            return bool(v)
        except Exception:
            return False

    def _friendly_blocking_door(self, depot_positions: List[Point2], *, radius: float = 2.25) -> bool:
        # se tiver unidade amiga (terra) muito em cima do choke, não levanta
        if not hasattr(self.bot, "units"):
            return False
        all_my = getattr(self.bot, "units", None)
        if all_my is None:
            return False

        # pega tudo que é meu e terrestre (inclui worker/marine etc.)
        # (sem estruturas)
        try:
            mine = [u for u in self.bot.units if getattr(u, "is_mine", True)]
        except Exception:
            mine = []

        if not mine:
            # fallback: tenta bot.units.filter?
            mine = []

        r = float(radius)
        for p in depot_positions:
            for u in mine:
                if getattr(u, "is_structure", False):
                    continue
                if getattr(u, "is_flying", False):
                    continue
                try:
                    if float(u.distance_to(p)) <= r:
                        return True
                except Exception:
                    continue
        return False

    def _enemy_ground_threat_near(self, anchor: Point2, *, radius: float = 18.0) -> bool:
        enemies = getattr(self.bot, "enemy_units", None)
        if enemies is None:
            return False
        r = float(radius)

        # ameaça = unidades inimigas terrestres (structures não contam)
        try:
            for e in enemies:
                if getattr(e, "is_structure", False):
                    continue
                if getattr(e, "is_flying", False):
                    continue
                if float(e.distance_to(anchor)) <= r:
                    return True
        except Exception:
            return False
        return False

    def _set_wall_meta(self, *, complete: bool | None = None, open_now: bool | None = None) -> None:
        self.ctx.owner_meta.setdefault(self.meta_key, {})
        if complete is not None:
            self.ctx.owner_meta[self.meta_key]["complete"] = bool(complete)
        if open_now is not None:
            self.ctx.owner_meta[self.meta_key]["open"] = bool(open_now)

    # -------------------
    # main
    # -------------------
    async def step(self, budget: TickBudget, cfg: dict) -> bool:
        # throttling simples pra não gastar tick
        loop = self._loop()
        if loop < int(self.rt.next_loop):
            return False

        anchor, depot_spots = self._get_wall_spots()
        if anchor is None or len(depot_spots) < 2:
            self.rt.next_loop = loop + 22
            return False

        d1 = self._find_my_depot_near(depot_spots[0])
        d2 = self._find_my_depot_near(depot_spots[1])
        have_two = bool(d1 is not None and d2 is not None)

        # completa quando os 2 depots existem e estão prontos (barracks pode variar por mapa/fork)
        complete_now = have_two and getattr(d1, "is_ready", True) and getattr(d2, "is_ready", True)
        if complete_now and not self.rt.complete:
            self.rt.complete = True
            self._set_wall_meta(complete=True)
            self._emit(
                "wall_complete",
                {
                    "depots": [
                        int(getattr(d1, "tag", 0)),
                        int(getattr(d2, "tag", 0)),
                    ],
                    "spots": [
                        [float(depot_spots[0].x), float(depot_spots[0].y)],
                        [float(depot_spots[1].x), float(depot_spots[1].y)],
                    ],
                },
            )

        # Decide OPEN/CLOSE
        threat = self._enemy_ground_threat_near(anchor, radius=float(getattr(cfg, "threat_radius", 18.0)))
        want_open = not threat  # padrão: aberto
        want_close = not want_open

        # não fecha se tem aliado na porta
        if want_close and self._friendly_blocking_door(depot_spots, radius=float(getattr(cfg, "door_clear_radius", 2.25))):
            want_close = False
            want_open = True

        # Sem budget, sem ação
        if budget.remaining <= 0:
            self.rt.next_loop = loop + 8
            return False

        issued = False
        for dep in [d1, d2]:
            if dep is None:
                continue

            lowered = self._depot_is_lowered(dep)

            # se quer OPEN -> depot tem que estar lowered
            if want_open and not lowered:
                ok = await self._do(dep(A.MORPH_SUPPLYDEPOT_LOWER))
                if ok:
                    budget.spend(1)
                    issued = True

            # se quer CLOSE -> depot tem que estar raised (not lowered)
            if want_close and lowered:
                ok = await self._do(dep(A.MORPH_SUPPLYDEPOT_RAISE))
                if ok:
                    budget.spend(1)
                    issued = True

            if budget.remaining <= 0:
                break

        if issued:
            self.rt.last_open = bool(want_open)
            self._set_wall_meta(open_now=bool(want_open))
            self._emit(
                "wall_gate",
                {
                    "open": bool(want_open),
                    "threat": bool(threat),
                    "anchor": [float(anchor.x), float(anchor.y)],
                },
            )
            self.rt.next_loop = loop + 6
            return True

        self.rt.next_loop = loop + 12
        return False

# ---------- bot/core/logger.py ----------
#bot/core/logger.py
from __future__ import annotations

import json
import os
from dataclasses import asdict, is_dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, Optional


def _json_default(o: Any):
    # dataclass -> dict
    if is_dataclass(o):
        return asdict(o)
    # objetos comuns do python-sc2 que têm .name
    name = getattr(o, "name", None)
    if isinstance(name, str):
        return name
    # fallback
    return str(o)


class JsonlLogger:
    """
    Escreve eventos em JSON Lines (1 JSON por linha).
    - Não trava o bot: I/O mínimo, append.
    - Você pode abrir o arquivo enquanto o jogo roda.
    """

    def __init__(self, *, log_dir: str = "logs", filename: Optional[str] = None, enabled: bool = True):
        self.enabled = enabled
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(parents=True, exist_ok=True)

        if filename is None:
            ts = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
            filename = f"game_{ts}.jsonl"

        self.path = self.log_dir / filename
        self._fp = open(self.path, "a", encoding="utf-8")

    def close(self):
        try:
            self._fp.close()
        except Exception:
            pass

    def emit(self, event: str, payload: Dict[str, Any] | None = None, *, meta: Dict[str, Any] | None = None):
        if not self.enabled:
            return
        rec = {
            "ts_utc": datetime.now(timezone.utc).isoformat(),
            "event": event,
            "payload": payload or {},
            "meta": meta or {},
        }
        self._fp.write(json.dumps(rec, ensure_ascii=False, default=_json_default) + "\n")
        self._fp.flush()

# ---------- bot/core/state.py ----------
#bot/core/state.py
# bot/core/state.py
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, Optional, Set


@dataclass
class BotState:
    iteration: int = 0

    # ---- unit management / reservations ----
    # unit_tag -> owner string (ex: "drop:drop_main")
    unit_owner: Dict[int, str] = field(default_factory=dict)

    # owner -> set of unit tags reserved
    owner_units: Dict[str, Set[int]] = field(default_factory=dict)

    # simple per-owner metadata (cooldowns, timestamps, etc.)
    owner_meta: Dict[str, dict] = field(default_factory=dict)

    def claim(self, owner: str, tag: int) -> None:
        tag = int(tag)
        self.unit_owner[tag] = owner
        self.owner_units.setdefault(owner, set()).add(tag)

    def release(self, tag: int) -> None:
        tag = int(tag)
        owner = self.unit_owner.pop(tag, None)
        if owner is None:
            return
        s = self.owner_units.get(owner)
        if s:
            s.discard(tag)

    def release_owner(self, owner: str) -> None:
        tags = list(self.owner_units.get(owner, set()))
        for t in tags:
            self.unit_owner.pop(int(t), None)
        self.owner_units[owner] = set()
        self.owner_meta.pop(owner, None)

    def owner_of(self, tag: int) -> Optional[str]:
        return self.unit_owner.get(int(tag))

# ---------- bot/core/unit_manager.py ----------
#bot/core/unit_manager.py
#bot/core/unit_manager.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Iterable, List, Optional

import inspect

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2

from bot.core.state import BotState


@dataclass
class UnitGroup:
    owner: str
    pickup: Point2
    requirements: Dict[U, int]
    assigned: Dict[U, List[int]]  # unit tags
    ready: bool = False


class UnitManager:
    """
    Responsável por:
    - reservar unidades (claims) para um "owner" (ex: drop:drop_main)
    - montar grupos (UnitGroup) com seleção consistente
    - stage/gather: mover unidades para pickup antes do task executar
    """

    def __init__(self, bot: Any, ctx: BotState, logger: Any | None = None, debug: bool = True):
        self.bot = bot
        self.ctx = ctx
        self.log = logger
        self.debug = debug
        self._iter: int = -1

    async def _do(self, cmd) -> bool:
        fn = getattr(self.bot, "do", None)
        if fn is None:
            return False
        res = fn(cmd)
        if inspect.isawaitable(res):
            await res
            return True
        if isinstance(res, bool):
            return res
        return True

    def _emit(self, event: str, payload: dict):
        if self.log:
            self.log.emit(event, payload, meta={"iter": int(getattr(self.ctx, "iteration", 0))})

    def begin_tick(self, iteration: int) -> None:
        self._iter = int(iteration)

    def _alive_unit_by_tag(self, unit_type: U, tag: int):
        units = self.bot.units(unit_type) if hasattr(self.bot, "units") else None
        if not units:
            return None
        return units.find_by_tag(int(tag))

    def _free_units(self, unit_type: U) -> List[Any]:
        units = self.bot.units(unit_type) if hasattr(self.bot, "units") else None
        if not units:
            return []
        ready = units.ready if hasattr(units, "ready") else units
        out = []
        for u in ready:
            if self.ctx.owner_of(int(u.tag)) is None:
                out.append(u)
        return out

    def _reserved_units(self, owner: str, unit_type: U) -> List[Any]:
        tags = self.ctx.owner_units.get(owner, set())
        if not tags:
            return []
        units = self.bot.units(unit_type) if hasattr(self.bot, "units") else None
        if not units:
            return []
        out = []
        for t in tags:
            u = units.find_by_tag(int(t))
            if u:
                out.append(u)
        return out

    def _ensure_owner_set(self, owner: str) -> None:
        self.ctx.owner_units.setdefault(owner, set())
        self.ctx.owner_meta.setdefault(owner, {})

    def claim_nearby(
        self,
        *,
        owner: str,
        unit_type: U,
        near: Point2,
        radius: float,
        limit: int,
    ) -> List[int]:
        """
        Claim pragmático: pega unidades LIVRES (sem owner) próximas de um ponto.
        Útil quando o drop está com marines reservados longe, mas tem marines “sobrando”
        ao redor do medivac e você quer completar a carga sem travar.
        """
        self._ensure_owner_set(owner)
        limit = int(limit)
        if limit <= 0:
            return []

        free = self._free_units(unit_type)
        if not free:
            return []

        r = float(radius)
        cand = [u for u in free if float(u.distance_to(near)) <= r]
        cand.sort(key=lambda u: u.distance_to(near))

        claimed: List[int] = []
        for u in cand:
            if len(claimed) >= limit:
                break
            tag = int(u.tag)
            # ainda livre?
            if self.ctx.owner_of(tag) is not None:
                continue
            self.ctx.claim(owner, tag)
            claimed.append(tag)

        if claimed:
            self._emit(
                "unitmgr_claim_nearby",
                {
                    "owner": owner,
                    "type": unit_type.name,
                    "near": [float(near.x), float(near.y)],
                    "radius": float(radius),
                    "claimed": [int(x) for x in claimed],
                },
            )

        return claimed

    async def request_group(
        self,
        *,
        owner: str,
        pickup: Point2,
        requirements: Dict[U, int],
        soft_gather: bool = True,
        hard_gather: bool = False,
        gather_radius: float = 10.0,
        max_distance_by_type: Dict[U, float] | None = None,
    ) -> UnitGroup:
        """
        - Reserva unidades livres para cumprir requirements.
        - Mantém reservas estáveis entre ticks.
        - Emite movimentos para pickup (gather).
        - max_distance_by_type: impede "roubo" de unidades muito longe do pickup.
        """
        self._ensure_owner_set(owner)
        max_distance_by_type = max_distance_by_type or {}

        assigned: Dict[U, List[int]] = {}
        all_ok = True

        for ut, need in requirements.items():
            need = int(need)

            # 1) mantém reservas atuais vivas
            reserved = self._reserved_units(owner, ut)
            reserved_tags = [int(u.tag) for u in reserved]
            kept = reserved_tags[:need]

            # libera excedente antigo
            for t in reserved_tags[need:]:
                if self.ctx.owner_of(t) == owner:
                    self.ctx.release(t)

            # 2) completa com unidades livres
            have = len(kept)
            if have < need:
                free = self._free_units(ut)

                maxd = float(max_distance_by_type.get(ut, 0.0) or 0.0)
                if maxd > 0.0:
                    free = [u for u in free if float(u.distance_to(pickup)) <= maxd]

                free.sort(key=lambda x: x.distance_to(pickup))

                for u in free:
                    if have >= need:
                        break
                    tag = int(u.tag)
                    self.ctx.claim(owner, tag)
                    kept.append(tag)
                    have += 1

            if len(kept) < need:
                all_ok = False

            assigned[ut] = kept

        group = UnitGroup(owner=owner, pickup=pickup, requirements=requirements, assigned=assigned, ready=all_ok)

        await self._gather_group(group, soft=soft_gather, hard=hard_gather, radius=gather_radius)

        self._emit(
            "unitmgr_group",
            {
                "owner": owner,
                "ready": bool(group.ready),
                "requirements": {k.name: int(v) for k, v in requirements.items()},
                "assigned": {k.name: [int(x) for x in v] for k, v in assigned.items()},
                "pickup": [float(pickup.x), float(pickup.y)],
                "soft_gather": bool(soft_gather),
                "hard_gather": bool(hard_gather),
            },
        )
        return group

    async def _gather_group(self, group: UnitGroup, *, soft: bool, hard: bool, radius: float) -> None:
        pickup = group.pickup

        for ut, tags in group.assigned.items():
            for t in tags:
                u = self._alive_unit_by_tag(ut, t)
                if not u:
                    if self.ctx.owner_of(int(t)) == group.owner:
                        self.ctx.release(int(t))
                    continue

                d = float(u.distance_to(pickup))
                if d <= float(radius):
                    continue

                in_combat = False
                if hasattr(u, "weapon_cooldown"):
                    try:
                        if float(getattr(u, "weapon_cooldown", 0.0)) > 0.0:
                            in_combat = True
                    except Exception:
                        pass
                if hasattr(u, "is_attacking"):
                    try:
                        if bool(getattr(u, "is_attacking", False)):
                            in_combat = True
                    except Exception:
                        pass

                if in_combat:
                    continue

                orders = getattr(u, "orders", None)
                has_orders = bool(orders) if orders is not None else False
                is_idle = bool(getattr(u, "is_idle", False))

                if soft and (is_idle or not has_orders):
                    await self._do(u.move(pickup))
                    continue

                if hard:
                    await self._do(u.move(pickup))
                    continue

    def release_owner(self, owner: str) -> None:
        self.ctx.release_owner(owner)
        self._emit("unitmgr_release_owner", {"owner": owner})

    def release_tags(self, owner: str, tags: Iterable[int]) -> None:
        for t in tags:
            if self.ctx.owner_of(int(t)) == owner:
                self.ctx.release(int(t))
        self._emit("unitmgr_release_tags", {"owner": owner, "tags": [int(x) for x in tags]})

# ---------- bot/engine/builder.py ----------
#bot/engine/builder.py
#bot/engine/builder.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Iterable
import inspect

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.ids.ability_id import AbilityId as A
from sc2.ids.upgrade_id import UpgradeId as Up


@dataclass
class LastAction:
    ok: bool
    kind: str
    unit: str
    reason: str
    details: Any | None = None


class Builder:
    def __init__(self, bot, economy, placement, state, logger=None):
        self.bot = bot
        self.economy = economy
        self.placement = placement
        self.state = state
        self.log = logger
        self.last: LastAction | None = None

    # ----------------------------
    # robust unit access
    # ----------------------------
    def _iter_owned(self) -> Iterable[Any]:
        st = getattr(self.bot, "state", None)
        if st is not None and hasattr(st, "units"):
            return st.units
        if hasattr(self.bot, "all_units"):
            return self.bot.all_units
        return self.bot.units

    def _iter_all_units(self) -> Iterable[Any]:
        st = getattr(self.bot, "state", None)
        if st is not None and hasattr(st, "units"):
            return st.units
        if hasattr(self.bot, "all_units"):
            return self.bot.all_units
        return self.bot.units

    def _owned_of_type(self, unit_type: U) -> list[Any]:
        out = []
        for u in self._iter_owned():
            is_mine = getattr(u, "is_mine", None)
            if is_mine is not None and not is_mine:
                continue
            if getattr(u, "type_id", None) == unit_type:
                out.append(u)
        return out

    # ----------------------------
    # counts
    # ----------------------------
    def have(self, unit_type: U) -> int:
        return len(self._owned_of_type(unit_type))

    def ready(self, unit_type: U) -> int:
        units = self._owned_of_type(unit_type)
        return sum(1 for u in units if getattr(u, "is_ready", False))

    def pending(self, unit_type: U) -> int:
        return int(self.bot.already_pending(unit_type))

    def total(self, unit_type: U) -> int:
        return self.have(unit_type) + self.pending(unit_type)

    # ----------------------------
    # low-level do() compatible
    # ----------------------------
    async def _do(self, cmd) -> bool:
        fn = getattr(self.bot, "do", None)
        if fn is None:
            return False

        res = fn(cmd)
        if inspect.isawaitable(res):
            res = await res

        # python-sc2 costuma retornar bool / ActionResult / None dependendo do fork
        if isinstance(res, bool):
            return res
        if res is None:
            # não dá pra afirmar sucesso: trate como "falhou" para não poluir o estado
            return False
        return True

    # ----------------------------
    # geyser access (neutral units)
    # ----------------------------
    def _iter_geyser_candidates(self) -> list[Any]:
        bot = self.bot
        st = getattr(bot, "state", None)

        if st is not None and hasattr(st, "vespene_geyser"):
            try:
                gs = list(st.vespene_geyser)
                if gs:
                    return gs
            except Exception:
                pass

        if hasattr(bot, "vespene_geyser"):
            try:
                gs = list(bot.vespene_geyser)
                if gs:
                    return gs
            except Exception:
                pass

        if st is not None and hasattr(st, "neutral_units"):
            try:
                gs = [u for u in st.neutral_units if getattr(u, "type_id", None) == U.VESPENEGEYSER]
                if gs:
                    return gs
            except Exception:
                pass

        return [u for u in self._iter_all_units() if getattr(u, "type_id", None) == U.VESPENEGEYSER]

    # ----------------------------
    # upgrades (robust)
    # ----------------------------
    def has_upgrade(self, up: Up) -> bool:
        st = getattr(self.bot, "state", None)
        ups = getattr(st, "upgrades", None)
        if ups is None:
            return False
        try:
            return up in ups
        except Exception:
            try:
                return int(up.value) in set(int(x) for x in ups)
            except Exception:
                return False

    def pending_upgrade(self, up: Up) -> int:
        fn = getattr(self.bot, "already_pending_upgrade", None)
        if fn is None:
            return 0
        try:
            return int(fn(up))
        except Exception:
            try:
                return int(fn(int(up.value)))
            except Exception:
                return 0

    # ----------------------------
    # actions
    # ----------------------------
    async def try_build(self, unit_type: U, *, near=None, wall_pref: str | None = None) -> bool:
        bot = self.bot

        if not bot.can_afford(unit_type):
            self._fail("build", unit_type, "cant_afford", {"minerals": int(bot.minerals), "gas": int(bot.vespene)})
            return False

        if bot.workers.amount == 0:
            self._fail("build", unit_type, "no_workers", None)
            return False

        # ---- REFINERY (near = geyser) ----
        if unit_type == U.REFINERY:
            ths = getattr(bot, "townhalls", None)
            th = ths.ready.first if ths and ths.ready else None
            if th is None:
                self._fail("build", unit_type, "no_townhall", None)
                return False

            geysers = sorted(self._iter_geyser_candidates(), key=lambda g: g.distance_to(th))
            if not geysers:
                self._fail("build", unit_type, "no_geyser_candidates", None)
                return False

            existing_refineries = self._owned_of_type(U.REFINERY)
            for g in geysers:
                occupied = any(r.distance_to(g) < 1.0 for r in existing_refineries)
                if occupied:
                    continue

                try:
                    res = await bot.build(U.REFINERY, near=g)
                except Exception as e:
                    self._fail("build", unit_type, "build_exception", {"error": str(e)})
                    return False

                if not res:
                    # aqui está o bug que te trava: build rejeitado, mas antes você logava ok
                    self._fail(
                        "build",
                        unit_type,
                        "build_rejected",
                        {"near_geyser": [float(g.position.x), float(g.position.y)]},
                    )
                    return False

                self._ok("build", unit_type, {"geyser_pos": [float(g.position.x), float(g.position.y)]})
                return True

            self._fail("build", unit_type, "all_geysers_occupied", None)
            return False

        # ---- NORMAL BUILD (Placement + bot.build) ----
        pos = await self.placement.find_placement(unit_type, near=near, wall_pref=wall_pref)
        if pos is None:
            self._fail("build", unit_type, "no_placement", {"wall_pref": wall_pref})
            return False

        try:
            res = await bot.build(unit_type, near=pos)
        except Exception as e:
            self._fail("build", unit_type, "build_exception", {"error": str(e), "pos": [float(pos.x), float(pos.y)]})
            return False

        if not res:
            self._fail(
                "build",
                unit_type,
                "build_rejected",
                {"pos": [float(pos.x), float(pos.y)], "wall_pref": wall_pref},
            )
            return False

        self._ok("build", unit_type, {"pos": [float(pos.x), float(pos.y)], "wall_pref": wall_pref})
        return True

    async def try_train(self, unit_type: U, *, from_type: U) -> bool:
        bot = self.bot

        producers = [u for u in self._owned_of_type(from_type) if getattr(u, "is_ready", False)]
        if not producers:
            self._fail("train", unit_type, "no_producer", {"from": str(from_type)})
            return False

        if not bot.can_afford(unit_type):
            self._fail("train", unit_type, "cant_afford", {"minerals": int(bot.minerals), "gas": int(bot.vespene)})
            return False

        if bot.supply_left <= 0:
            self._fail("train", unit_type, "no_supply", {"supply_left": int(bot.supply_left)})
            return False

        for b in producers:
            if not getattr(b, "is_idle", False):
                continue

            try:
                cmd = b.train(unit_type)
            except Exception as e:
                self._fail("train", unit_type, "train_exception", {"error": str(e), "from": str(from_type)})
                return False

            ok = await self._do(cmd)
            if ok:
                self._ok("train", unit_type, {"from": str(from_type), "producer_tag": int(getattr(b, "tag", 0))})
                return True

            self._fail("train", unit_type, "do_failed", {"from": str(from_type), "producer_tag": int(getattr(b, "tag", 0))})
            return False

        self._fail("train", unit_type, "all_busy", {"from": str(from_type)})
        return False

    # ----------------------------
    # addons + research (inalterado)
    # ----------------------------
    async def try_addon(self, *, on: U, addon: str) -> bool:
        bot = self.bot
        addon = addon.strip().upper()

        parents = [b for b in self._owned_of_type(on) if getattr(b, "is_ready", False)]
        if not parents:
            self._fail("addon", on, "no_parent", {"on": str(on)})
            return False

        parent = None
        for b in parents:
            if getattr(b, "is_idle", False):
                parent = b
                break
        if parent is None:
            self._fail("addon", on, "no_idle_parent", {"on": str(on)})
            return False

        if on == U.BARRACKS and addon == "TECHLAB":
            ability = A.BUILD_TECHLAB_BARRACKS
            unit_name = "BARRACKSTECHLAB"
        elif on == U.BARRACKS and addon == "REACTOR":
            ability = A.BUILD_REACTOR_BARRACKS
            unit_name = "BARRACKSREACTOR"
        elif on == U.FACTORY and addon == "TECHLAB":
            ability = A.BUILD_TECHLAB_FACTORY
            unit_name = "FACTORYTECHLAB"
        elif on == U.FACTORY and addon == "REACTOR":
            ability = A.BUILD_REACTOR_FACTORY
            unit_name = "FACTORYREACTOR"
        elif on == U.STARPORT and addon == "TECHLAB":
            ability = A.BUILD_TECHLAB_STARPORT
            unit_name = "STARPORTTECHLAB"
        elif on == U.STARPORT and addon == "REACTOR":
            ability = A.BUILD_REACTOR_STARPORT
            unit_name = "STARPORTREACTOR"
        else:
            self._fail("addon", on, "unsupported_addon", {"on": str(on), "addon": addon})
            return False

        can_afford_ability = getattr(bot, "can_afford", None)
        if callable(can_afford_ability):
            try:
                if not bot.can_afford(ability):
                    self._fail("addon", on, "cant_afford", {"ability": str(ability)})
                    return False
            except Exception:
                pass

        ok = await self._do(parent(ability))
        if ok:
            self._ok("addon", on, {"on": on.name, "addon": addon, "unit": unit_name, "parent_tag": int(parent.tag)})
            return True

        self._fail("addon", on, "do_failed", {"on": on.name, "addon": addon})
        return False

    async def try_research(self, upgrade: Up) -> bool:
        bot = self.bot

        if self.has_upgrade(upgrade):
            self._fail("research", U.BARRACKS, "already_done", {"upgrade": str(upgrade)})
            return False

        if self.pending_upgrade(upgrade) > 0:
            self._fail("research", U.BARRACKS, "already_pending", {"upgrade": str(upgrade)})
            return False

        if upgrade == Up.STIMPACK:
            labs = [x for x in self._owned_of_type(U.BARRACKSTECHLAB) if getattr(x, "is_ready", False)]
            if not labs:
                self._fail("research", U.BARRACKSTECHLAB, "no_techlab", {"upgrade": "STIMPACK"})
                return False

            lab = None
            for x in labs:
                if getattr(x, "is_idle", False):
                    lab = x
                    break
            if lab is None:
                self._fail("research", U.BARRACKSTECHLAB, "all_busy", {"upgrade": "STIMPACK"})
                return False

            try:
                if not bot.can_afford(A.RESEARCH_STIMPACK):
                    self._fail("research", U.BARRACKSTECHLAB, "cant_afford", {"upgrade": "STIMPACK"})
                    return False
            except Exception:
                pass

            ok = await self._do(lab(A.RESEARCH_STIMPACK))
            if ok:
                self._ok("research", U.BARRACKSTECHLAB, {"upgrade": "STIMPACK", "lab_tag": int(lab.tag)})
                return True

            self._fail("research", U.BARRACKSTECHLAB, "do_failed", {"upgrade": "STIMPACK"})
            return False

        self._fail("research", U.BARRACKS, "unsupported_upgrade", {"upgrade": str(upgrade)})
        return False

    # ----------------------------
    # logging helpers
    # ----------------------------
    def _ok(self, kind: str, unit_type: U, details: dict | None):
        self.last = LastAction(ok=True, kind=kind, unit=str(unit_type.name), reason="ok", details=details)
        if self.log:
            self.log.emit(
                "action_ok",
                {"kind": kind, "unit": unit_type.name, **(details or {})},
                meta={"iter": int(self.state.iteration)},
            )

    def _fail(self, kind: str, unit_type: U, reason: str, details: dict | None):
        self.last = LastAction(ok=False, kind=kind, unit=str(unit_type.name), reason=reason, details=details)
        if self.log:
            payload = {"kind": kind, "unit": unit_type.name, "reason": reason}
            if details:
                payload.update(details)
            self.log.emit("action_fail", payload, meta={"iter": int(self.state.iteration)})

# ---------- bot/engine/economy.py ----------
#bot/engine/economy.py
# economy.py
from __future__ import annotations

from typing import Any

from sc2.ids.unit_typeid import UnitTypeId as U


class Economy:
    def __init__(self, bot: Any, *, ctx: Any | None = None, logger: Any | None = None):
        self.bot = bot
        self.ctx = ctx
        self.log = logger

    async def step(self) -> None:
        # python-sc2 worker distribution
        await self.bot.distribute_workers()

    async def train_scv(self, target: int) -> bool:
        """Treina SCV até atingir target (conta pending)."""
        bot = self.bot
        if not bot.townhalls.ready:
            return False

        scv_total = bot.workers.amount + bot.already_pending(U.SCV)
        if scv_total >= int(target):
            return False

        cc = bot.townhalls.ready.first
        if cc.is_idle and bot.can_afford(U.SCV) and bot.supply_left > 0:
            cc.train(U.SCV)
            if self.log:
                self.log.emit(
                    "econ_train_scv",
                    {"target": int(target), "scv_total": int(scv_total) + 1},
                    meta={"iter": int(getattr(self.ctx, "iteration", 0))},
                )
            return True

        return False

# ---------- bot/engine/expansion_finder.py ----------
#bot/engine/expansion_finder.py
#bot/engine/expansion_finder.py
from __future__ import annotations

from dataclasses import dataclass
from collections import deque
from typing import Any, Dict, List, Optional, Tuple, Callable

from sc2.position import Point2


@dataclass(frozen=True)
class ExpansionRank:
    pos: Point2
    path_dist: float


def _k(p: Point2) -> Tuple[int, int]:
    # chave estável: coords *2 (grid de 0.5)
    return (int(round(float(p.x) * 2)), int(round(float(p.y) * 2)))


def _tile(p: Point2) -> Tuple[int, int]:
    # tile 1x1 (inteiro)
    return (int(round(float(p.x))), int(round(float(p.y))))


def _emit(emit: Optional[Callable[[str, dict], None]], event: str, payload: dict) -> None:
    if emit is None:
        return
    try:
        emit(event, payload)
    except Exception:
        # logging nunca pode quebrar o bot
        pass


def _in_pathing_grid(bot: Any, p: Point2) -> bool:
    fn = getattr(bot, "in_pathing_grid", None)
    if callable(fn):
        try:
            return bool(fn(p))
        except Exception:
            return False

    # fallback: tenta game_info.pathing_grid
    gi = getattr(bot, "game_info", None)
    grid = getattr(gi, "pathing_grid", None) if gi is not None else None
    if grid is None:
        return False

    x, y = _tile(p)
    try:
        return bool(grid[x, y])  # type: ignore[index]
    except Exception:
        try:
            return bool(grid.is_set(Point2((x, y))))  # type: ignore[attr-defined]
        except Exception:
            return False


def _nearest_pathable(bot: Any, p: Point2, *, max_r: int = 6) -> Optional[Point2]:
    """
    Garante que o ponto usado no pathing esteja no grid caminhável.
    Se já for válido, retorna p.
    Senão, procura um ponto próximo (anel/espiral) no pathing grid.
    """
    if p is None:
        return None
    p = Point2((float(p.x), float(p.y)))

    if _in_pathing_grid(bot, p):
        return p

    base_x, base_y = _tile(p)
    for r in range(1, int(max_r) + 1):
        for dx in range(-r, r + 1):
            for dy in (-r, r):
                q = Point2((base_x + dx, base_y + dy))
                if _in_pathing_grid(bot, q):
                    return q
        for dy in range(-r + 1, r):
            for dx in (-r, r):
                q = Point2((base_x + dx, base_y + dy))
                if _in_pathing_grid(bot, q):
                    return q

    return None


def _start_from_townhall(bot: Any, preferred: Optional[Point2]) -> Optional[Point2]:
    """
    Anti-bug do caller: se existe townhall pronta, use o centro dela como start.
    - se preferred existe, pega a townhall mais próxima de preferred
    - senão, usa a mais próxima de bot.start_location
    """
    ths = getattr(bot, "townhalls", None)
    if ths is None:
        return None

    try:
        ready = ths.ready
    except Exception:
        return None

    if not ready:
        return None

    anchor = preferred
    if anchor is None:
        anchor = getattr(bot, "start_location", None)

    try:
        if anchor is not None:
            # python-sc2 Units tem closest_to
            th = ready.closest_to(anchor)
        else:
            th = ready.first
        return th.position
    except Exception:
        try:
            return ready.first.position
        except Exception:
            return None


async def _query_path(bot: Any, a: Point2, b: Point2, *, emit: Optional[Callable[[str, dict], None]] = None) -> Optional[float]:
    """
    Retorna distância de pathing (ground) entre a e b.
    Robustez:
    - ajusta a/b para pontos caminháveis (pathing grid)
    - se query_pathing falhar/retornar None, devolve None (sem inventar euclidiano)
    """
    client = getattr(bot, "client", None)
    if client is None:
        _emit(emit, "pathing_query_unavailable", {"reason": "no_client"})
        return None

    fn = getattr(client, "query_pathing", None)
    if not callable(fn):
        _emit(emit, "pathing_query_unavailable", {"reason": "no_query_pathing"})
        return None

    a2 = _nearest_pathable(bot, a)
    b2 = _nearest_pathable(bot, b)

    if a2 is None or b2 is None:
        _emit(
            emit,
            "pathing_query_adjust_fail",
            {"a": [float(a.x), float(a.y)], "b": [float(b.x), float(b.y)]},
        )
        return None

    try:
        d = await fn(a2, b2)
        if d is None:
            _emit(
                emit,
                "pathing_query_none",
                {
                    "a": [float(a2.x), float(a2.y)],
                    "b": [float(b2.x), float(b2.y)],
                },
            )
            return None
        out = float(d)
        _emit(
            emit,
            "pathing_query_ok",
            {
                "a": [float(a2.x), float(a2.y)],
                "b": [float(b2.x), float(b2.y)],
                "d": out,
            },
        )
        return out
    except Exception as e:
        _emit(
            emit,
            "pathing_query_error",
            {
                "a": [float(a2.x), float(a2.y)],
                "b": [float(b2.x), float(b2.y)],
                "err": str(e)[:200],
            },
        )
        return None


def _grid_accessor(bot: Any):
    gi = getattr(bot, "game_info", None)
    grid = getattr(gi, "pathing_grid", None) if gi is not None else None
    if grid is None:
        return None

    w = getattr(grid, "width", None)
    h = getattr(grid, "height", None)
    if not isinstance(w, int) or not isinstance(h, int):
        size = getattr(grid, "size", None)
        if isinstance(size, tuple) and len(size) == 2:
            w, h = int(size[0]), int(size[1])

    if not isinstance(w, int) or not isinstance(h, int):
        return None

    def is_pathable(x: int, y: int) -> bool:
        if x < 0 or y < 0 or x >= w or y >= h:
            return False
        try:
            return bool(grid[x, y])  # type: ignore[index]
        except Exception:
            try:
                return bool(grid.is_set(Point2((x, y))))  # type: ignore[attr-defined]
            except Exception:
                return False

    return (w, h, is_pathable)


def _bfs_distances_on_pathing_grid(bot: Any, start: Point2, *, emit: Optional[Callable[[str, dict], None]] = None) -> Optional[Dict[Tuple[int, int], int]]:
    """
    Fallback de chão (não-euclidiano):
    BFS no pathing_grid, custo uniforme por tile.
    Retorna dist[tile] = steps.
    """
    acc = _grid_accessor(bot)
    if acc is None:
        _emit(emit, "pathing_bfs_unavailable", {"reason": "no_grid_accessor"})
        return None
    w, h, is_pathable = acc

    s = _nearest_pathable(bot, start)
    if s is None:
        _emit(emit, "pathing_bfs_unavailable", {"reason": "start_not_pathable"})
        return None

    sx, sy = _tile(s)
    if not is_pathable(sx, sy):
        _emit(emit, "pathing_bfs_unavailable", {"reason": "start_tile_not_pathable", "start": [sx, sy]})
        return None

    dist: Dict[Tuple[int, int], int] = {}
    q = deque()
    dist[(sx, sy)] = 0
    q.append((sx, sy))

    visited = 0

    while q:
        x, y = q.popleft()
        visited += 1
        d0 = dist[(x, y)]
        nd = d0 + 1

        nx, ny = x + 1, y
        if (nx, ny) not in dist and is_pathable(nx, ny):
            dist[(nx, ny)] = nd
            q.append((nx, ny))

        nx, ny = x - 1, y
        if (nx, ny) not in dist and is_pathable(nx, ny):
            dist[(nx, ny)] = nd
            q.append((nx, ny))

        nx, ny = x, y + 1
        if (nx, ny) not in dist and is_pathable(nx, ny):
            dist[(nx, ny)] = nd
            q.append((nx, ny))

        nx, ny = x, y - 1
        if (nx, ny) not in dist and is_pathable(nx, ny):
            dist[(nx, ny)] = nd
            q.append((nx, ny))

    _emit(emit, "pathing_bfs_ok", {"tiles_reached": len(dist), "popped": visited, "grid": [w, h]})
    return dist


async def rank_expansions_by_pathing(
    bot: Any,
    expansions: List[Point2],
    *,
    start: Point2,
    cache: Dict[Tuple[int, int], float] | None = None,
    bfs_fail_ratio: float = 0.5,
    emit: Optional[Callable[[str, dict], None]] = None,
) -> List[ExpansionRank]:
    """
    Ordena expansões por distância de chão.

    Estratégia:
    1) tenta query_pathing (robusto com nearest pathable)
    2) se muitas queries falharem, roda BFS no pathing_grid
    3) se BFS não existir, retorna as que conseguir medir + INF temporário pras restantes (sem cachear INF)
    """
    cache = cache if cache is not None else {}

    ranks: List[ExpansionRank] = []
    missing: List[Point2] = []

    ok_q = 0
    fail_q = 0

    for p in expansions:
        key = _k(p)
        if key in cache:
            ranks.append(ExpansionRank(pos=p, path_dist=float(cache[key])))
            continue

        d = await _query_path(bot, start, p, emit=emit)
        if d is None:
            missing.append(p)
            fail_q += 1
            continue

        cache[key] = float(d)
        ranks.append(ExpansionRank(pos=p, path_dist=float(d)))
        ok_q += 1

    total = max(1, len(expansions))
    fail_ratio = float(len(missing)) / float(total)

    _emit(
        emit,
        "pathing_rank_summary",
        {
            "expansions": int(len(expansions)),
            "query_ok": int(ok_q),
            "query_fail": int(fail_q),
            "missing": int(len(missing)),
            "fail_ratio": float(fail_ratio),
            "bfs_fail_ratio": float(bfs_fail_ratio),
        },
    )

    if missing and fail_ratio >= float(bfs_fail_ratio):
        dist_map = _bfs_distances_on_pathing_grid(bot, start, emit=emit)
        if dist_map is not None:
            solved = 0
            for p in missing:
                tx, ty = _tile(p)
                steps = dist_map.get((tx, ty))
                if steps is None:
                    pp = _nearest_pathable(bot, p)
                    if pp is not None:
                        tx2, ty2 = _tile(pp)
                        steps = dist_map.get((tx2, ty2))

                if steps is None:
                    continue

                d = float(steps)
                cache[_k(p)] = d
                ranks.append(ExpansionRank(pos=p, path_dist=d))
                solved += 1

            _emit(emit, "pathing_bfs_solve", {"missing": int(len(missing)), "solved": int(solved)})

    # ainda faltando? joga pra longe (SEM cachear INF)
    for p in missing:
        if _k(p) in cache:
            continue
        ranks.append(ExpansionRank(pos=p, path_dist=1e18))

    ranks.sort(key=lambda r: r.path_dist)
    return ranks


async def compute_main_and_natural(
    bot: Any,
    *,
    expansions: List[Point2],
    start: Point2,
    cache: Dict[Tuple[int, int], float] | None = None,
    emit: Optional[Callable[[str, dict], None]] = None,
) -> tuple[Optional[Point2], Optional[Point2]]:
    """
    Main = expansão mais próxima (ground) do start REAL.
    Natural = segunda mais próxima que não seja “colada” no main.

    PATCH CRÍTICO:
    - Se houver townhall pronta, usa o centro dela como start, ignorando start ruim do caller.
    """
    if not expansions:
        _emit(emit, "expansion_compute_fail", {"reason": "no_expansions"})
        return None, None

    # Start “de verdade”: townhall center > caller start
    th_start = _start_from_townhall(bot, start)
    if th_start is not None:
        _emit(
            emit,
            "expansion_start_override",
            {
                "caller_start": [float(start.x), float(start.y)] if start is not None else None,
                "townhall_start": [float(th_start.x), float(th_start.y)],
            },
        )
        start_eff = th_start
    else:
        start_eff = start

    ranks = await rank_expansions_by_pathing(bot, expansions, start=start_eff, cache=cache, emit=emit)

    if not ranks:
        _emit(emit, "expansion_compute_fail", {"reason": "no_ranks"})
        return None, None

    main = ranks[0].pos
    nat = None

    # filtro anti-lixo: natural normalmente não é “colada” no main.
    # (3.0 é ok; se o seu mapa tiver expo muito perto, aumente depois)
    for r in ranks[1:]:
        if float(r.pos.distance_to(main)) > 3.0 and float(r.path_dist) < 1e17:
            nat = r.pos
            break

    _emit(
        emit,
        "expansion_compute_ok",
        {
            "main": [float(main.x), float(main.y)] if main is not None else None,
            "natural": [float(nat.x), float(nat.y)] if nat is not None else None,
            "start_eff": [float(start_eff.x), float(start_eff.y)] if start_eff is not None else None,
        },
    )

    return main, nat

# ---------- bot/engine/locations.py ----------
#bot/engine/locations.py
#bot/engine/locations.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional, Tuple, List

from sc2.position import Point2
from sc2.ids.unit_typeid import UnitTypeId as U

from bot.engine.expansion_finder import compute_main_and_natural


def _k(p: Point2) -> Tuple[int, int]:
    return (int(round(float(p.x) * 2)), int(round(float(p.y) * 2)))


@dataclass
class MapLocations:
    my_main: Optional[Point2] = None
    my_natural: Optional[Point2] = None
    enemy_main: Optional[Point2] = None
    enemy_natural: Optional[Point2] = None


class LocationsService:
    """
    Fonte única da verdade para:
      - my_main / my_natural
      - enemy_main / enemy_natural

    Critério: distância de CHÃO.
    Sem fallback silencioso pra euclidiana.
    """

    def __init__(self, bot: Any, *, ctx: Any, logger: Any | None = None, debug: bool = True):
        self.bot = bot
        self.ctx = ctx
        self.log = logger
        self.debug = debug

        self.loc = MapLocations()

        self._cache_my: Dict[Tuple[int, int], float] = {}
        self._cache_enemy: Dict[Tuple[int, int], float] = {}

        self._next_recalc_iter: int = 0
        self._last_emit_iter: int = -999999

    # -----------------------
    # Legacy API (compat)
    # -----------------------
    def my_main_exp(self) -> Optional[Point2]:
        return self.loc.my_main

    def my_natural_exp(self) -> Optional[Point2]:
        return self.loc.my_natural

    def enemy_main_exp(self) -> Optional[Point2]:
        return self.loc.enemy_main

    def enemy_natural_exp(self) -> Optional[Point2]:
        return self.loc.enemy_natural

    # -----------------------
    # Internals
    # -----------------------
    def _emit(self, event: str, payload: dict) -> None:
        if self.log:
            self.log.emit(event, payload, meta={"iter": int(getattr(self.ctx, "iteration", 0))})

    def _expansions(self) -> List[Point2]:
        exps = getattr(self.bot, "expansion_locations_list", None)
        return list(exps) if exps else []

    def _pt(self, p: Optional[Point2]) -> Optional[list[float]]:
        if p is None:
            return None
        return [float(p.x), float(p.y)]

    def _same(self, a: Optional[Point2], b: Optional[Point2], eps: float = 0.25) -> bool:
        if a is None and b is None:
            return True
        if a is None or b is None:
            return False
        return float(a.distance_to(b)) <= float(eps)

    # ---- START ORIGINS (sem euclidiano) ----
    def _my_ground_start(self) -> Optional[Point2]:
        """
        Prioridade:
        1) centro do townhall (muito melhor pro pathing do que start_location)
        2) SCV (se por algum motivo não tem townhall)
        3) start_location (último recurso)
        """
        ths = getattr(self.bot, "townhalls", None)
        if ths is not None:
            try:
                if ths.ready:
                    return ths.ready.first.position
            except Exception:
                pass
            try:
                if ths:
                    return ths.first.position
            except Exception:
                pass

        workers = getattr(self.bot, "workers", None)
        if workers is not None:
            try:
                if workers:
                    return workers.first.position
            except Exception:
                pass

        return getattr(self.bot, "start_location", None)

    def _enemy_ground_start(self) -> Optional[Point2]:
        """
        Prioridade:
        1) inimigo visto: CC/Nexus/Hatch/Lair/Hive etc
        2) enemy_start_locations[0]
        """
        # enemy structures seen (quando tiver)
        try:
            es = getattr(self.bot, "enemy_structures", None)
            if es is not None:
                for ut in (U.COMMANDCENTER, U.ORBITALCOMMAND, U.PLANETARYFORTRESS, U.NEXUS, U.HATCHERY, U.LAIR, U.HIVE):
                    try:
                        grp = es(ut)
                        if grp:
                            # pega o mais “central”/primeiro
                            return grp.first.position
                    except Exception:
                        continue
        except Exception:
            pass

        locs = getattr(self.bot, "enemy_start_locations", None)
        return locs[0] if locs else None

    async def recalc_if_needed(self, iteration: int, *, every_iters: int = 110) -> None:
        iteration = int(iteration)
        if iteration < int(self._next_recalc_iter):
            return

        exps = self._expansions()
        if not exps:
            return

        my_start = self._my_ground_start()
        enemy_start = self._enemy_ground_start()

        # se nem start temos, não inventa
        if my_start is None:
            self._emit("locations_skip", {"reason": "no_my_start"})
            self._next_recalc_iter = iteration + int(every_iters)
            return

        # --- MY ---
        my_main, my_nat = await compute_main_and_natural(
            self.bot, expansions=exps, start=my_start, cache=self._cache_my
        )

        # --- ENEMY ---
        enemy_main, enemy_nat = (None, None)
        if enemy_start is not None:
            enemy_main, enemy_nat = await compute_main_and_natural(
                self.bot, expansions=exps, start=enemy_start, cache=self._cache_enemy
            )

        # se enemy_start não existe ainda, não chuta
        changed = (
            (not self._same(self.loc.my_main, my_main))
            or (not self._same(self.loc.my_natural, my_nat))
            or (not self._same(self.loc.enemy_main, enemy_main))
            or (not self._same(self.loc.enemy_natural, enemy_nat))
        )

        self.loc.my_main = my_main
        self.loc.my_natural = my_nat
        self.loc.enemy_main = enemy_main
        self.loc.enemy_natural = enemy_nat

        # publica também no bot (compat)
        self.bot.cached_main_expansion = my_main
        self.bot.cached_natural_expansion = my_nat
        self.bot.cached_enemy_main_expansion = enemy_main
        self.bot.cached_enemy_natural_expansion = enemy_nat

        # loga origem usada (pra debug do “ponto errado”)
        if self.log:
            self._emit(
                "locations_origin",
                {
                    "my_start": self._pt(my_start),
                    "enemy_start": self._pt(enemy_start),
                },
            )

        # emite evento: no máximo 1x por ~22 iters, ou sempre se mudou
        if changed or (iteration - self._last_emit_iter) >= 22:
            self._last_emit_iter = iteration
            self._emit(
                "locations_update",
                {
                    "my_main": self._pt(my_main),
                    "my_natural": self._pt(my_nat),
                    "enemy_main": self._pt(enemy_main),
                    "enemy_natural": self._pt(enemy_nat),
                },
            )

        self._next_recalc_iter = iteration + int(every_iters)

# ---------- bot/engine/placement.py ----------
#bot/engine/placement.py
#bot/engine/placement.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Optional, Dict, List, Tuple

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2

from bot.engine.wall import WallPlanner


def _snap_half(p: Point2) -> Point2:
    x = round(float(p.x) * 2.0) / 2.0
    y = round(float(p.y) * 2.0) / 2.0
    return Point2((x, y))


def _near_key(p: Point2 | None) -> str:
    """
    Cache key estável para 'near'. Não precisa ser perfeito; precisa ser consistente.
    """
    if p is None:
        return "NONE"
    p = _snap_half(p)
    return f"{float(p.x):.1f},{float(p.y):.1f}"


@dataclass
class _Reservation:
    unit_type: U
    pos: Point2
    expires_iter: int


class Placement:
    """
    Regra:
      - Se main_wall_enabled=True:
          * tenta colocar os 2 primeiros SUPPLYDEPOT e a 1a BARRACKS nos spots da MAIN wall,
            baseado em ocupação real (não em contador interno).
      - Se main_wall_enabled=False:
          * tudo usa placement normal.

    Patch importante:
      - Anchor default NÃO pode depender de townhalls.ready.first (ordem não é garantida).
      - Cache precisa respeitar o 'near', senão STARPORT pode “grudar” em base errada.
    """

    def __init__(
        self,
        bot: Any,
        *,
        ctx: Any | None = None,
        logger: Any | None = None,
        wall_main: bool = True,
        wall_natural: bool = False,
        main_wall_enabled: bool = True,
        reserve_ttl_iters: int = 80,
        debug: bool = True,
        # segurança: se cache estiver muito longe do near, ignora
        cache_max_dist: float = 18.0,
    ):
        self.bot = bot
        self.ctx = ctx
        self.log = logger
        self.debug = debug

        self.wall_main = bool(wall_main)
        self.wall_natural = bool(wall_natural)
        self.main_wall_enabled = bool(main_wall_enabled)
        self.reserve_ttl_iters = int(reserve_ttl_iters)
        self.cache_max_dist = float(cache_max_dist)

        self.wall = WallPlanner(bot, ctx=ctx, logger=logger, debug=debug) if ctx is not None else None

        # cache agora é por (unit_type + near_key)
        self._cache: Dict[str, Point2] = {}
        self._reservations: List[_Reservation] = []

        self._wall_slots: Dict[str, Dict[str, List[Point2]]] = {
            "MAIN": {"SUPPLYDEPOT": [], "BARRACKS": []},
            "NATURAL": {"SUPPLYDEPOT": [], "BARRACKS": []},
        }

    def _emit(self, event: str, payload: dict) -> None:
        if self.log:
            self.log.emit(event, payload, meta={"iter": int(getattr(self.ctx, "iteration", 0) if self.ctx else 0)})

    def _iter(self) -> int:
        return int(getattr(self.ctx, "iteration", 0) if self.ctx else 0)

    def _cleanup_reservations(self) -> None:
        it = self._iter()
        self._reservations = [r for r in self._reservations if int(r.expires_iter) > it]

    def _is_reserved(self, unit_type: U, pos: Point2) -> bool:
        for r in self._reservations:
            if r.unit_type == unit_type and float(r.pos.distance_to(pos)) < 0.25:
                return True
        return False

    def _reserve(self, unit_type: U, pos: Point2) -> None:
        it = self._iter()
        self._reservations.append(_Reservation(unit_type=unit_type, pos=pos, expires_iter=it + self.reserve_ttl_iters))

    async def _can_place(self, unit_type: U, pos: Point2) -> bool:
        bot = self.bot

        fn = getattr(bot, "can_place_single", None)
        if callable(fn):
            try:
                return bool(await fn(unit_type, pos))
            except Exception:
                pass

        fn = getattr(bot, "can_place", None)
        if callable(fn):
            try:
                res = fn(unit_type, [pos])
                if isinstance(res, list) and res:
                    return bool(res[0])
                return bool(res)
            except Exception:
                pass

        # fallback permissivo (mantém o teu comportamento), mas agora com logs melhores a montante
        return True

    def _pick_main_anchor(self) -> Point2:
        """
        Anchor default deve ser MAIN de forma estável.

        Heurística:
          1) Se ctx tiver my_main, usa.
          2) Senão, pega o townhall ready mais perto de start_location.
          3) Senão, start_location.
        """
        bot = self.bot

        # (1) ctx.my_main (quando existir)
        if self.ctx is not None:
            mm = getattr(self.ctx, "my_main", None)
            if isinstance(mm, Point2):
                self._emit("placement_anchor", {"kind": "ctx.my_main", "pos": [float(mm.x), float(mm.y)]})
                return mm

        # (2) townhall mais perto do start_location
        ths = getattr(bot, "townhalls", None)
        if ths is not None:
            try:
                ready = ths.ready
                if ready:
                    sl = bot.start_location
                    best = min(ready, key=lambda u: float(u.position.distance_to(sl)))
                    p = best.position
                    self._emit(
                        "placement_anchor",
                        {"kind": "townhall_closest_to_start", "pos": [float(p.x), float(p.y)]},
                    )
                    return p
            except Exception:
                pass

        # (3) start_location
        sl = bot.start_location
        self._emit("placement_anchor", {"kind": "start_location", "pos": [float(sl.x), float(sl.y)]})
        return sl

    async def _fallback_find(self, unit_type: U, *, near: Point2 | None) -> Point2 | None:
        bot = self.bot
        if near is None:
            near = self._pick_main_anchor()
        try:
            return await bot.find_placement(unit_type, near=near, placement_step=2)
        except Exception as e:
            self._emit(
                "placement_find_placement_exc",
                {"unit": unit_type.name, "near": [float(near.x), float(near.y)], "err": str(e)[:200]},
            )
            return None

    def _ensure_wall_slots_loaded(self, where: str) -> None:
        if self.wall is None:
            return
        w = str(where).strip().upper()
        if w not in self._wall_slots:
            return
        if self._wall_slots[w]["SUPPLYDEPOT"] or self._wall_slots[w]["BARRACKS"]:
            return

        try:
            depots = [p for p in self.wall.wall_spots_for(U.SUPPLYDEPOT, where=w) if p is not None]
            rax = [p for p in self.wall.wall_spots_for(U.BARRACKS, where=w) if p is not None]
            self._wall_slots[w]["SUPPLYDEPOT"] = [_snap_half(p) for p in depots[:2]]
            self._wall_slots[w]["BARRACKS"] = [_snap_half(p) for p in rax[:1]]
            self._emit(
                "placement_wall_slots_loaded",
                {
                    "where": w,
                    "depots": [[float(p.x), float(p.y)] for p in self._wall_slots[w]["SUPPLYDEPOT"]],
                    "barracks": [[float(p.x), float(p.y)] for p in self._wall_slots[w]["BARRACKS"]],
                },
            )
        except Exception:
            self._wall_slots[w]["SUPPLYDEPOT"] = []
            self._wall_slots[w]["BARRACKS"] = []

    def _my_units_of_type(self, ut: U) -> list[Any]:
        if not hasattr(self.bot, "units"):
            return []
        try:
            units = self.bot.units(ut)
        except Exception:
            return []
        out = []
        for u in units:
            is_mine = getattr(u, "is_mine", None)
            if is_mine is not None and not is_mine:
                continue
            out.append(u)
        return out

    def _occupied_near(self, ut: U, pos: Point2, *, max_d: float = 1.0) -> bool:
        for u in self._my_units_of_type(ut):
            try:
                if float(u.distance_to(pos)) <= float(max_d):
                    return True
            except Exception:
                continue
        return False

    async def _try_main_wall_firsts(self, ut: U) -> Optional[Point2]:
        """
        Força MAIN wall para:
          - SUPPLYDEPOT: usa os 2 slots disponíveis
          - BARRACKS: usa o 1 slot disponível
        Sem contador interno: decide por ocupação real + reserva TTL.
        """
        if not self.main_wall_enabled:
            return None
        if self.wall is None or not self.wall_main:
            return None
        if ut not in (U.SUPPLYDEPOT, U.BARRACKS):
            return None

        self._cleanup_reservations()
        self._ensure_wall_slots_loaded("MAIN")

        slots = self._wall_slots["MAIN"].get(ut.name, [])
        if not slots:
            return None

        for p in list(slots):
            p = _snap_half(p)

            if self._occupied_near(ut, p, max_d=1.0):
                continue
            if self._is_reserved(ut, p):
                continue
            if not await self._can_place(ut, p):
                continue

            self._reserve(ut, p)
            self._emit("placement_main_wall_forced", {"unit": ut.name, "pos": [float(p.x), float(p.y)]})
            return p

        return None

    def _cache_key(self, ut: U, near: Point2 | None) -> str:
        return f"{ut.name}@{_near_key(near)}"

    async def find_placement(
        self,
        unit_type,
        *,
        near: Point2 | None = None,
        wall_pref: str | None = None,
    ) -> Point2 | None:
        ut = unit_type
        if isinstance(unit_type, str):
            ut = getattr(U, unit_type)

        # se near não veio, assume MAIN estável
        if near is None:
            near = self._pick_main_anchor()

        # (A) wall_pref explícita (opener/force)
        if wall_pref is not None:
            w = str(wall_pref).strip().upper()
            self._cleanup_reservations()
            self._ensure_wall_slots_loaded(w)
            slots = self._wall_slots.get(w, {}).get(ut.name, [])
            for p in list(slots):
                p = _snap_half(p)

                if self._occupied_near(ut, p, max_d=1.0):
                    continue
                if self._is_reserved(ut, p):
                    continue
                if not await self._can_place(ut, p):
                    continue

                self._reserve(ut, p)
                self._cache[self._cache_key(ut, near)] = p
                self._emit("placement_wall_pick", {"where": w, "unit": ut.name, "pos": [float(p.x), float(p.y)]})
                return p

        # (B) primeiros buildings na MAIN wall
        forced = await self._try_main_wall_firsts(ut)
        if forced is not None:
            return forced

        # (C) fallback normal
        self._cleanup_reservations()

        ck = self._cache_key(ut, near)
        cached = self._cache.get(ck)
        if cached is not None and not self._is_reserved(ut, cached):
            # guarda: se cache “vazou” pra longe do near, ignora
            try:
                d = float(cached.distance_to(near))
            except Exception:
                d = 9999.0

            if d <= self.cache_max_dist:
                if await self._can_place(ut, cached):
                    self._reserve(ut, cached)
                    self._emit(
                        "placement_cache_hit",
                        {"unit": ut.name, "near": [float(near.x), float(near.y)], "pos": [float(cached.x), float(cached.y)], "d": d},
                    )
                    return cached
            else:
                self._emit(
                    "placement_cache_skip_far",
                    {
                        "unit": ut.name,
                        "near": [float(near.x), float(near.y)],
                        "cached": [float(cached.x), float(cached.y)],
                        "d": d,
                        "max": float(self.cache_max_dist),
                    },
                )

        pos = await self._fallback_find(ut, near=near)
        if pos is None:
            self._emit("placement_fail", {"unit": ut.name, "near": [float(near.x), float(near.y)]})
            return None

        pos = _snap_half(pos)
        self._reserve(ut, pos)
        self._cache[ck] = pos
        self._emit("placement_ok", {"unit": ut.name, "near": [float(near.x), float(near.y)], "pos": [float(pos.x), float(pos.y)]})
        return pos

# ---------- bot/engine/wall.py ----------
#bot/engine/wall.py
#bot/engine/wall.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Optional, List

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2


def _snap_half(p: Point2) -> Point2:
    x = round(float(p.x) * 2.0) / 2.0
    y = round(float(p.y) * 2.0) / 2.0
    return Point2((x, y))


@dataclass
class WallLayout:
    ramp: Any
    ramp_center: Optional[Point2]
    depot_positions: List[Point2]
    barracks_position: Optional[Point2]


class WallPlanner:
    """
    Suporta 2 walls:
      - MAIN: usa main_base_ramp quando possível
      - NATURAL: rampa mais provável da natural

    Retorna spots (2 depots + 1 barracks quando disponíveis).
    """

    def __init__(self, bot: Any, *, ctx: Any, logger: Any | None = None, debug: bool = True):
        self.bot = bot
        self.ctx = ctx
        self.log = logger
        self.debug = debug

        self._cached_main: WallLayout | None = None
        self._cached_nat: WallLayout | None = None
        self._cached_main_iter: int = -999999
        self._cached_nat_iter: int = -999999

    def _emit(self, event: str, payload: dict) -> None:
        if self.log:
            self.log.emit(event, payload, meta={"iter": int(getattr(self.ctx, "iteration", 0))})

    def _my_start(self) -> Optional[Point2]:
        return getattr(self.bot, "start_location", None)

    def _enemy_main(self) -> Optional[Point2]:
        locs = getattr(self.bot, "enemy_start_locations", None)
        return locs[0] if locs else None

    def _expansions(self) -> list[Point2]:
        exps = getattr(self.bot, "expansion_locations_list", None)
        return list(exps) if exps else []

    def _my_main_expansion(self) -> Optional[Point2]:
        my_main = self._my_start()
        exps = self._expansions()
        if my_main is None or not exps:
            return None
        return min(exps, key=lambda p: p.distance_to(my_main))

    def _my_natural(self) -> Optional[Point2]:
        nat = getattr(self.bot, "cached_natural_expansion", None)
        if nat is not None:
            return nat
        main_exp = self._my_main_expansion()
        exps = self._expansions()
        if main_exp is None or not exps:
            return None
        candidates = [p for p in exps if p.distance_to(main_exp) > 3.0]
        if not candidates:
            return None
        return min(candidates, key=lambda p: p.distance_to(main_exp))

    def _iter_ramps(self) -> list[Any]:
        gi = getattr(self.bot, "game_info", None)
        ramps = getattr(gi, "map_ramps", None) if gi is not None else None
        if ramps is None:
            ramps = getattr(self.bot, "ramps", None)
        try:
            return list(ramps) if ramps else []
        except Exception:
            return []

    def _is_reasonable_ramp(self, r: Any) -> bool:
        if r is None:
            return False
        if getattr(r, "top_center", None) is None and getattr(r, "upper", None) is None:
            return False
        return True

    def _ramp_center(self, r: Any) -> Optional[Point2]:
        tc = getattr(r, "top_center", None)
        bc = getattr(r, "bottom_center", None)
        if tc is not None and bc is not None:
            try:
                return Point2(((tc.x + bc.x) / 2, (tc.y + bc.y) / 2))
            except Exception:
                pass
        for k in ("top_center", "bottom_center", "upper", "lower"):
            p = getattr(r, k, None)
            if p is not None:
                return p
        return None

    def _layout_from_ramp(self, ramp: Any, *, label: str) -> WallLayout | None:
        if ramp is None:
            return None

        center = self._ramp_center(ramp)
        if center is not None:
            center = _snap_half(center)

        depot_positions: List[Point2] = []
        barracks_pos: Optional[Point2] = None

        # Ramp helpers (quando existem) — sempre snap.
        try:
            cds = getattr(ramp, "corner_depots", None)
            if cds:
                depot_positions = [_snap_half(p) for p in list(cds)[:2] if p is not None]
        except Exception:
            depot_positions = []

        try:
            bcp = getattr(ramp, "barracks_correct_placement", None)
            if bcp is not None:
                barracks_pos = _snap_half(bcp)
        except Exception:
            barracks_pos = None

        self._emit(
            "wall_layout",
            {
                "where": label,
                "ramp_center": [float(center.x), float(center.y)] if center else None,
                "depot_positions": [[float(p.x), float(p.y)] for p in depot_positions],
                "barracks_position": [float(barracks_pos.x), float(barracks_pos.y)] if barracks_pos else None,
            },
        )

        return WallLayout(
            ramp=ramp,
            ramp_center=center,
            depot_positions=depot_positions,
            barracks_position=barracks_pos,
        )

    def _main_ramp(self) -> Any | None:
        return getattr(self.bot, "main_base_ramp", None)

    def _find_natural_ramp(self) -> Any | None:
        nat = self._my_natural()
        if nat is None:
            return None

        enemy = self._enemy_main()
        ramps = [r for r in self._iter_ramps() if self._is_reasonable_ramp(r)]
        if not ramps:
            return None

        main_ramp = self._main_ramp()
        if main_ramp is not None:
            ramps = [r for r in ramps if r is not main_ramp]

        if not ramps:
            return None

        def score(r: Any) -> float:
            c = self._ramp_center(r)
            if c is None:
                return 1e18
            d_nat = float(c.distance_to(nat))
            if enemy is None:
                return d_nat
            d_enemy = float(c.distance_to(enemy))
            return d_nat + 0.03 * d_enemy

        return min(ramps, key=score)

    def compute(self, where: str, *, cache_window_iters: int = 400) -> WallLayout | None:
        it = int(getattr(self.ctx, "iteration", 0))
        w = str(where).strip().upper()

        if w == "MAIN":
            if self._cached_main is not None and (it - self._cached_main_iter) <= int(cache_window_iters):
                return self._cached_main

            ramp = self._main_ramp()
            layout = self._layout_from_ramp(ramp, label="MAIN")
            self._cached_main = layout
            self._cached_main_iter = it
            return layout

        if w == "NATURAL":
            if self._cached_nat is not None and (it - self._cached_nat_iter) <= int(cache_window_iters):
                return self._cached_nat

            ramp = self._find_natural_ramp()
            layout = self._layout_from_ramp(ramp, label="NATURAL")
            self._cached_nat = layout
            self._cached_nat_iter = it
            return layout

        return None

    def wall_spots_for(self, unit_type: U, *, where: str) -> List[Point2]:
        layout = self.compute(where)
        if layout is None:
            return []
        if unit_type == U.SUPPLYDEPOT:
            return list(layout.depot_positions)[:2]
        if unit_type == U.BARRACKS:
            return [layout.barracks_position] if layout.barracks_position is not None else []
        return []

    def wall_anchor(self, *, where: str) -> Optional[Point2]:
        layout = self.compute(where)
        if layout is None:
            return None
        return layout.ramp_center

# ---------- bot/strategy/loader.py ----------
#bot/strategy/loader.py
#bot/strategy/loader.py
from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, List

from .schema import (
    StrategyConfig,
    EconomyCfg,
    ProductionCfg,
    DropCfg,
    BehaviorsCfg,
    MacroBehaviorCfg,
    CombatBehaviorCfg,
    OpenerCfg,
)

_ALLOWED_POINTS = {"ENEMY_MAIN", "ENEMY_NATURAL", "MY_MAIN", "MY_NATURAL"}


def _as_str(x: Any, *, path: str) -> str:
    if not isinstance(x, str):
        raise TypeError(f"{path}: expected str, got {type(x).__name__}")
    return x


def _as_int(x: Any, *, path: str) -> int:
    if not isinstance(x, (int, float)):
        raise TypeError(f"{path}: expected int, got {type(x).__name__}")
    return int(x)


def _as_float(x: Any, *, path: str) -> float:
    if not isinstance(x, (int, float)):
        raise TypeError(f"{path}: expected float, got {type(x).__name__}")
    return float(x)


def _as_bool(x: Any, *, path: str) -> bool:
    if not isinstance(x, bool):
        raise TypeError(f"{path}: expected bool, got {type(x).__name__}")
    return x


def _require_obj(d: Dict[str, Any], key: str, *, path: str) -> Dict[str, Any]:
    if key not in d:
        raise KeyError(f"{path}: missing required key '{key}'")
    v = d[key]
    if not isinstance(v, dict):
        raise TypeError(f"{path}.{key}: must be object")
    return v


def _require_list(d: Dict[str, Any], key: str, *, path: str) -> list:
    if key not in d:
        raise KeyError(f"{path}: missing required key '{key}'")
    v = d[key]
    if not isinstance(v, list):
        raise TypeError(f"{path}.{key}: must be array")
    return v


def _parse_drop_obj(raw: Dict[str, Any], *, path: str, default_name: str) -> DropCfg:
    enabled = _as_bool(raw.get("enabled", False), path=f"{path}.enabled")
    if not enabled:
        return DropCfg(enabled=False, name=default_name)

    for k in ("min_marines", "load_count", "move_eps", "ground_radius", "staging", "target"):
        if k not in raw:
            raise KeyError(f"{path}.enabled=true exige '{k}'")

    name = raw.get("name", default_name)
    if not isinstance(name, str):
        raise TypeError(f"{path}.name: expected str")

    staging = _as_str(raw["staging"], path=f"{path}.staging")
    target = _as_str(raw["target"], path=f"{path}.target")

    if staging not in _ALLOWED_POINTS:
        raise ValueError(f"{path}.staging inválido: {staging} (allowed={sorted(_ALLOWED_POINTS)})")
    if target not in _ALLOWED_POINTS:
        raise ValueError(f"{path}.target inválido: {target} (allowed={sorted(_ALLOWED_POINTS)})")

    staging_dist = _as_float(raw.get("staging_dist", 18.0), path=f"{path}.staging_dist")

    start_time = raw.get("start_time", None)
    if start_time is not None:
        start_time = _as_float(start_time, path=f"{path}.start_time")

    start_loop = raw.get("start_loop", None)
    if start_loop is not None:
        start_loop = _as_int(start_loop, path=f"{path}.start_loop")

    pickup = _as_str(raw.get("pickup", "MY_MAIN"), path=f"{path}.pickup")
    if pickup not in _ALLOWED_POINTS:
        raise ValueError(f"{path}.pickup inválido: {pickup} (allowed={sorted(_ALLOWED_POINTS)})")

    pickup_eps = _as_float(raw.get("pickup_eps", 6.0), path=f"{path}.pickup_eps")
    load_range = _as_float(raw.get("load_range", 7.0), path=f"{path}.load_range")

    return DropCfg(
        enabled=True,
        name=name,
        start_time=start_time,
        start_loop=start_loop,
        min_marines=_as_int(raw["min_marines"], path=f"{path}.min_marines"),
        load_count=_as_int(raw["load_count"], path=f"{path}.load_count"),
        move_eps=_as_float(raw["move_eps"], path=f"{path}.move_eps"),
        ground_radius=_as_float(raw["ground_radius"], path=f"{path}.ground_radius"),
        pickup=pickup,
        staging=staging,
        target=target,
        staging_dist=staging_dist,
        pickup_eps=pickup_eps,
        load_range=load_range,
        require_stim=_as_bool(raw.get("require_stim", False), path=f"{path}.require_stim"),
    )


def _parse_opener(data: Dict[str, Any], *, path: str) -> OpenerCfg:
    # default: opener ligado e forçando wall
    if "opener" not in data or data["opener"] is None:
        return OpenerCfg()

    raw = data["opener"]
    if not isinstance(raw, dict):
        raise TypeError(f"{path}.opener must be object")

    enabled = _as_bool(raw.get("enabled", True), path=f"{path}.opener.enabled")
    force_wall = _as_bool(raw.get("force_wall", True), path=f"{path}.opener.force_wall")
    depots = _as_int(raw.get("depots", 2), path=f"{path}.opener.depots")
    barracks = _as_int(raw.get("barracks", 1), path=f"{path}.opener.barracks")

    # sane defaults
    depots = max(0, depots)
    barracks = max(0, barracks)

    return OpenerCfg(enabled=enabled, force_wall=force_wall, depots=depots, barracks=barracks)


def load_strategy(name: str) -> StrategyConfig:
    base = Path(__file__).resolve().parents[1] / "strats"
    path = base / f"{name}.json"

    if not path.exists():
        raise FileNotFoundError(f"Strategy file not found: {path}")

    try:
        data = json.loads(path.read_text(encoding="utf-8-sig"))
    except Exception as e:
        raise RuntimeError(f"Failed to parse JSON strategy: {path}") from e

    if not isinstance(data, dict):
        raise ValueError(f"Strategy root must be JSON object: {path}")

    econ = _require_obj(data, "economy", path=str(path))
    beh = _require_obj(data, "behaviors", path=str(path))
    build = _require_list(data, "build", path=str(path))
    prod_rules = _require_list(data, "production_rules", path=str(path))

    scv_target = _as_int(econ.get("scv_target"), path="economy.scv_target")
    depot_trigger = _as_int(econ.get("depot_trigger_supply_left"), path="economy.depot_trigger_supply_left")

    prod_cfg = data.get("production", {})
    if not isinstance(prod_cfg, dict):
        raise TypeError("production must be object")
    marine_cap = _as_int(prod_cfg.get("marine_cap", 24), path="production.marine_cap")

    macro = beh.get("macro")
    if not isinstance(macro, dict):
        raise TypeError("behaviors.macro must be object")
    for k in ("enabled", "auto_workers", "auto_scv", "auto_supply"):
        if k not in macro:
            raise KeyError(f"behaviors.macro: missing required key '{k}'")

    combat = beh.get("combat")
    if not isinstance(combat, dict):
        raise TypeError("behaviors.combat must be object")
    if "enabled" not in combat:
        raise KeyError("behaviors.combat: missing required key 'enabled'")

    # wall_natural pode vir como root bool, ou wall: { natural: bool }
    wall_natural = False
    if "wall_natural" in data:
        wall_natural = _as_bool(data.get("wall_natural", False), path="wall_natural")
    elif "wall" in data and isinstance(data["wall"], dict):
        wall_natural = _as_bool(data["wall"].get("natural", False), path="wall.natural")

    opener = _parse_opener(data, path=str(path))

    drops: List[DropCfg] = []
    if "drops" in data and data["drops"] is not None:
        raw_drops = data["drops"]
        if not isinstance(raw_drops, list):
            raise TypeError("drops must be array")
        for i, rd in enumerate(raw_drops):
            if not isinstance(rd, dict):
                raise TypeError(f"drops[{i}] must be object")
            dc = _parse_drop_obj(rd, path=f"drops[{i}]", default_name=f"drop_{i}")
            if dc.enabled:
                drops.append(dc)
    else:
        raw_drop = data.get("drop", None)
        if raw_drop is not None:
            if not isinstance(raw_drop, dict):
                raise TypeError("drop must be object")
            dc = _parse_drop_obj(raw_drop, path="drop", default_name="drop_0")
            if dc.enabled:
                drops.append(dc)

    return StrategyConfig(
        name=str(data.get("name", name)),
        economy=EconomyCfg(scv_target=scv_target, depot_trigger_supply_left=depot_trigger),
        production=ProductionCfg(marine_cap=marine_cap),
        behaviors=BehaviorsCfg(
            macro=MacroBehaviorCfg(
                enabled=_as_bool(macro["enabled"], path="behaviors.macro.enabled"),
                auto_workers=_as_bool(macro["auto_workers"], path="behaviors.macro.auto_workers"),
                auto_scv=_as_bool(macro["auto_scv"], path="behaviors.macro.auto_scv"),
                auto_supply=_as_bool(macro["auto_supply"], path="behaviors.macro.auto_supply"),
            ),
            combat=CombatBehaviorCfg(
                enabled=_as_bool(combat["enabled"], path="behaviors.combat.enabled"),
            ),
        ),
        wall_natural=bool(wall_natural),
        opener=opener,
        drops=drops,
        build=build,
        production_rules=prod_rules,
    )

# ---------- bot/strategy/plan_executor.py ----------
#bot/strategy/plan_executor.py
#bot/strategy/plan_executor.py
from __future__ import annotations

from typing import Any, Dict, Optional

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.ids.upgrade_id import UpgradeId as Up
from sc2.position import Point2

from .schema import StrategyConfig


def _as_int(x: Any, default: int = 0) -> int:
    try:
        return int(x)
    except Exception:
        return default


def _as_bool(x: Any, default: bool = False) -> bool:
    try:
        return bool(x)
    except Exception:
        return default


def parse_u(name: str) -> U:
    try:
        return getattr(U, name)
    except AttributeError as e:
        raise ValueError(f"UnitTypeId inválido no JSON: {name}") from e


def parse_up(name: str) -> Up:
    try:
        return getattr(Up, name)
    except AttributeError as e:
        raise ValueError(f"UpgradeId inválido no JSON: {name}") from e


_TEMPORARY_FAIL_REASONS: set[str] = {
    "cant_afford",
    "no_supply",
    "no_placement",
    "all_busy",
    "no_idle_parent",
    "do_failed",

    # NOVO: não mate o plan por isso
    "no_geyser_candidates",
    "all_geysers_occupied",
    "no_townhall",
    "no_workers",
}
_ALLOWED_NEAR_POINTS = {"MY_MAIN", "MY_NATURAL"}


class PlanExecutor:
    def __init__(self, bot: Any, builder: Any, strategy: StrategyConfig, *, ctx: Any, logger: Any | None = None):
        self.bot = bot
        self.builder = builder
        self.strategy = strategy
        self.ctx = ctx
        self.log = logger
        self._done_steps: set[str] = set()

        # opener runtime
        self._opener_done: bool = False
        self._opener_force_wall_active: bool = bool(getattr(self.strategy.opener, "force_wall", True))
        self._opener_no_place_streak: int = 0

        if self.log:
            self.log.emit(
                "strategy_loaded",
                {
                    "name": self.strategy.name,
                    "build_steps": int(len(self.strategy.build)),
                    "production_rules": int(len(self.strategy.production_rules)),
                    "opener": {
                        "enabled": bool(getattr(self.strategy.opener, "enabled", True)),
                        "force_wall": bool(getattr(self.strategy.opener, "force_wall", True)),
                        "depots": int(getattr(self.strategy.opener, "depots", 2)),
                        "barracks": int(getattr(self.strategy.opener, "barracks", 1)),
                    },
                },
                meta={"iter": int(getattr(self.ctx, "iteration", 0))},
            )

    async def step(self) -> None:
        # (0) opener obrigatório antes do plano
        if await self._run_opener_one_action():
            return

        # (1) build plan
        if await self._run_build_plan_one_step():
            return

        # (2) production rules
        await self._run_production_rules_one_action()

    # -----------------------
    # opener (MAIN wall)
    # -----------------------
    async def _run_opener_one_action(self) -> bool:
        opener = getattr(self.strategy, "opener", None)
        if opener is None or not bool(getattr(opener, "enabled", True)):
            self._opener_done = True
            return False

        if self._opener_done:
            return False

        depots_need = int(getattr(opener, "depots", 2))
        rax_need = int(getattr(opener, "barracks", 1))

        if depots_need <= 0 and rax_need <= 0:
            self._opener_done = True
            return False

        depots_total = int(self.builder.total(U.SUPPLYDEPOT))
        rax_total = int(self.builder.total(U.BARRACKS))

        if depots_total >= depots_need and rax_total >= rax_need:
            self._opener_done = True
            if self.log:
                self.log.emit(
                    "opener_complete",
                    {"depots_total": depots_total, "barracks_total": rax_total},
                    meta={"iter": int(self.ctx.iteration)},
                )
            return False

        # ordem fixa: depots -> barracks
        want = None
        if depots_total < depots_need:
            want = U.SUPPLYDEPOT
        elif rax_total < rax_need:
            want = U.BARRACKS

        if want is None:
            self._opener_done = True
            return False

        wall_pref = "MAIN" if self._opener_force_wall_active else None

        did = await self.builder.try_build(want, near=None, wall_pref=wall_pref)
        last = getattr(self.builder, "last", None)
        last_reason = str(getattr(last, "reason", "") or "")

        # se não conseguiu placement na wall repetidas vezes, faz fallback automático
        if not did and wall_pref is not None and last_reason == "no_placement":
            self._opener_no_place_streak += 1
            if self._opener_no_place_streak >= 8:
                self._opener_force_wall_active = False
                if self.log:
                    self.log.emit(
                        "opener_force_wall_disabled",
                        {"reason": "no_placement_streak", "streak": int(self._opener_no_place_streak)},
                        meta={"iter": int(self.ctx.iteration)},
                    )
        elif did:
            self._opener_no_place_streak = 0

        if self.log:
            self.log.emit(
                "opener_step",
                {
                    "want": want.name,
                    "did": bool(did),
                    "depots_total": depots_total,
                    "barracks_total": rax_total,
                    "force_wall_active": bool(self._opener_force_wall_active),
                    "last_reason": last_reason,
                },
                meta={"iter": int(self.ctx.iteration)},
            )

        return bool(did)

    # -----------------------
    # map-point helpers (near)
    # -----------------------
    def _my_start(self) -> Optional[Point2]:
        return getattr(self.bot, "start_location", None)

# --- PLAN_EXECUTOR: substituir _my_natural por esta versão ---

    def _my_natural(self) -> Optional[Point2]:
        loc = getattr(self.bot, "locations", None)
        if loc is not None:
            nat = loc.my_natural_exp()
            if nat is not None:
                return nat

        nat = getattr(self.bot, "cached_natural_expansion", None)
        if nat is not None:
            return nat

        exps = getattr(self.bot, "expansion_locations_list", None)
        my_main = self._my_start()
        if my_main is None or not exps:
            return None

        exps = list(exps)
        main_exp = min(exps, key=lambda p: p.distance_to(my_main))
        candidates = [p for p in exps if p.distance_to(main_exp) > 3.0]
        if not candidates:
            return None
        return min(candidates, key=lambda p: p.distance_to(main_exp))
    def _resolve_near(self, near_key: str | None) -> Optional[Point2]:
        if near_key is None:
            return None
        key = str(near_key).strip().upper()
        if key not in _ALLOWED_NEAR_POINTS:
            raise ValueError(f"near inválido: {key} (allowed={sorted(_ALLOWED_NEAR_POINTS)})")
        if key == "MY_MAIN":
            return self._my_start()
        if key == "MY_NATURAL":
            return self._my_natural()
        return None

    # -----------------------
    # main loop (build/production)
    # -----------------------
    async def _run_build_plan_one_step(self) -> bool:
        for step in self.strategy.build:
            name = str(step.get("name") or step.get("id") or "").strip() or f"_unnamed_{id(step)}"
            if name in self._done_steps:
                continue

            requires = step.get("requires") or {}
            when = step.get("when") or {}
            action = step.get("do") or {}

            if not self._check_conditions(requires):
                continue
            if not self._check_conditions(when):
                continue

            self._emit("plan_step_ready", {"name": name, "requires": requires, "when": when, "do": action})

            did = await self._execute_action(action)
            if did:
                self._done_steps.add(name)
                self._emit("plan_step_done", {"name": name, "do": action})
                return True

            last = getattr(self.builder, "last", None)
            last_reason = str(getattr(last, "reason", "") or "")
            last_details = getattr(last, "details", None)

            self._emit(
                "plan_step_blocked",
                {"name": name, "do": action, "last_reason": last_reason, "last_details": last_details},
            )

            if last_reason in _TEMPORARY_FAIL_REASONS:
                continue

            return False

        return False

    async def _run_production_rules_one_action(self) -> bool:
        for rule in self.strategy.production_rules:
            requires = rule.get("requires") or {}
            when = rule.get("when") or {}
            action = rule.get("do") or {}

            if not self._check_conditions(requires):
                continue
            if not self._check_conditions(when):
                continue

            self._emit("prod_rule_ready", {"name": rule.get("name", ""), "do": action})

            did = await self._execute_action(action)
            if did:
                self._emit("prod_rule_done", {"name": rule.get("name", ""), "do": action})
                return True

        return False

    def _check_conditions(self, cond: Dict[str, Any]) -> bool:
        if not cond:
            return True

        bot = self.bot

        if "minerals_gte" in cond and bot.minerals < _as_int(cond["minerals_gte"], 0):
            return False
        if "gas_gte" in cond and bot.vespene < _as_int(cond["gas_gte"], 0):
            return False

        if "supply_left_lte" in cond and bot.supply_left > _as_int(cond["supply_left_lte"], 0):
            return False
        if "supply_left_gte" in cond and bot.supply_left < _as_int(cond["supply_left_gte"], 0):
            return False

        if "supply_used_gte" in cond and bot.supply_used < _as_int(cond["supply_used_gte"], 0):
            return False
        if "supply_used_lte" in cond and bot.supply_used > _as_int(cond["supply_used_lte"], 0):
            return False

        if "supply_cap_gte" in cond and bot.supply_cap < _as_int(cond["supply_cap_gte"], 0):
            return False
        if "supply_cap_lte" in cond and bot.supply_cap > _as_int(cond["supply_cap_lte"], 0):
            return False

        if "have_gte" in cond and not self._check_unit_thresholds(cond["have_gte"], op="gte", mode="total"):
            return False
        if "have_lte" in cond and not self._check_unit_thresholds(cond["have_lte"], op="lte", mode="total"):
            return False
        if "ready_gte" in cond and not self._check_unit_thresholds(cond["ready_gte"], op="gte", mode="ready"):
            return False
        if "unit_gte" in cond and not self._check_unit_thresholds(cond["unit_gte"], op="gte", mode="total"):
            return False
        if "unit_lte" in cond and not self._check_unit_thresholds(cond["unit_lte"], op="lte", mode="total"):
            return False

        if "upgrade_done" in cond:
            ups = cond["upgrade_done"]
            if isinstance(ups, str):
                ups = [ups]
            if not isinstance(ups, list):
                raise TypeError("upgrade_done must be string or list of strings")
            for u in ups:
                up = parse_up(str(u))
                if not self.builder.has_upgrade(up):
                    return False

        if "upgrade_missing" in cond:
            ups = cond["upgrade_missing"]
            if isinstance(ups, str):
                ups = [ups]
            if not isinstance(ups, list):
                raise TypeError("upgrade_missing must be string or list of strings")
            for u in ups:
                up = parse_up(str(u))
                if self.builder.has_upgrade(up):
                    return False
                if self.builder.pending_upgrade(up) > 0:
                    return False

        return True

    def _check_unit_thresholds(self, table: Dict[str, Any], *, op: str, mode: str) -> bool:
        for k, v in table.items():
            ut = parse_u(str(k))
            thr = _as_int(v, 0)
            val = self.builder.ready(ut) if mode == "ready" else self.builder.total(ut)

            if op == "gte":
                if val < thr:
                    return False
            else:
                if val > thr:
                    return False
        return True

    async def _execute_action(self, action: Dict[str, Any]) -> bool:
        if not action:
            return False

        if "build" in action:
            ut = parse_u(str(action["build"]))

            limit = action.get("limit")
            if limit is not None and self.builder.total(ut) >= _as_int(limit, 0):
                return False
            if self.builder.pending(ut) > 0:
                return False

            near_key = action.get("near", None)
            near_pt = self._resolve_near(near_key) if near_key is not None else None
            return await self.builder.try_build(ut, near=near_pt)

        if "build_addon" in action:
            addon = str(action["build_addon"])
            on_name = str(action.get("on") or "").strip()
            if not on_name:
                raise ValueError("Action build_addon exige campo 'on' (ex: 'BARRACKS').")
            on_ut = parse_u(on_name)

            limit = action.get("limit")
            if limit is not None:
                addon_upper = addon.strip().upper()
                infer = None
                if on_ut == U.BARRACKS and addon_upper == "TECHLAB":
                    infer = U.BARRACKSTECHLAB
                elif on_ut == U.BARRACKS and addon_upper == "REACTOR":
                    infer = U.BARRACKSREACTOR
                elif on_ut == U.STARPORT and addon_upper == "REACTOR":
                    infer = U.STARPORTREACTOR
                elif on_ut == U.STARPORT and addon_upper == "TECHLAB":
                    infer = U.STARPORTTECHLAB
                elif on_ut == U.FACTORY and addon_upper == "TECHLAB":
                    infer = U.FACTORYTECHLAB
                elif on_ut == U.FACTORY and addon_upper == "REACTOR":
                    infer = U.FACTORYREACTOR

                if infer is not None and self.builder.total(infer) >= _as_int(limit, 0):
                    return False

            return await self.builder.try_addon(on=on_ut, addon=addon)

        if "research" in action:
            up = parse_up(str(action["research"]))
            return await self.builder.try_research(up)

        if "train" in action:
            ut = parse_u(str(action["train"]))
            from_name = str(action.get("from") or "").strip()
            if not from_name:
                raise ValueError("Action train exige campo 'from' (ex: 'BARRACKS').")
            ft = parse_u(from_name)

            cap = action.get("cap")
            if cap is not None and self.builder.total(ut) >= _as_int(cap, 0):
                return False

            return await self.builder.try_train(ut, from_type=ft)

        return False

    def _emit(self, event: str, payload: dict) -> None:
        if not self.log:
            return
        self.log.emit(event, payload, meta={"strategy": self.strategy.name, "iter": int(self.ctx.iteration)})

# ---------- bot/strategy/schema.py ----------
#bot/strategy/schema.py
#bot/strategy/schema.py
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional


@dataclass(frozen=True)
class EconomyCfg:
    scv_target: int = 20
    depot_trigger_supply_left: int = 2


@dataclass(frozen=True)
class ProductionCfg:
    marine_cap: int = 24


@dataclass(frozen=True)
class MacroBehaviorCfg:
    enabled: bool = True
    auto_workers: bool = True
    auto_scv: bool = True
    auto_supply: bool = True


@dataclass(frozen=True)
class CombatBehaviorCfg:
    enabled: bool = False


@dataclass(frozen=True)
class BehaviorsCfg:
    macro: MacroBehaviorCfg = MacroBehaviorCfg()
    combat: CombatBehaviorCfg = CombatBehaviorCfg()


@dataclass(frozen=True)
class DropCfg:
    enabled: bool = False
    name: str = "drop"

    start_loop: Optional[int] = None
    start_time: Optional[float] = None

    min_marines: int = 8
    load_count: int = 8
    move_eps: float = 3.0
    ground_radius: float = 12.0

    pickup: str = "MY_MAIN"
    staging: str = "ENEMY_NATURAL"
    target: str = "ENEMY_MAIN"
    staging_dist: float = 18.0

    pickup_eps: float = 6.0
    load_range: float = 7.0

    require_stim: bool = False


@dataclass(frozen=True)
class OpenerCfg:
    """
    Opener obrigatório (se enabled):
      - depots na MAIN wall
      - barracks na MAIN wall
    'force_wall' tenta usar os spots do WallPlanner; se falhar repetidamente, o PlanExecutor faz fallback.
    """
    enabled: bool = True
    force_wall: bool = True
    depots: int = 2
    barracks: int = 1


@dataclass(frozen=True)
class StrategyConfig:
    name: str = "default"

    economy: EconomyCfg = EconomyCfg()
    production: ProductionCfg = ProductionCfg()
    behaviors: BehaviorsCfg = BehaviorsCfg()

    # NATURAL wall como parâmetro da build (mantido)
    wall_natural: bool = False

    # NOVO: opener obrigatório (main wall)
    opener: OpenerCfg = OpenerCfg()

    drops: List[DropCfg] = field(default_factory=list)

    build: List[Dict[str, Any]] = field(default_factory=list)
    production_rules: List[Dict[str, Any]] = field(default_factory=list)

# ---------- bot/strats/default.json ----------
#bot/strats/default.json
{
    "name": "default",
    "opener": {
        "enabled": true,
        "force_wall": true,
        "depots": 2,
        "barracks": 1
    },
    "economy": {
        "scv_target": 40,
        "depot_trigger_supply_left": 3
    },
    "production": {
        "marine_cap": 40
    },
    "behaviors": {
        "macro": {
            "enabled": true,
            "auto_workers": true,
            "auto_scv": true,
            "auto_supply": true
        },
        "combat": {
            "enabled": false
        }
    },
    "drops": [
        {
            "enabled": true,
            "name": "drop_main",
            "start_time": 240.0,
            "min_marines": 8,
            "load_count": 8,
            "move_eps": 3.0,
            "ground_radius": 12.0,
            "staging": "ENEMY_NATURAL",
            "target": "ENEMY_MAIN",
            "staging_dist": 18.0,
            "require_stim": false,
            "marine_select_maxd": 140.0,
            "gather_radius": 16.0
        },
        {
            "enabled": true,
            "name": "drop_natural",
            "start_time": 240.0,
            "min_marines": 8,
            "load_count": 8,
            "move_eps": 3.0,
            "ground_radius": 12.0,
            "staging": "ENEMY_NATURAL",
            "target": "ENEMY_NATURAL",
            "staging_dist": 18.0,
            "require_stim": false,
            "marine_select_maxd": 140.0,
            "gather_radius": 16.0
        }
    ],
    "build": [
        {
            "name": "cc_natural_2",
            "requires": {
                "ready_gte": {
                    "BARRACKS": 1
                }
            },
            "when": {
                "have_lte": {
                    "COMMANDCENTER": 1
                },
                "minerals_gte": 400
            },
            "do": {
                "build": "COMMANDCENTER",
                "near": "MY_NATURAL"
            }
        },
        {
            "name": "refinery_1_after_rax",
            "requires": {
                "ready_gte": {
                    "BARRACKS": 1
                }
            },
            "when": {
                "have_lte": {
                    "REFINERY": 0
                },
                "minerals_gte": 75
            },
            "do": {
                "build": "REFINERY"
            }
        },
        {
            "name": "refinery_2_after_ref1",
            "requires": {
                "ready_gte": {
                    "REFINERY": 1
                }
            },
            "when": {
                "have_lte": {
                    "REFINERY": 1
                },
                "minerals_gte": 75
            },
            "do": {
                "build": "REFINERY"
            }
        },
        {
            "name": "barracks_2",
            "requires": {
                "ready_gte": {
                    "BARRACKS": 1
                }
            },
            "when": {
                "have_lte": {
                    "BARRACKS": 1
                },
                "minerals_gte": 150
            },
            "do": {
                "build": "BARRACKS"
            }
        },
        {
            "name": "factory_1",
            "requires": {
                "ready_gte": {
                    "BARRACKS": 1
                }
            },
            "when": {
                "have_lte": {
                    "FACTORY": 0
                },
                "minerals_gte": 150
            },
            "do": {
                "build": "FACTORY"
            }
        },
        {
            "name": "starport_1",
            "requires": {
                "ready_gte": {
                    "FACTORY": 1
                }
            },
            "when": {
                "have_lte": {
                    "STARPORT": 0
                },
                "minerals_gte": 150,
                "gas_gte": 100
            },
            "do": {
                "build": "STARPORT"
            }
        }
    ],
    "production_rules": [
        {
            "name": "medivacs_2",
            "requires": {
                "ready_gte": {
                    "STARPORT": 1
                }
            },
            "when": {
                "unit_lte": {
                    "MEDIVAC": 2
                }
            },
            "do": {
                "train": "MEDIVAC",
                "from": "STARPORT",
                "cap": 2
            }
        },
        {
            "name": "marines_cap_32",
            "requires": {
                "ready_gte": {
                    "BARRACKS": 1
                }
            },
            "when": {
                "unit_lte": {
                    "MARINE": 32
                }
            },
            "do": {
                "train": "MARINE",
                "from": "BARRACKS",
                "cap": 32
            }
        }
    ]
}

# ---------- bot/strats/future.json ----------
#bot/strats/future.json
{
  "name": "default",
  "initial_state": "NORMAL",
  "states": {
    "NORMAL": {
      "priority": [
        "macro",
        "plan",
        "drop",
        "combat"
      ],
      "macro": {
        "enabled": true,
        "auto_workers": true,
        "auto_scv": true,
        "auto_supply": true,
        "scv_target": 20,
        "depot_trigger_supply_left": 2
      },
      "drop": {
        "enabled": false
      },
      "combat": {
        "enabled": false
      },
      "plan": {
        "opener": [
          {
            "when": {
              "supply_used_gte": 12
            },
            "do": {
              "build": "SUPPLYDEPOT"
            }
          },
          {
            "when": {
              "ready_gte": {
                "SUPPLYDEPOT": 1
              }
            },
            "do": {
              "build": "BARRACKS"
            }
          },
          {
            "when": {
              "ready_gte": {
                "BARRACKS": 1
              }
            },
            "do": {
              "build": "REFINERY"
            }
          },
          {
            "when": {
              "ready_gte": {
                "BARRACKS": 1
              }
            },
            "do": {
              "build": "FACTORY"
            }
          }
        ]
      }
    }
  },
  "transitions": []
}

# ---------- bot/terran_bot.py ----------
#bot/terran_bot.py
#bot/terran_bot.py
from __future__ import annotations

from sc2.bot_ai import BotAI

from bot.core.state import BotState
from bot.core.logger import JsonlLogger
from bot.core.unit_manager import UnitManager

from bot.engine.economy import Economy
from bot.engine.placement import Placement
from bot.engine.builder import Builder

from bot.engine.locations import LocationsService  # NEW

from bot.strategy.loader import load_strategy
from bot.strategy.plan_executor import PlanExecutor

from bot.behaviors.macro import MacroBehavior
from bot.behaviors.drop import DropBehavior
from bot.behaviors.combat import CombatBehavior
from bot.behaviors.plan import PlanBehavior
from bot.behaviors.orchestrator import BehaviorOrchestrator


class TerranBot(BotAI):
    def __init__(self, strat_name: str = "default", debug: bool = True):
        super().__init__()
        self.debug = debug
        self.ctx = BotState()

        self.log = JsonlLogger(enabled=True)
        self.strategy = load_strategy(strat_name)
        self.log.emit("bot_init", {"strategy": self.strategy.name, "strat_name": str(strat_name)})

        # Fonte única da verdade para main/natural/enemy main/enemy natural (por PATHING)
        self.locations = LocationsService(self, ctx=self.ctx, logger=self.log, debug=debug)

        # atributos “legados” (serão preenchidos pelo LocationsService)
        self.cached_main_expansion = None
        self.cached_natural_expansion = None
        self.cached_enemy_main_expansion = None
        self.cached_enemy_natural_expansion = None

        self.econ = Economy(self, ctx=self.ctx, logger=self.log)

        self.place = Placement(
            self,
            ctx=self.ctx,
            logger=self.log,
            wall_main=True,
            wall_natural=bool(getattr(self.strategy, "wall_natural", False)),
            debug=debug,
        )

        self.builder = Builder(self, self.econ, self.place, self.ctx, logger=self.log)
        self.unitmgr = UnitManager(self, self.ctx, logger=self.log, debug=debug)

        self.macro = MacroBehavior(self, self.econ, self.builder, ctx=self.ctx, logger=self.log, debug=debug)

        self.plan_exec = PlanExecutor(self, self.builder, self.strategy, ctx=self.ctx, logger=self.log)
        self.plan = PlanBehavior(self.plan_exec)

        self.combat = CombatBehavior(self, self.ctx, logger=self.log, debug=debug)

        self.drop_pairs: list[tuple[DropBehavior, dict]] = []
        for dc in getattr(self.strategy, "drops", []):
            drop_id = str(getattr(dc, "name", "") or "drop").strip() or "drop"
            beh = DropBehavior(self, self.ctx, self.unitmgr, drop_id=drop_id, logger=self.log, debug=debug)
            self.drop_pairs.append((beh, {"drop": dc}))

        self.orch = BehaviorOrchestrator()
        self._last_snapshot_iter = -999999

    def _active_pairs(self):
        pairs = [
            (self.plan, {"strategy": self.strategy}),
            (self.macro, {"econ": self.strategy.economy, "macro": self.strategy.behaviors.macro}),
        ]
        for beh, cfg in self.drop_pairs:
            pairs.append((beh, cfg))
        pairs.append((self.combat, {"combat": self.strategy.behaviors.combat}))
        return pairs

    def _compute_budget(self) -> int:
        drops = getattr(self.strategy, "drops", [])
        enabled_drops = sum(1 for d in drops if getattr(d, "enabled", False))
        return 2 if enabled_drops >= 2 else 1

    async def on_step(self, iteration: int):
        self.ctx.iteration = int(iteration)
        self.unitmgr.begin_tick(int(iteration))

        # ÚNICO lugar onde main/natural/enemy main/enemy natural é calculado
        await self.locations.recalc_if_needed(int(iteration))

        if iteration - self._last_snapshot_iter >= 22:
            self._last_snapshot_iter = iteration
            self.log.emit(
                "snapshot",
                {
                    "iteration": int(iteration),
                    "time": float(self.time),
                    "minerals": int(self.minerals),
                    "gas": int(self.vespene),
                    "supply_used": int(self.supply_used),
                    "supply_cap": int(self.supply_cap),
                    "supply_left": int(self.supply_left),
                    "workers": int(self.workers.amount),
                },
                meta={"strategy": self.strategy.name, "iter": int(self.ctx.iteration)},
            )

        self.orch.set_active(self._active_pairs())
        await self.orch.step(budget_actions=self._compute_budget())

    async def on_end(self, game_result):
        self.log.emit("game_end", {"result": str(game_result), "time": float(self.time)})
        self.log.close()

# ---------- run.py ----------
#run.py
import argparse
import asyncio
import logging
import aiohttp
import os
import sc2
from sc2.main import run_game
from sc2.data import Race, Difficulty
from sc2.client import Client
from sc2.player import Bot, Computer
from sc2.protocol import ConnectionAlreadyClosed
import random

from bot import CompetitiveBot
from config import BOT_NAME, BOT_RACE, MAP_POOL, MAP_PATH, OPPONENT_RACE, OPPONENT_DIFFICULTY, REALTIME, REPLAY_SAVE_PATH
from sc2.data import Race, Difficulty


# Run ladder game
# This lets python-sc2 connect to a ladder game.
# Based on: https://github.com/Dentosal/python-sc2/blob/master/examples/run_external.py
def run_ladder_game(args, bot):
    if args.LadderServer == None:
        host = "127.0.0.1"
    else:
        host = args.LadderServer

    host_port = args.GamePort
    lan_port = args.StartPort

    # Port config
    ports = [lan_port + p for p in range(1, 6)]

    portconfig = sc2.portconfig.Portconfig
    portconfig.shared = ports[0]  # Not used
    portconfig.server = [ports[1], ports[2]]
    portconfig.players = [[ports[3], ports[4]]]

    # Join ladder game
    g = join_ladder_game(host=host, port=host_port, players=[bot], realtime=args.Realtime, portconfig=portconfig)

    # Ensure replay directory exists
    if REPLAY_SAVE_PATH and not os.path.exists(REPLAY_SAVE_PATH):
        os.makedirs(REPLAY_SAVE_PATH, exist_ok=True)
    
    # Run the game
    result = asyncio.get_event_loop().run_until_complete(g)
    
    # Save replay if we have a path and a result
    if result and REPLAY_SAVE_PATH:
        replay_path = os.path.join(REPLAY_SAVE_PATH, f"{BOT_NAME}_vs_{args.OpponentId}.SC2Replay")
        try:
            result.save_replay(replay_path)
            print(f"Replay saved to: {replay_path}")
        except Exception as e:
            print(f"Failed to save replay: {e}")
    
    return result, args.OpponentId


# Modified version of sc2.main._join_game to allow custom host and port, and to not spawn an additional sc2process (thanks to alkurbatov for fix)
async def join_ladder_game(
        host, port, players, realtime, portconfig, save_replay_as=None, step_time_limit=None, game_time_limit=None
):
    ws_url = "ws://{}:{}/sc2api".format(host, port)
    ws_connection = await aiohttp.ClientSession().ws_connect(ws_url, timeout=120)
    client = Client(ws_connection)
    try:
        result = await sc2.main._play_game(players[0], client, realtime, portconfig, step_time_limit, game_time_limit)
        if save_replay_as is not None:
            await client.save_replay(save_replay_as)
        # await client.leave()
        # await client.quit()
    except ConnectionAlreadyClosed:
        logging.error(f"Connection was closed before the game ended")
        return None
    finally:
        await ws_connection.close()

    return result


def parse_arguments():
    # Load command line arguments
    parser = argparse.ArgumentParser()

    # Ladder play arguments
    parser.add_argument("--GamePort", type=int, help="Game port.")
    parser.add_argument("--StartPort", type=int, help="Start port.")
    parser.add_argument("--LadderServer", type=str, help="Ladder server.")

    # Bot settings
    parser.add_argument("--bot-name", type=str, default=BOT_NAME,
                       help=f"Name of your bot. Default: {BOT_NAME}")
    parser.add_argument("--bot-race", type=str, default=BOT_RACE,
                       help=f"Bot race (Terran, Zerg, Protoss, Random). Default: {BOT_RACE}")
    
    # Game settings
    parser.add_argument("--map", type=str, default=None,
                       help=f"Map to play on. If not specified, a random map will be selected from: {', '.join(MAP_POOL)}")
    parser.add_argument("--opponent-race", type=str, default=OPPONENT_RACE,
                       help=f"Computer race (Terran, Zerg, Protoss, Random). Default: {OPPONENT_RACE}")
    parser.add_argument("--difficulty", type=str, default=OPPONENT_DIFFICULTY,
                       help=f"Computer difficulty (VeryEasy to VeryHard). Default: {OPPONENT_DIFFICULTY}")
    parser.add_argument("--realtime", action='store_true', default=REALTIME,
                       help=f"Play in realtime. Default: {REALTIME}")
    parser.add_argument("--sc2-version", type=str, help="Starcraft 2 game version (optional)")

    args, unknown_args = parser.parse_known_args()

    for unknown_arg in unknown_args:
        print(f"Unknown argument: {unknown_arg}")

    # Set default opponent ID if not provided
    if not hasattr(args, 'OpponentId') or not args.OpponentId:
        args.OpponentId = f"{args.opponent_race}_{args.difficulty}"

    return args


def load_bot(args):
    """Initialize and configure the bot."""
    # Create bot instance
    bot = CompetitiveBot()

    # Convert string race to Race enum
    try:
        bot_race = Race[args.bot_race.capitalize()]
    except KeyError:
        print(f"Invalid bot race: {args.bot_race}. Using Terran.")
        bot_race = Race.Terran

    # Return configured bot
    return Bot(bot_race, bot)


def run():
    """Legacy run function - kept for compatibility."""
    print("Warning: Using legacy run() function. Consider updating your code.")
    main()


def main():
    """Main function to run the bot."""
    # Parse command line arguments
    args = parse_arguments()
    
    # Simple console logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(message)s",
    )
    
    # Get bot name and race from args (with fallback to config)
    bot_name = getattr(args, 'bot_name', BOT_NAME)
    bot_race = getattr(args, 'bot_race', BOT_RACE)
    
    print(f"===== {bot_name} ({bot_race}) =====")
    print(f"Available maps: {', '.join(MAP_POOL)}")
    print(f"Opponent: {args.opponent_race} {args.difficulty}")
    print(f"Realtime: {'Yes' if args.realtime else 'No'}")

    try:
        # Load and run the bot
        bot = load_bot(args)

        # Convert string to Race and Difficulty enums for opponent
        try:
            opponent_race = Race[args.opponent_race.capitalize()]
        except KeyError:
            print(f"Invalid opponent race: {args.opponent_race}. Using Terran.")
            opponent_race = Race.Terran
        try:
            difficulty = Difficulty[args.difficulty]
        except KeyError:
            print(f"Invalid difficulty: {args.difficulty}. Using VeryHard.")
            difficulty = Difficulty.VeryHard

        # Select a random map if none specified
        map_name = args.map if args.map else random.choice(MAP_POOL)

        # Get map from specified path or default SC2 maps
        if MAP_PATH and os.path.exists(MAP_PATH):
            try:
                print(f"Loading map from custom path: {MAP_PATH}")
                # Use the map_dir parameter directly with the full Maps path
                map_obj = sc2.maps.get(map_name, map_dir=MAP_PATH)
            except Exception as e:
                print(f"Error loading custom map: {e}")
                print("Falling back to default SC2 maps...")
                map_obj = sc2.maps.get(map_name)
        else:
            map_obj = sc2.maps.get(map_name)

        # Start a local game
        print(f"\nStarting game on {map_name}...")
        run_game(
            map_obj,
            [bot, Computer(opponent_race, difficulty)],
            realtime=args.realtime,
            sc2_version=args.sc2_version if hasattr(args, 'sc2_version') else None
        )
    except KeyboardInterrupt:
        print("\nGame stopped by user")
    except Exception as e:
        print(f"\nAn error occurred: {e}")
        if __debug__:
            import traceback
            traceback.print_exc()
        return 1
    return 0

if __name__ == "__main__":
    import sys
    sys.exit(main())
