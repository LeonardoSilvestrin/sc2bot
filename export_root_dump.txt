===== PROJECT TREE =====
.
├── .github
│   └── workflows
│       ├── build_windows_exe.yaml
│       └── ladder_zip.yml
├── .vscode1
│   ├── launch.json
│   └── settings.json
├── bot
│   ├── policies
│   │   ├── drop.py
│   │   └── threat.py
│   ├── __init__.py
│   ├── devlog.py
│   └── main.py
├── data
│   └── None-protoss.json
├── logs
│   ├── MyBot__Ley_Lines_AIE__vs__Protoss__start.jsonl
│   ├── MyBot__Ley_Lines_AIE__vs__Terran__start.jsonl
│   ├── MyBot__Persephone_AIE__vs__Terran__start.jsonl
│   └── MyBot__Torches_AIE__vs__Terran__start.jsonl
├── scripts
│   ├── create_ladder_zip.py
│   ├── create_pyinstaller_exe.py
│   ├── update_ares.py
│   └── upload_to_ai_arena.py
├── .env
├── .gitignore
├── .gitmodules
├── config.yml
├── export_prompt_root.py
├── export_root_dump.txt
├── ladder.py
├── LICENSE
├── poetry.lock
├── protoss_builds.yml
├── pyproject.toml
├── README.md
├── run.py
└── terran_builds.yml

===== bot/*.py (FULL CONTENT) =====

# bot/__init__.py
```python

```

# bot/devlog.py
```python
#bot/devlog.py
from __future__ import annotations

import json
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Dict, Optional


@dataclass
class DevLogger:
    """
    Logger JSONL simples (1 evento por linha).
    Objetivo: você conseguir auditar decisões ("flags") pós-partida.
    """

    log_dir: str = "logs"
    filename: Optional[str] = None
    enabled: bool = True

    def _ensure_dir(self) -> None:
        os.makedirs(self.log_dir, exist_ok=True)

    def set_file(self, filename: str) -> None:
        self.filename = filename

    def emit(self, event: str, payload: Optional[Dict[str, Any]] = None, *, meta: Optional[Dict[str, Any]] = None) -> None:
        if not self.enabled:
            return
        if not self.filename:
            # Se esquecer de setar, não explode o jogo.
            return

        self._ensure_dir()
        row = {
            "ts_utc": datetime.now(timezone.utc).isoformat(),
            "event": event,
            "payload": payload or {},
            "meta": meta or {},
        }
        path = os.path.join(self.log_dir, self.filename)
        try:
            with open(path, "a", encoding="utf-8") as f:
                f.write(json.dumps(row, ensure_ascii=False) + "\n")
        except Exception:
            # logging nunca pode matar o bot
            pass
```

# bot/main.py
```python
#bot/main.py
from __future__ import annotations

import os
from typing import Optional

from ares import AresBot
from sc2.data import Result

from bot.devlog import DevLogger
from bot.policies.drop import DropPolicy
from bot.policies.threat import ThreatPolicy


class MyBot(AresBot):
    def __init__(self, game_step_override: Optional[int] = None, *, debug: bool = True):
        super().__init__(game_step_override)
        self.debug = debug

        # policies
        self.threat_policy = ThreatPolicy(defend_radius=22.0, min_enemy=1)
        self.drop_policy = DropPolicy(enabled=True, min_marines=8, load_count=8)

        # devlog
        self.log = DevLogger(enabled=True)

    async def on_start(self) -> None:
        await super().on_start()

        # log file por partida
        # tenta um nome estável; se faltar info, usa timestamp
        map_name = getattr(self.game_info.map_name, "name", None) or str(getattr(self.game_info, "map_name", "map"))
        enemy = "opponent"
        try:
            enemy = self.enemy_race.name if self.enemy_race else "opponent"
        except Exception:
            pass

        fname = f"MyBot__{map_name}__vs__{enemy}__{int(self.time)}.jsonl".replace(" ", "_")
        # se "int(self.time)" vier 0 no start, usa path fallback
        if fname.endswith("__0.jsonl"):
            fname = f"MyBot__{map_name}__vs__{enemy}__start.jsonl".replace(" ", "_")

        self.log.set_file(fname)

        if self.debug:
            print("[on_start] Ares build runner enabled")
            print(f"[on_start] devlog={os.path.join(self.log.log_dir, fname)}")

        self.log.emit("bot_init", {"strategy": "terran_builds.yml/Default"}, meta={"map": map_name})

    async def on_step(self, iteration: int) -> None:
        await super().on_step(iteration)

        # Enquanto a opening do Ares não terminou, não faça macro/combate paralelos
        if not self.build_order_runner.build_completed:
            if self.debug and iteration % 22 == 0:
                print(
                    f"[opening] iter={iteration} "
                    f"t={self.time:.1f} "
                    f"m={int(self.minerals)} g={int(self.vespene)} "
                    f"s={int(self.supply_used)}/{int(self.supply_cap)}"
                )
            if iteration % 44 == 0:
                self.log.emit(
                    "opening_tick",
                    {
                        "iteration": iteration,
                        "time": round(self.time, 2),
                        "minerals": int(self.minerals),
                        "gas": int(self.vespene),
                        "supply_used": int(self.supply_used),
                        "supply_cap": int(self.supply_cap),
                    },
                )
            return

        # ----------------------------
        # Pós-opening: policies
        # Ordem importa:
        #   1) Threat: não morrer
        #   2) Drop: fazer algo agressivo sem depender de “A-move cego”
        # ----------------------------

        # Threat
        threat_report = self.threat_policy.evaluate(self)
        if threat_report.threatened:
            acted = await self.threat_policy.act(self, threat_report)
            if acted:
                self.log.emit(
                    "threat_defend",
                    {
                        "iteration": iteration,
                        "time": round(self.time, 2),
                        "enemy_count": threat_report.enemy_count,
                        "radius": threat_report.radius,
                        "pos": [round(threat_report.threat_pos.x, 1), round(threat_report.threat_pos.y, 1)]
                        if threat_report.threat_pos
                        else None,
                    },
                )

        # Drop (só tenta se não estiver em ameaça imediata forte)
        # Heurística seca: se tem ameaça, prioriza defesa e não inicia drop.
        if not threat_report.threatened:
            drop_acted = await self.drop_policy.act(self)
            if drop_acted and iteration % 11 == 0:
                self.log.emit(
                    "drop_tick",
                    {
                        "iteration": iteration,
                        "time": round(self.time, 2),
                        "phase": str(self.drop_policy.state.phase),
                    },
                )

        if self.debug and iteration % 44 == 0:
            print(
                f"[post_opening] iter={iteration} "
                f"t={self.time:.1f} "
                f"m={int(self.minerals)} g={int(self.vespene)} "
                f"s={int(self.supply_used)}/{int(self.supply_cap)} "
                f"threat={threat_report.threatened} "
                f"drop={self.drop_policy.state.phase}"
            )

    async def on_end(self, game_result: Result) -> None:
        await super().on_end(game_result)
        if self.debug:
            print(f"[game_end] result={game_result}")
        self.log.emit("game_end", {"result": str(game_result)})
```

# bot/policies/drop.py
```python
#bot/policies/drop.py
from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Optional

from sc2.ids.ability_id import AbilityId as A
from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2
from sc2.unit import Unit


class DropPhase(str, Enum):
    IDLE = "IDLE"
    STAGING = "STAGING"
    LOADING = "LOADING"
    FLYING = "FLYING"
    DROPPING = "DROPPING"
    FIGHTING = "FIGHTING"
    EVAC = "EVAC"
    RESET = "RESET"


@dataclass
class DropState:
    phase: DropPhase = DropPhase.IDLE
    medivac_tag: Optional[int] = None
    started_at: float = 0.0
    last_transition_at: float = 0.0
    target_pos: Optional[Point2] = None
    staging_pos: Optional[Point2] = None


class DropPolicy:
    """
    Drop básico e robusto (estado + timeout).
    Meta: bot fazer algo perigoso *sem travar*.

    Premissas:
      - Terran
      - Medivac + Marines
    """

    def __init__(
        self,
        *,
        enabled: bool = True,
        min_marines: int = 8,
        load_count: int = 8,
        stage_radius: float = 10.0,
        phase_timeout: float = 35.0,
        fight_time: float = 10.0,
    ):
        self.enabled = enabled
        self.min_marines = min_marines
        self.load_count = load_count
        self.stage_radius = stage_radius
        self.phase_timeout = phase_timeout
        self.fight_time = fight_time
        self.state = DropState()

    def _enemy_main_like(self, bot) -> Optional[Point2]:
        # Melhor esforço:
        # - se o bot já viu enemy_start_locations, usa o primeiro
        try:
            if bot.enemy_start_locations:
                return bot.enemy_start_locations[0]
        except Exception:
            pass
        return None

    def _default_staging(self, bot) -> Optional[Point2]:
        # staging perto da natural/main, evitando ficar no meio do mapa
        try:
            if bot.townhalls:
                th = bot.townhalls.closest_to(bot.start_location)
                return th.position.towards(bot.game_info.map_center, 6)
        except Exception:
            pass
        return bot.start_location.towards(bot.game_info.map_center, 6)

    def _get_medivac(self, bot) -> Optional[Unit]:
        if self.state.medivac_tag:
            m = bot.units.find_by_tag(self.state.medivac_tag)
            if m and m.is_alive:
                return m

        medivacs = bot.units(U.MEDIVAC)
        if medivacs.amount == 0:
            return None

        # escolhe um medivac relativamente "livre"
        m = medivacs.sorted(lambda x: x.cargo_used)[0]
        self.state.medivac_tag = m.tag
        return m

    def _phase_timed_out(self, bot) -> bool:
        if self.state.phase in (DropPhase.IDLE, DropPhase.RESET):
            return False
        return (bot.time - self.state.last_transition_at) > self.phase_timeout

    def _transition(self, bot, phase: DropPhase) -> None:
        self.state.phase = phase
        if self.state.started_at == 0.0:
            self.state.started_at = bot.time
        self.state.last_transition_at = bot.time

    def evaluate(self, bot) -> bool:
        if not self.enabled:
            return False

        # Só tenta se tiver recursos mínimos
        if bot.units(U.MEDIVAC).amount < 1:
            return False

        marines = bot.units(U.MARINE)
        if marines.amount < self.min_marines:
            return False

        # precisa ter target
        target = self._enemy_main_like(bot)
        if not target:
            return False

        return True

    async def act(self, bot) -> bool:
        """
        Retorna True se emitiu comando.
        """
        if not self.evaluate(bot):
            # Se não dá pra dropar, reseta state pra não ficar "preso"
            self.state = DropState()
            return False

        if self._phase_timed_out(bot):
            self._transition(bot, DropPhase.RESET)

        target = self._enemy_main_like(bot)
        staging = self._default_staging(bot)
        if not target or not staging:
            return False

        self.state.target_pos = target
        self.state.staging_pos = staging

        m = self._get_medivac(bot)
        if not m:
            return False

        marines = bot.units(U.MARINE)
        if marines.amount == 0:
            return False

        issued = False

        # -----------------------
        # State machine
        # -----------------------
        if self.state.phase == DropPhase.IDLE:
            self._transition(bot, DropPhase.STAGING)

        if self.state.phase == DropPhase.STAGING:
            # junta marines e medivac no staging
            pack = marines.closest_n_units(staging, self.load_count)
            for u in pack:
                if u.distance_to(staging) > self.stage_radius:
                    u.move(staging)
                    issued = True

            if m.distance_to(staging) > self.stage_radius:
                m.move(staging)
                issued = True

            # pronto pra carregar se o pack estiver perto
            if pack.amount >= self.load_count and pack.center.distance_to(staging) <= self.stage_radius:
                self._transition(bot, DropPhase.LOADING)

        if self.state.phase == DropPhase.LOADING:
            pack = marines.closest_n_units(m.position, self.load_count)

            # se medivac já cheio o suficiente, parte
            if m.cargo_used >= self.load_count:
                self._transition(bot, DropPhase.FLYING)
            else:
                # manda os marines entrarem no medivac (load)
                # cuidado: python-sc2 faz o order no próprio marine com AbilityId.LOAD_MEDIVAC
                for u in pack:
                    if u.is_alive and u.distance_to(m) <= 5:
                        u( A.LOAD_MEDIVAC, m )
                        issued = True
                    elif u.is_alive:
                        u.move(m.position)
                        issued = True

        if self.state.phase == DropPhase.FLYING:
            # vai para um ponto próximo do alvo pra evitar cair em cima de torre/canhões
            approach = target.towards(bot.game_info.map_center, -6)
            if m.distance_to(approach) > 4:
                m.move(approach)
                issued = True
            else:
                self._transition(bot, DropPhase.DROPPING)

        if self.state.phase == DropPhase.DROPPING:
            # unload all
            if m.cargo_used > 0:
                m( A.UNLOADALLAT_MEDIVAC, m.position.towards(target, 3) )
                issued = True
            self._transition(bot, DropPhase.FIGHTING)

        if self.state.phase == DropPhase.FIGHTING:
            # manda marines atacar algo por um tempo curto e depois evacuar
            fight_elapsed = bot.time - self.state.last_transition_at
            local_marines = bot.units(U.MARINE).closer_than(18, m.position)

            # Se não viu nada, ataca o target "as cegas"
            if bot.enemy_units.closer_than(18, m.position).amount > 0:
                enemy = bot.enemy_units.closer_than(18, m.position).closest_to(m.position)
                for u in local_marines:
                    if u.is_idle:
                        u.attack(enemy)
                        issued = True
            else:
                for u in local_marines:
                    if u.is_idle:
                        u.attack(target)
                        issued = True

            if fight_elapsed >= self.fight_time:
                self._transition(bot, DropPhase.EVAC)

        if self.state.phase == DropPhase.EVAC:
            # tenta recolher os marines próximos
            local_marines = bot.units(U.MARINE).closer_than(10, m.position)
            if m.cargo_used < m.cargo_max and local_marines.amount > 0:
                for u in local_marines:
                    if u.is_alive and u.distance_to(m) <= 5:
                        u( A.LOAD_MEDIVAC, m )
                        issued = True
                    elif u.is_alive:
                        u.move(m.position)
                        issued = True

            # volta pra staging e reseta quando chegar
            if m.distance_to(staging) > 6:
                m.move(staging)
                issued = True
            else:
                self._transition(bot, DropPhase.RESET)

        if self.state.phase == DropPhase.RESET:
            # reset total para permitir um próximo drop depois
            self.state = DropState()
            issued = True

        return issued
```

# bot/policies/threat.py
```python
#bot/policies/threat.py
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional, Tuple

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2
from sc2.unit import Unit


@dataclass
class ThreatReport:
    threatened: bool
    threat_pos: Optional[Point2]
    enemy_count: int
    radius: float


class ThreatPolicy:
    """
    Defesa reativa simples:
      - Detecta inimigos perto de qualquer townhall (CC/OC/PF).
      - Se ameaçado, comanda exército básico para defender.

    Observação: isso NÃO é "boa defesa", é "não morrer de graça".
    """

    def __init__(self, *, defend_radius: float = 22.0, min_enemy: int = 1):
        self.defend_radius = defend_radius
        self.min_enemy = min_enemy

    def _townhalls(self, bot) -> List[Unit]:
        # AresBot herda BotAI => townhalls existe no python-sc2
        try:
            return list(bot.townhalls)
        except Exception:
            return []

    def evaluate(self, bot) -> ThreatReport:
        ths = self._townhalls(bot)
        if not ths:
            return ThreatReport(False, None, 0, self.defend_radius)

        enemies = bot.enemy_units
        if not enemies:
            return ThreatReport(False, None, 0, self.defend_radius)

        best: Tuple[int, Optional[Point2]] = (0, None)
        for th in ths:
            near = enemies.closer_than(self.defend_radius, th.position)
            c = near.amount
            if c > best[0]:
                best = (c, th.position)

        threatened = best[0] >= self.min_enemy
        return ThreatReport(threatened, best[1], best[0], self.defend_radius)

    async def act(self, bot, report: ThreatReport) -> bool:
        """
        Retorna True se emitiu comandos relevantes.
        """
        if not report.threatened or not report.threat_pos:
            return False

        # Grupo de defesa: começa simples (bio)
        defenders = bot.units.of_type(
            {
                U.MARINE,
                U.MARAUDER,
                U.SIEGETANK,
                U.SIEGETANKSIEGED,
                U.HELLION,
                U.HELLBAT,
                U.CYCLONE,
                U.THOR,
                U.THORAP,
                U.MEDIVAC,
            }
        )

        if defenders.amount == 0:
            return False

        # Não puxa tudo do mapa inteiro; só quem está relativamente perto
        local = defenders.closer_than(45, report.threat_pos)
        if local.amount == 0:
            # fallback: puxa tudo
            local = defenders

        # Medivac não precisa suicidar: manda seguir/ir para trás levemente
        medivacs = local(U.MEDIVAC)
        army = local - medivacs

        issued = False
        for u in army:
            if u.is_idle:
                u.attack(report.threat_pos)
                issued = True

        for m in medivacs:
            if m.is_idle:
                m.move(report.threat_pos.towards(bot.start_location, 6))
                issued = True

        return issued
```

===== terran_builds.yml (ROOT) =====

# terran_builds.yml
```yaml
UseData: False
BuildSelection: Cycle
MinGamesWinrateBased: 3

BuildChoices:
  Protoss:
    BotName: BoiBandido
    Cycle:
      - Default
  Terran:
    BotName: BoiBandido
    Cycle:
      - Default
  Zerg:
    BotName: BoiBandido
    Cycle:
      - Default
  Random:
    BotName: BoiBandido
    Cycle:
      - Default

Builds:
  Default:
    ConstantWorkerProductionTill: 20
    AutoSupplyAtSupply: 16
    OpeningBuildOrder:
      - 14 supply @ ramp
      - 16 barracks @ ramp
      - 16 gas
      - 0 orbital
      - 19 expand
      - 20 marine *2
      - 1 factory
      - 21 gas
      - 1 starport
```
