===== PROJECT TREE =====
.
├── .github
│   └── workflows
│       ├── build_windows_exe.yaml
│       └── ladder_zip.yml
├── .vscode1
│   ├── launch.json
│   └── settings.json
├── bot
│   ├── actions
│   │   ├── __init__.py
│   │   ├── anchor_tank.py
│   │   ├── base.py
│   │   ├── defend.py
│   │   ├── drop.py
│   │   ├── macro.py
│   │   └── scout.py
│   ├── config
│   │   ├── __init__.py
│   │   ├── loader.py
│   │   └── schema.py
│   ├── core
│   │   ├── __init__.py
│   │   ├── allocator.py
│   │   ├── blackboard.py
│   │   ├── context.py
│   │   └── orchestrator.py
│   ├── policies
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── drop.py
│   │   ├── scout.py
│   │   ├── strategy.py
│   │   └── threat.py
│   ├── services
│   │   ├── __init__.py
│   │   ├── grid.py
│   │   ├── map.py
│   │   ├── query.py
│   │   ├── roles.py
│   │   └── workers.py
│   ├── utils
│   │   ├── __init__.py
│   │   ├── geometry.py
│   │   └── time.py
│   ├── __init__.py
│   ├── devlog.py
│   └── main.py
├── data
│   └── None-protoss.json
├── logs
│   ├── MyBot__Ley_Lines_AIE__vs__Protoss__start.jsonl
│   ├── MyBot__Ley_Lines_AIE__vs__Zerg__start.jsonl
│   ├── MyBot__Persephone_AIE__vs__Terran__start.jsonl
│   └── MyBot__Torches_AIE__vs__Protoss__start.jsonl
├── scripts
│   ├── create_ladder_zip.py
│   ├── create_pyinstaller_exe.py
│   ├── update_ares.py
│   └── upload_to_ai_arena.py
├── .env
├── .gitignore
├── .gitmodules
├── config.yml
├── export_prompt_root.py
├── export_root_dump.txt
├── ladder.py
├── LICENSE
├── poetry.lock
├── protoss_builds.yml
├── pyproject.toml
├── README.md
├── run.py
└── terran_builds.yml

===== bot/*.py (FULL CONTENT) =====

# bot/__init__.py
```python

```

# bot/actions/__init__.py
```python

```

# bot/actions/anchor_tank.py
```python
#bot/actions/anchor_tank.py

class AnchorTankAction:
    """Ação para posicionar siege tank em choke."""
    pass
```

# bot/actions/base.py
```python
#bot/actions/base.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Protocol


@dataclass
class TickContext:
    iteration: int
    time: float
    opening_done: bool
    threatened: bool


class Action(Protocol):
    name: str
    priority: int
    allow_during_opening: bool

    def is_done(self) -> bool: ...
    async def step(self, bot, ctx: TickContext) -> bool: ...
```

# bot/actions/defend.py
```python
#bot/actions/defend.py

class DefendAction:
    """Ação de defesa."""
    pass
```

# bot/actions/drop.py
```python
#bot/actions/drop.py

class DropAction:
    """Ação de drop."""
    pass
```

# bot/actions/macro.py
```python
#bot/actions/macro.py

class MacroAction:
    """Ação de manutenção macro."""
    pass
```

# bot/actions/scout.py
```python
#bot/actions/scout.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

from ares.consts import UnitRole
from sc2.position import Point2
from sc2.unit import Unit


@dataclass
class ScoutState:
    dispatched: bool = False
    arrived: bool = False
    scout_tag: Optional[int] = None
    last_seen_log_at: float = 0.0


class ScoutAction:
    name = "scout_main_scv"
    priority = 30
    allow_during_opening = True

    def __init__(self, *, trigger_time: float = 25.0, log_every: float = 6.0, see_radius: float = 14.0):
        self.trigger_time = trigger_time
        self.log_every = log_every
        self.see_radius = see_radius
        self.state = ScoutState()

    def is_done(self) -> bool:
        # Scout “não termina” por enquanto; ele continua reportando até morrer.
        return False

    def _enemy_main(self, bot) -> Point2:
        return bot.enemy_start_locations[0]

    def _get_scout(self, bot) -> Optional[Unit]:
        if self.state.scout_tag is None:
            return None
        return bot.units.find_by_tag(self.state.scout_tag)


    async def step(self, bot, ctx) -> bool:
        target = self._enemy_main(bot)

        # 1) Só dispara após trigger_time
        if not self.state.dispatched:
            if bot.time < self.trigger_time:
                return False

            # pega worker via Ares
            worker: Unit = bot.mediator.select_worker(target_position=target)

            # marca role scout
            bot.mediator.assign_role(tag=worker.tag, role=UnitRole.BUILD_RUNNER_SCOUT, remove_from_squad=True)

            # envia
            worker.move(target)

            self.state.dispatched = True
            self.state.scout_tag = worker.tag

            bot.log.emit(
                "scout_dispatch",
                {
                    "iteration": ctx.iteration,
                    "time": round(bot.time, 2),
                    "scout_tag": worker.tag,
                    "target": [round(target.x, 1), round(target.y, 1)],
                    "trigger_time": self.trigger_time,
                    "opening_done": ctx.opening_done,
                },
            )
            return True  # consumiu budget (emitimos comando)

        # 2) Pós-dispatch: log do que vê
        scout = self._get_scout(bot)
        if scout is None:
            return False

        # arrived 1x
        if not self.state.arrived and scout.distance_to(target) <= 8:
            self.state.arrived = True
            bot.log.emit(
                "scout_arrived",
                {
                    "iteration": ctx.iteration,
                    "time": round(bot.time, 2),
                    "scout_tag": scout.tag,
                    "pos": [round(scout.position.x, 1), round(scout.position.y, 1)],
                },
            )

        # log structures seen periodically
        if (bot.time - self.state.last_seen_log_at) >= self.log_every:
            self.state.last_seen_log_at = bot.time

            seen = bot.enemy_structures.closer_than(self.see_radius, scout.position)
            payload = {
                "iteration": ctx.iteration,
                "time": round(bot.time, 2),
                "scout_tag": scout.tag,
                "scout_pos": [round(scout.position.x, 1), round(scout.position.y, 1)],
                "count": int(seen.amount),
                "types": [s.type_id.name for s in seen],
                "structures": [
                    {"type": s.type_id.name, "pos": [round(s.position.x, 1), round(s.position.y, 1)], "hp": int(s.health)}
                    for s in seen
                ],
            }
            bot.log.emit("scout_seen_structures", payload)

        return False
```

# bot/config/__init__.py
```python

```

# bot/config/loader.py
```python
#bot/config/loader.py

class ConfigLoader:
    """Carregamento de config externa."""
    pass
```

# bot/config/schema.py
```python
#bot/config/schema.py

class ConfigSchema:
    """Definições de schema para validação."""
    pass
```

# bot/core/__init__.py
```python

```

# bot/core/allocator.py
```python
#bot/core/allocator.py

class Allocator:
    """Responsável por reservar/unlock unidades."""
    pass
```

# bot/core/blackboard.py
```python
#bot/core/blackboard.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

from sc2.position import Point2


@dataclass
class Blackboard:
    opening_done: bool = False
    enemy_main: Optional[Point2] = None
    threatened: bool = False

    @staticmethod
    def build(bot) -> "Blackboard":
        bb = Blackboard()
        try:
            bb.opening_done = bool(getattr(bot.build_order_runner, "build_completed", False))
        except Exception:
            bb.opening_done = False

        # enemy main best-effort
        try:
            if bot.enemy_start_locations:
                bb.enemy_main = bot.enemy_start_locations[0]
        except Exception:
            bb.enemy_main = None

        return bb
```

# bot/core/context.py
```python
#bot/core/context.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Optional

from bot.devlog import DevLogger
from bot.services.roles import RoleService


@dataclass
class BotContext:
    """
    Container de serviços, config e logger.
    A ideia: actions/policies recebem (ctx, bb) e não ficam pescando bot.mediator.
    """
    bot: Any
    log: DevLogger
    roles: RoleService
    cfg: Optional[dict] = None

    @staticmethod
    def from_bot(bot: Any, log: DevLogger, *, cfg: Optional[dict] = None) -> "BotContext":
        return BotContext(
            bot=bot,
            log=log,
            roles=RoleService(bot),
            cfg=cfg,
        )
```

# bot/core/orchestrator.py
```python
#bot/core/orchestrator.py
from __future__ import annotations

from dataclasses import dataclass, field
from typing import List

from bot.actions.base import Action, TickContext


@dataclass
class Orchestrator:
    """
    MVP:
      - Agenda ações por prioridade.
      - Gating por opening (allow_during_opening).
      - Budget de comandos por tick.
      - Preempção simples em ameaça.
    """
    command_budget: int = 2
    defense_floor: int = 80  # se threatened, só roda ações >= isso

    actions: List[Action] = field(default_factory=list)

    def add(self, action: Action) -> None:
        self.actions.append(action)

    async def tick(self, bot, ctx: TickContext) -> None:
        runnable: List[Action] = []

        for a in self.actions:
            if a.is_done():
                continue
            if (not ctx.opening_done) and (not a.allow_during_opening):
                continue
            if ctx.threatened and a.priority < self.defense_floor:
                continue
            runnable.append(a)

        runnable.sort(key=lambda x: x.priority, reverse=True)

        budget = self.command_budget
        for a in runnable:
            if budget <= 0:
                break
            used = await a.step(bot, ctx)
            if used:
                budget -= 1
```

# bot/devlog.py
```python
#bot/devlog.py
from __future__ import annotations

import json
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Dict, Optional


@dataclass
class DevLogger:
    """
    Logger JSONL simples (1 evento por linha).
    Objetivo: você conseguir auditar decisões ("flags") pós-partida.
    """

    log_dir: str = "logs"
    filename: Optional[str] = None
    enabled: bool = True

    def _ensure_dir(self) -> None:
        os.makedirs(self.log_dir, exist_ok=True)

    def set_file(self, filename: str) -> None:
        self.filename = filename

    def emit(self, event: str, payload: Optional[Dict[str, Any]] = None, *, meta: Optional[Dict[str, Any]] = None) -> None:
        if not self.enabled:
            return
        if not self.filename:
            # Se esquecer de setar, não explode o jogo.
            return

        self._ensure_dir()
        row = {
            "ts_utc": datetime.now(timezone.utc).isoformat(),
            "event": event,
            "payload": payload or {},
            "meta": meta or {},
        }
        path = os.path.join(self.log_dir, self.filename)
        try:
            with open(path, "a", encoding="utf-8") as f:
                f.write(json.dumps(row, ensure_ascii=False) + "\n")
        except Exception:
            # logging nunca pode matar o bot
            pass
```

# bot/main.py
```python
#bot/main.py
from __future__ import annotations

import os
from typing import Optional

from ares import AresBot
from sc2.data import Result

from bot.actions.base import TickContext
from bot.actions.scout import ScoutAction
from bot.core.orchestrator import Orchestrator
from bot.devlog import DevLogger
from bot.policies.drop import DropPolicy
from bot.policies.threat import ThreatPolicy


class MyBot(AresBot):
    def __init__(self, game_step_override: Optional[int] = None, *, debug: bool = True):
        super().__init__(game_step_override)
        self.debug = debug

        self.log = DevLogger(enabled=True)

        # policies (legado por enquanto)
        self.threat_policy = ThreatPolicy(defend_radius=22.0, min_enemy=1)
        self.drop_policy = DropPolicy(enabled=True, min_marines=8, load_count=8)

        # orchestrator + actions
        self.orch = Orchestrator(command_budget=2, defense_floor=80)
        self.orch.add(ScoutAction(trigger_time=25.0, log_every=6.0, see_radius=14.0))

    async def on_start(self) -> None:
        await super().on_start()

        map_name = self.game_info.map_name
        enemy = self.enemy_race.name

        fname = f"MyBot__{map_name}__vs__{enemy}__start.jsonl".replace(" ", "_")
        self.log.set_file(fname)

        if self.debug:
            print("[on_start] Ares build runner enabled")
            print(f"[on_start] devlog={os.path.join(self.log.log_dir, fname)}")

        self.log.emit("bot_init", {"strategy": "terran_builds.yml/Default"}, meta={"map": map_name})

    async def on_step(self, iteration: int) -> None:
        await super().on_step(iteration)

        opening_done = bool(self.build_order_runner.build_completed)

        # Threat sempre avalia (mesmo na opening)
        threat_report = self.threat_policy.evaluate(self)

        ctx = TickContext(
            iteration=iteration,
            time=float(self.time),
            opening_done=opening_done,
            threatened=bool(threat_report.threatened),
        )

        # 1) Orchestrator roda SEMPRE (inclusive durante opening)
        await self.orch.tick(self, ctx)

        # 2) Defesa reativa (pode ficar fora do orch por enquanto)
        if threat_report.threatened:
            acted = await self.threat_policy.act(self, threat_report)
            if acted:
                self.log.emit(
                    "threat_defend",
                    {
                        "iteration": iteration,
                        "time": round(self.time, 2),
                        "enemy_count": threat_report.enemy_count,
                        "radius": threat_report.radius,
                        "pos": [round(threat_report.threat_pos.x, 1), round(threat_report.threat_pos.y, 1)]
                        if threat_report.threat_pos
                        else None,
                        "opening_done": opening_done,
                    },
                )

        # 3) Drop só pós-opening e sem ameaça (por enquanto)
        if opening_done and (not threat_report.threatened):
            drop_acted = await self.drop_policy.act(self)
            if drop_acted and iteration % 11 == 0:
                self.log.emit(
                    "drop_tick",
                    {"iteration": iteration, "time": round(self.time, 2), "phase": str(self.drop_policy.state.phase)},
                )

        if self.debug and iteration % 44 == 0:
            print(
                f"[tick] iter={iteration} t={self.time:.1f} "
                f"m={int(self.minerals)} g={int(self.vespene)} "
                f"s={int(self.supply_used)}/{int(self.supply_cap)} "
                f"opening_done={opening_done} threat={threat_report.threatened} "
                f"drop={self.drop_policy.state.phase}"
            )

    async def on_end(self, game_result: Result) -> None:
        await super().on_end(game_result)
        if self.debug:
            print(f"[game_end] result={game_result}")
        self.log.emit("game_end", {"result": str(game_result)})
```

# bot/policies/__init__.py
```python

```

# bot/policies/base.py
```python
#bot/policies/base.py

class Policy:
    """Classe base para policies estratégicas."""
    pass
```

# bot/policies/drop.py
```python
#bot/policies/drop.py
from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Optional

from sc2.ids.ability_id import AbilityId as A
from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2
from sc2.unit import Unit


class DropPhase(str, Enum):
    IDLE = "IDLE"
    STAGING = "STAGING"
    LOADING = "LOADING"
    FLYING = "FLYING"
    DROPPING = "DROPPING"
    FIGHTING = "FIGHTING"
    EVAC = "EVAC"
    RESET = "RESET"


@dataclass
class DropState:
    phase: DropPhase = DropPhase.IDLE
    medivac_tag: Optional[int] = None
    started_at: float = 0.0
    last_transition_at: float = 0.0
    target_pos: Optional[Point2] = None
    staging_pos: Optional[Point2] = None


class DropPolicy:
    """
    Drop básico e robusto (estado + timeout).
    Meta: bot fazer algo perigoso *sem travar*.

    Premissas:
      - Terran
      - Medivac + Marines
    """

    def __init__(
        self,
        *,
        enabled: bool = True,
        min_marines: int = 8,
        load_count: int = 8,
        stage_radius: float = 10.0,
        phase_timeout: float = 35.0,
        fight_time: float = 10.0,
    ):
        self.enabled = enabled
        self.min_marines = min_marines
        self.load_count = load_count
        self.stage_radius = stage_radius
        self.phase_timeout = phase_timeout
        self.fight_time = fight_time
        self.state = DropState()

    def _enemy_main_like(self, bot) -> Optional[Point2]:
        # Melhor esforço:
        # - se o bot já viu enemy_start_locations, usa o primeiro
        try:
            if bot.enemy_start_locations:
                return bot.enemy_start_locations[0]
        except Exception:
            pass
        return None

    def _default_staging(self, bot) -> Optional[Point2]:
        # staging perto da natural/main, evitando ficar no meio do mapa
        try:
            if bot.townhalls:
                th = bot.townhalls.closest_to(bot.start_location)
                return th.position.towards(bot.game_info.map_center, 6)
        except Exception:
            pass
        return bot.start_location.towards(bot.game_info.map_center, 6)

    def _get_medivac(self, bot) -> Optional[Unit]:
        if self.state.medivac_tag:
            m = bot.units.find_by_tag(self.state.medivac_tag)
            if m and m.is_alive:
                return m

        medivacs = bot.units(U.MEDIVAC)
        if medivacs.amount == 0:
            return None

        # escolhe um medivac relativamente "livre"
        m = medivacs.sorted(lambda x: x.cargo_used)[0]
        self.state.medivac_tag = m.tag
        return m

    def _phase_timed_out(self, bot) -> bool:
        if self.state.phase in (DropPhase.IDLE, DropPhase.RESET):
            return False
        return (bot.time - self.state.last_transition_at) > self.phase_timeout

    def _transition(self, bot, phase: DropPhase) -> None:
        self.state.phase = phase
        if self.state.started_at == 0.0:
            self.state.started_at = bot.time
        self.state.last_transition_at = bot.time

    def evaluate(self, bot) -> bool:
        if not self.enabled:
            return False

        # Só tenta se tiver recursos mínimos
        if bot.units(U.MEDIVAC).amount < 1:
            return False

        marines = bot.units(U.MARINE)
        if marines.amount < self.min_marines:
            return False

        # precisa ter target
        target = self._enemy_main_like(bot)
        if not target:
            return False

        return True

    async def act(self, bot) -> bool:
        """
        Retorna True se emitiu comando.
        """
        if not self.evaluate(bot):
            # Se não dá pra dropar, reseta state pra não ficar "preso"
            self.state = DropState()
            return False

        if self._phase_timed_out(bot):
            self._transition(bot, DropPhase.RESET)

        target = self._enemy_main_like(bot)
        staging = self._default_staging(bot)
        if not target or not staging:
            return False

        self.state.target_pos = target
        self.state.staging_pos = staging

        m = self._get_medivac(bot)
        if not m:
            return False

        marines = bot.units(U.MARINE)
        if marines.amount == 0:
            return False

        issued = False

        # -----------------------
        # State machine
        # -----------------------
        if self.state.phase == DropPhase.IDLE:
            self._transition(bot, DropPhase.STAGING)

        if self.state.phase == DropPhase.STAGING:
            # junta marines e medivac no staging
            pack = marines.closest_n_units(staging, self.load_count)
            for u in pack:
                if u.distance_to(staging) > self.stage_radius:
                    u.move(staging)
                    issued = True

            if m.distance_to(staging) > self.stage_radius:
                m.move(staging)
                issued = True

            # pronto pra carregar se o pack estiver perto
            if pack.amount >= self.load_count and pack.center.distance_to(staging) <= self.stage_radius:
                self._transition(bot, DropPhase.LOADING)

        if self.state.phase == DropPhase.LOADING:
            pack = marines.closest_n_units(m.position, self.load_count)

            # se medivac já cheio o suficiente, parte
            if m.cargo_used >= self.load_count:
                self._transition(bot, DropPhase.FLYING)
            else:
                # manda os marines entrarem no medivac (load)
                # cuidado: python-sc2 faz o order no próprio marine com AbilityId.LOAD_MEDIVAC
                for u in pack:
                    if u.is_alive and u.distance_to(m) <= 5:
                        u( A.LOAD_MEDIVAC, m )
                        issued = True
                    elif u.is_alive:
                        u.move(m.position)
                        issued = True

        if self.state.phase == DropPhase.FLYING:
            # vai para um ponto próximo do alvo pra evitar cair em cima de torre/canhões
            approach = target.towards(bot.game_info.map_center, -6)
            if m.distance_to(approach) > 4:
                m.move(approach)
                issued = True
            else:
                self._transition(bot, DropPhase.DROPPING)

        if self.state.phase == DropPhase.DROPPING:
            # unload all
            if m.cargo_used > 0:
                m( A.UNLOADALLAT_MEDIVAC, m.position.towards(target, 3) )
                issued = True
            self._transition(bot, DropPhase.FIGHTING)

        if self.state.phase == DropPhase.FIGHTING:
            # manda marines atacar algo por um tempo curto e depois evacuar
            fight_elapsed = bot.time - self.state.last_transition_at
            local_marines = bot.units(U.MARINE).closer_than(18, m.position)

            # Se não viu nada, ataca o target "as cegas"
            if bot.enemy_units.closer_than(18, m.position).amount > 0:
                enemy = bot.enemy_units.closer_than(18, m.position).closest_to(m.position)
                for u in local_marines:
                    if u.is_idle:
                        u.attack(enemy)
                        issued = True
            else:
                for u in local_marines:
                    if u.is_idle:
                        u.attack(target)
                        issued = True

            if fight_elapsed >= self.fight_time:
                self._transition(bot, DropPhase.EVAC)

        if self.state.phase == DropPhase.EVAC:
            # tenta recolher os marines próximos
            local_marines = bot.units(U.MARINE).closer_than(10, m.position)
            if m.cargo_used < m.cargo_max and local_marines.amount > 0:
                for u in local_marines:
                    if u.is_alive and u.distance_to(m) <= 5:
                        u( A.LOAD_MEDIVAC, m )
                        issued = True
                    elif u.is_alive:
                        u.move(m.position)
                        issued = True

            # volta pra staging e reseta quando chegar
            if m.distance_to(staging) > 6:
                m.move(staging)
                issued = True
            else:
                self._transition(bot, DropPhase.RESET)

        if self.state.phase == DropPhase.RESET:
            # reset total para permitir um próximo drop depois
            self.state = DropState()
            issued = True

        return issued
```

# bot/policies/scout.py
```python
#bot/policies/scout.py
from __future__ import annotations

from dataclasses import dataclass

from sc2.unit import Unit

from bot.services.map import MapService
from bot.services.roles import RoleService


@dataclass
class ScoutState:
    dispatched: bool = False
    scout_tag: int | None = None


class ScoutPolicy:
    """
    MVP de scout:
      - quando chamado, se ainda não despachou:
          - pega 1 SCV via RoleService.request_worker_scout()
          - manda mover/atacar-move até a main inimiga (aqui: move simples)
          - marca dispatched

    Sem fallback.
    """

    def __init__(self) -> None:
        self.state = ScoutState()

    async def act(self, bot, *, roles: RoleService, maps: MapService) -> bool:
        if self.state.dispatched:
            return False

        target = maps.enemy_main()

        scout: Unit = roles.request_worker_scout(target_position=target)
        scout.move(target)

        self.state.dispatched = True
        self.state.scout_tag = scout.tag
        return True
```

# bot/policies/strategy.py
```python
#bot/policies/strategy.py

class StrategyPolicy:
    """Define fase do jogo e estratégia ativa."""
    pass
```

# bot/policies/threat.py
```python
#bot/policies/threat.py
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional, Tuple

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2
from sc2.unit import Unit


@dataclass
class ThreatReport:
    threatened: bool
    threat_pos: Optional[Point2]
    enemy_count: int
    radius: float


class ThreatPolicy:
    """
    Defesa reativa simples:
      - Detecta inimigos perto de qualquer townhall (CC/OC/PF).
      - Se ameaçado, comanda exército básico para defender.

    Observação: isso NÃO é "boa defesa", é "não morrer de graça".
    """

    def __init__(self, *, defend_radius: float = 22.0, min_enemy: int = 1):
        self.defend_radius = defend_radius
        self.min_enemy = min_enemy

    def _townhalls(self, bot) -> List[Unit]:
        # AresBot herda BotAI => townhalls existe no python-sc2
        try:
            return list(bot.townhalls)
        except Exception:
            return []

    def evaluate(self, bot) -> ThreatReport:
        ths = self._townhalls(bot)
        if not ths:
            return ThreatReport(False, None, 0, self.defend_radius)

        enemies = bot.enemy_units
        if not enemies:
            return ThreatReport(False, None, 0, self.defend_radius)

        best: Tuple[int, Optional[Point2]] = (0, None)
        for th in ths:
            near = enemies.closer_than(self.defend_radius, th.position)
            c = near.amount
            if c > best[0]:
                best = (c, th.position)

        threatened = best[0] >= self.min_enemy
        return ThreatReport(threatened, best[1], best[0], self.defend_radius)

    async def act(self, bot, report: ThreatReport) -> bool:
        """
        Retorna True se emitiu comandos relevantes.
        """
        if not report.threatened or not report.threat_pos:
            return False

        # Grupo de defesa: começa simples (bio)
        defenders = bot.units.of_type(
            {
                U.MARINE,
                U.MARAUDER,
                U.SIEGETANK,
                U.SIEGETANKSIEGED,
                U.HELLION,
                U.HELLBAT,
                U.CYCLONE,
                U.THOR,
                U.THORAP,
                U.MEDIVAC,
            }
        )

        if defenders.amount == 0:
            return False

        # Não puxa tudo do mapa inteiro; só quem está relativamente perto
        local = defenders.closer_than(45, report.threat_pos)
        if local.amount == 0:
            # fallback: puxa tudo
            local = defenders

        # Medivac não precisa suicidar: manda seguir/ir para trás levemente
        medivacs = local(U.MEDIVAC)
        army = local - medivacs

        issued = False
        for u in army:
            if u.is_idle:
                u.attack(report.threat_pos)
                issued = True

        for m in medivacs:
            if m.is_idle:
                m.move(report.threat_pos.towards(bot.start_location, 6))
                issued = True

        return issued
```

# bot/services/__init__.py
```python

```

# bot/services/grid.py
```python
#bot/services/grid.py

class GridService:
    """Encapsula grids e helpers de pathfinding."""
    pass
```

# bot/services/map.py
```python
#bot/services/map.py
from __future__ import annotations

from dataclasses import dataclass

from sc2.position import Point2


@dataclass(frozen=True)
class MapService:
    """
    Encapsula leituras de "onde ir" no mapa.

    Sem fallback:
    - Se enemy_start_locations não existir ou estiver vazio -> crash.
    """

    bot: object  # AresBot / BotAI

    def enemy_main(self) -> Point2:
        return self.bot.enemy_start_locations[0]
```

# bot/services/query.py
```python
#bot/services/query.py

class QueryService:
    """Consultas rápidas de unidades."""
    pass
```

# bot/services/roles.py
```python
#bot/services/roles.py
from __future__ import annotations

from dataclasses import dataclass

from ares.consts import UnitRole
from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2
from sc2.unit import Unit


@dataclass(frozen=True)
class RoleService:
    """
    Wrapper mínimo e direto do UnitRoleManager via mediator.

    Regra: sem fallback.
    Se mediator não tiver o método esperado, crasha.
    """

    bot: object  # AresBot / BotAI

    def assign(self, *, unit: Unit, role: UnitRole, remove_from_squad: bool = True) -> None:
        self.bot.mediator.assign_role(tag=unit.tag, role=role, remove_from_squad=remove_from_squad)

    def get_scout_workers(self):
        return self.bot.mediator.get_units_from_role(role=UnitRole.BUILD_RUNNER_SCOUT, unit_type=U.SCV)

    def request_worker_scout(self, *, target_position: Point2) -> Unit:
        """
        Seleciona 1 worker e marca como scout.

        - Usa select_worker do Ares (não é python-sc2 puro).
        - Atribui UnitRole.BUILD_RUNNER_SCOUT.
        """
        worker: Unit = self.bot.mediator.select_worker(target_position=target_position)
        self.assign(unit=worker, role=UnitRole.BUILD_RUNNER_SCOUT, remove_from_squad=True)
        return worker
```

# bot/services/workers.py
```python
#bot/services/workers.py

class WorkerService:
    """Seleção inteligente de workers."""
    pass
```

# bot/utils/__init__.py
```python

```

# bot/utils/geometry.py
```python
#bot/utils/geometry.py

class GeometryUtils:
    """Funções auxiliares geométricas."""
    pass
```

# bot/utils/time.py
```python
#bot/utils/time.py

class TimeUtils:
    """Helpers de tempo e cooldown."""
    pass
```

===== terran_builds.yml (ROOT) =====

# terran_builds.yml
```yaml
UseData: False
BuildSelection: Cycle
MinGamesWinrateBased: 3

BuildChoices:
  Protoss:
    BotName: BoiBandido
    Cycle:
      - Default
  Terran:
    BotName: BoiBandido
    Cycle:
      - Default
  Zerg:
    BotName: BoiBandido
    Cycle:
      - Default
  Random:
    BotName: BoiBandido
    Cycle:
      - Default

Builds:
  Default:
    ConstantWorkerProductionTill: 20
    AutoSupplyAtSupply: 16
    OpeningBuildOrder:
      - 14 supply @ ramp
      - 16 barracks @ ramp
      - 16 gas
      - 0 orbital
      - 19 expand
      - 20 marine *2
      - 1 factory
      - 21 gas
      - 1 starport
```
