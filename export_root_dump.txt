===== PROJECT TREE =====
.
├── .github
│   └── workflows
│       ├── build_windows_exe.yaml
│       └── ladder_zip.yml
├── .vscode1
│   ├── launch.json
│   └── settings.json
├── bot
│   ├── ares_wrapper
│   │   ├── __init__.py
│   │   ├── map.py
│   │   └── roles.py
│   ├── config
│   │   ├── __init__.py
│   │   ├── loader.py
│   │   └── schema.py
│   ├── infra
│   │   └── unit_leases.py
│   ├── inteligence
│   │   ├── __init__.py
│   │   └── threat.py
│   ├── mind
│   │   ├── __init__.py
│   │   ├── attention.py
│   │   ├── awareness.py
│   │   ├── ego.py
│   │   └── self.py
│   ├── planners
│   │   ├── defense_planner.py
│   │   ├── intel_planner.py
│   │   └── proposals.py
│   ├── tasks
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── defend.py
│   │   ├── scan.py
│   │   └── scout.py
│   ├── __init__.py
│   ├── devlog.py
│   └── main.py
├── data
│   └── None-protoss.json
├── logs
│   └── MyBot__Torches_AIE__vs__Protoss__start.jsonl
├── scripts
│   ├── create_ladder_zip.py
│   ├── create_pyinstaller_exe.py
│   ├── update_ares.py
│   └── upload_to_ai_arena.py
├── .env
├── .gitignore
├── .gitmodules
├── ARCHITECTURE.md
├── config.yml
├── export_prompt_root.py
├── export_root_dump.txt
├── ladder.py
├── LICENSE
├── poetry.lock
├── protoss_builds.yml
├── pyproject.toml
├── README.md
├── run.py
└── terran_builds.yml

===== bot/*.py (FULL CONTENT) =====

# bot/__init__.py
```python

```

# bot/ares_wrapper/__init__.py
```python
#bot/ares_wrapper/__init__.py
from __future__ import annotations

from dataclasses import dataclass

from bot.ares_wrapper.map import Map
from bot.ares_wrapper.roles import Roles


@dataclass(frozen=True)
class AresWrapper:
    """
    Camada de adaptação ao Ares/python-sc2.

    Regra:
      - Pode chamar bot.mediator, bot.game_info, etc.
      - NÃO contém decisão estratégica e NÃO contém state machine de missão.
    """
    bot: object

    @property
    def roles(self) -> Roles:
        return Roles(self.bot)

    @property
    def map(self) -> Map:
        return Map(self.bot)
```

# bot/ares_wrapper/map.py
```python
#bot/ares_wrapper/map.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Literal, Tuple

from sc2.position import Point2


EnemyMainSource = Literal["ENEMY_START", "FALLBACK_CENTER", "FALLBACK_START"]


@dataclass(frozen=True)
class Map:
    bot: object

    def enemy_main(self) -> Tuple[Point2, EnemyMainSource]:
        # 1) normal
        try:
            locs = getattr(self.bot, "enemy_start_locations", None)
            if locs and len(locs) > 0:
                return locs[0], "ENEMY_START"
        except Exception:
            pass

        # 2) fallback map center
        try:
            return self.bot.game_info.map_center, "FALLBACK_CENTER"
        except Exception:
            pass

        # 3) fallback final
        return self.bot.start_location, "FALLBACK_START"
```

# bot/ares_wrapper/roles.py
```python
#bot/ares_wrapper/roles.py
from __future__ import annotations

from dataclasses import dataclass

from ares.consts import UnitRole
from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2
from sc2.unit import Unit


@dataclass(frozen=True)
class Roles:
    bot: object  # AresBot / BotAI

    def assign(self, *, unit: Unit, role: UnitRole, remove_from_squad: bool = True) -> None:
        self.bot.mediator.assign_role(tag=unit.tag, role=role, remove_from_squad=remove_from_squad)

    def get_scout_workers(self):
        return self.bot.mediator.get_units_from_role(role=UnitRole.BUILD_RUNNER_SCOUT, unit_type=U.SCV)

    def request_worker_scout(self, *, target_position: Point2) -> Unit:
        worker: Unit = self.bot.mediator.select_worker(target_position=target_position)
        self.assign(unit=worker, role=UnitRole.BUILD_RUNNER_SCOUT, remove_from_squad=True)
        return worker
```

# bot/config/__init__.py
```python

```

# bot/config/loader.py
```python
#bot/config/loader.py

class ConfigLoader:
    """Carregamento de config externa."""
    pass
```

# bot/config/schema.py
```python
#bot/config/schema.py

class ConfigSchema:
    """Definições de schema para validação."""
    pass
```

# bot/devlog.py
```python
#bot/devlog.py
from __future__ import annotations

import json
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Dict, Optional


@dataclass
class DevLogger:
    """
    Logger JSONL simples (1 evento por linha).
    Objetivo: você conseguir auditar decisões ("flags") pós-partida.
    """

    log_dir: str = "logs"
    filename: Optional[str] = None
    enabled: bool = True

    def _ensure_dir(self) -> None:
        os.makedirs(self.log_dir, exist_ok=True)

    def set_file(self, filename: str) -> None:
        self.filename = filename

    def emit(self, event: str, payload: Optional[Dict[str, Any]] = None, *, meta: Optional[Dict[str, Any]] = None) -> None:
        if not self.enabled:
            return
        if not self.filename:
            # Se esquecer de setar, não explode o jogo.
            return

        self._ensure_dir()
        row = {
            "ts_utc": datetime.now(timezone.utc).isoformat(),
            "event": event,
            "payload": payload or {},
            "meta": meta or {},
        }
        path = os.path.join(self.log_dir, self.filename)
        try:
            with open(path, "a", encoding="utf-8") as f:
                f.write(json.dumps(row, ensure_ascii=False) + "\n")
        except Exception:
            # logging nunca pode matar o bot
            pass
```

# bot/infra/unit_leases.py
```python
#bot/runtime/unit_leases.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional

from ares.consts import UnitRole


@dataclass
class Lease:
    owner: str          # task_id
    role: UnitRole
    expires_at: float


class UnitLeases:
    """
    Ownership mínimo com TTL pra evitar unidade "presa".
    - Task chama claim/touch.
    - Scheduler chama reap() por tick.
    """

    def __init__(self, *, default_ttl: float = 8.0):
        self.default_ttl = float(default_ttl)
        self._leases: Dict[int, Lease] = {}  # unit_tag -> Lease

    def reap(self, *, now: float) -> None:
        expired = [tag for tag, lease in self._leases.items() if lease.expires_at <= now]
        for tag in expired:
            del self._leases[tag]

    def owner_of(self, unit_tag: int, *, now: float) -> Optional[str]:
        self.reap(now=now)
        lease = self._leases.get(unit_tag)
        return lease.owner if lease else None

    def can_claim(self, unit_tag: int, *, now: float) -> bool:
        self.reap(now=now)
        return unit_tag not in self._leases

    def claim(
        self,
        *,
        task_id: str,
        unit_tag: int,
        role: UnitRole,
        now: float,
        ttl: Optional[float] = None,
        force: bool = False,
    ) -> bool:
        self.reap(now=now)
        if (not force) and unit_tag in self._leases:
            return False

        t = float(ttl) if ttl is not None else self.default_ttl
        self._leases[unit_tag] = Lease(owner=task_id, role=role, expires_at=now + t)
        return True

    def touch(self, *, task_id: str, unit_tag: int, now: float, ttl: Optional[float] = None) -> None:
        self.reap(now=now)
        lease = self._leases.get(unit_tag)
        if not lease or lease.owner != task_id:
            return
        t = float(ttl) if ttl is not None else self.default_ttl
        lease.expires_at = now + t

    def release_owner(self, *, task_id: str) -> None:
        to_del = [tag for tag, lease in self._leases.items() if lease.owner == task_id]
        for tag in to_del:
            del self._leases[tag]
```

# bot/inteligence/__init__.py
```python

```

# bot/inteligence/threat.py
```python
#bot/inteligence/threat.py
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional, Tuple

from sc2.position import Point2
from sc2.unit import Unit


@dataclass(frozen=True)
class ThreatReport:
    threatened: bool
    threat_pos: Optional[Point2]
    enemy_count: int
    radius: float
    urgency: int  # 0..100


class Threat:
    """
    Intelligence-only:
      - Detecta inimigos perto de townhalls
      - Produz threat_pos + enemy_count + urgency
    """

    def __init__(self, *, defend_radius: float = 22.0, min_enemy: int = 1):
        self.defend_radius = float(defend_radius)
        self.min_enemy = int(min_enemy)

    def _townhalls(self, bot) -> List[Unit]:
        try:
            return list(bot.townhalls)
        except Exception:
            return []

    def evaluate(self, bot) -> ThreatReport:
        ths = self._townhalls(bot)
        if not ths:
            return ThreatReport(False, None, 0, self.defend_radius, 0)

        enemies = bot.enemy_units
        if not enemies:
            return ThreatReport(False, None, 0, self.defend_radius, 0)

        best: Tuple[int, Optional[Point2]] = (0, None)
        for th in ths:
            near = enemies.closer_than(self.defend_radius, th.position)
            c = int(near.amount)
            if c > best[0]:
                best = (c, th.position)

        threatened = best[0] >= self.min_enemy
        enemy_count = int(best[0])

        # urgência simples (MVP): ameaça => 50 + 10*count, cap 100
        urgency = 0
        if threatened:
            urgency = min(100, 50 + 10 * enemy_count)

        return ThreatReport(threatened, best[1], enemy_count, self.defend_radius, int(urgency))
```

# bot/main.py
```python
# bot/main.py
from __future__ import annotations

from typing import Optional

from ares import AresBot
from sc2.data import Result

from bot.ares_wrapper import AresWrapper
from bot.devlog import DevLogger
from bot.mind.self import RuntimeApp


class MyBot(AresBot):
    def __init__(self, game_step_override: Optional[int] = None, *, debug: bool = True):
        super().__init__(game_step_override)
        self.debug = debug

        # logger pode ficar aqui (infra), mas runtime decide como usar
        self.log = DevLogger(enabled=True)

        # wrapper do engine (opcional ficar aqui; pode migrar pro runtime depois)
        self.ares = AresWrapper(self)

        # runtime é a única "inteligência" conectada ao main
        self.rt = RuntimeApp.build(log=self.log, debug=debug)

    async def on_start(self) -> None:
        await super().on_start()
        await self.rt.on_start(self)

    async def on_step(self, iteration: int) -> None:
        await super().on_step(iteration)
        await self.rt.on_step(self, iteration=iteration)

    async def on_end(self, game_result: Result) -> None:
        await super().on_end(game_result)
        await self.rt.on_end(self, game_result=game_result)
```

# bot/mind/__init__.py
```python

```

# bot/mind/attention.py
```python
# bot/runtime/attention.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional, Tuple

from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2

from bot.inteligence.threat import Threat, ThreatReport
from bot.mind.awareness import Awareness


@dataclass(frozen=True)
class Attention:
    """
    Snapshot do tick atual.
    - IMUTÁVEL
    - Recalculado todo tick via derive_attention()
    - Read-only para planners/tasks
    """

    opening_done: bool

    threatened: bool
    defense_urgency: int  # 0..100
    threat_pos: Optional[Point2] = None
    enemy_count_near_bases: int = 0

    orbital_ready_to_scan: bool = False
    orbital_energy: float = 0.0

    time: float = 0.0


def _orbital_scan_status(bot) -> Tuple[bool, float]:
    try:
        orbitals = bot.structures(U.ORBITALCOMMAND).ready
        if orbitals.amount == 0:
            return False, 0.0
        oc = orbitals.first
        energy = float(getattr(oc, "energy", 0.0) or 0.0)
        return (energy >= 50.0), energy
    except Exception:
        return False, 0.0


def derive_attention(bot, *, awareness: Awareness, threat: Threat) -> Attention:
    """
    Deriva o snapshot do tick atual.
    Regra: NÃO escreve em awareness (sem side-effects).
    """
    opening_done = bool(getattr(bot, "build_order_runner", None) and bot.build_order_runner.build_completed)

    thr: ThreatReport = threat.evaluate(bot)
    orbital_ready, orbital_energy = _orbital_scan_status(bot)

    return Attention(
        opening_done=opening_done,
        threatened=bool(thr.threatened),
        defense_urgency=int(thr.urgency),
        threat_pos=thr.threat_pos,
        enemy_count_near_bases=int(thr.enemy_count),
        orbital_ready_to_scan=bool(orbital_ready),
        orbital_energy=float(orbital_energy),
        time=float(getattr(bot, "time", 0.0)),
    )
```

# bot/mind/awareness.py
```python
from __future__ import annotations

from dataclasses import dataclass, field


@dataclass
class IntelState:
    # SCV scout
    scv_dispatched: bool = False
    scv_arrived_main: bool = False
    last_scv_dispatch_at: float = 0.0

    # scan
    scanned_enemy_main: bool = False
    last_scan_at: float = 0.0


@dataclass
class Awareness:
    intel: IntelState = field(default_factory=IntelState)
```

# bot/mind/ego.py
```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

from bot.devlog import DevLogger
from bot.planners.proposals import Planner, Proposal
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.infra.unit_leases import UnitLeases
from bot.tasks.base import Task, TaskTick


@dataclass
class egoConfig:
    command_budget: int = 2
    soft_preempt_at: int = 60
    hard_preempt_at: int = 80


@dataclass
class Active:
    task: Task
    score: int


class ego:
    def __init__(self, *, leases: UnitLeases, log: DevLogger, cfg: Optional[egoConfig] = None):
        self.leases = leases
        self.log = log
        self.cfg = cfg or egoConfig()
        self._planners: List[Planner] = []
        self._active_by_domain: Dict[str, Active] = {}

    def register_planner(self, planner: Planner) -> None:
        self._planners.append(planner)

    def _pick_from_proposals(self, proposals: List[Proposal]) -> Dict[str, Active]:
        best: Dict[str, Active] = {}
        for p in proposals:
            score = int(p.score)
            if score <= 0:
                continue
            cur = best.get(p.domain)
            if cur is None or score > cur.score:
                best[p.domain] = Active(task=p.task, score=score)
        return best

    async def tick(self, bot, *, tick: TaskTick, attention: Attention, awareness: Awareness) -> None:
        now = float(tick.time)
        self.leases.reap(now=now)

        proposals: List[Proposal] = []
        for pl in self._planners:
            try:
                proposals.extend(pl.propose(bot, awareness=awareness, attention=attention))
            except Exception as e:
                self.log.emit("planner_error", {"planner": getattr(pl, "planner_id", "unknown"), "err": str(e)})

        desired = self._pick_from_proposals(proposals)

        # preempção
        if attention.defense_urgency >= self.cfg.hard_preempt_at:
            for domain in ("HARASS", "MAP"):
                slot = self._active_by_domain.get(domain)
                if slot:
                    await slot.task.abort(bot, reason=f"hard_preempt urgency={attention.defense_urgency}")
                    self.leases.release_owner(task_id=slot.task.task_id)
                    del self._active_by_domain[domain]
                    self.log.emit("task_hard_preempt", {"domain": domain, "tid": slot.task.task_id})
        elif attention.defense_urgency >= self.cfg.soft_preempt_at:
            for domain in ("HARASS", "MAP"):
                slot = self._active_by_domain.get(domain)
                if slot:
                    await slot.task.pause(bot, reason=f"soft_preempt urgency={attention.defense_urgency}")
                    self.log.emit("task_soft_preempt", {"domain": domain, "tid": slot.task.task_id})

        # swap active
        for domain, slot in desired.items():
            cur = self._active_by_domain.get(domain)
            if cur is None or cur.task.task_id != slot.task.task_id:
                if cur is not None:
                    await cur.task.abort(bot, reason="replaced")
                    self.leases.release_owner(task_id=cur.task.task_id)
                    self.log.emit("task_replaced", {"domain": domain, "from": cur.task.task_id, "to": slot.task.task_id})

                self._active_by_domain[domain] = slot
                self.log.emit("task_selected", {"domain": domain, "tid": slot.task.task_id, "score": slot.score})

        # execute with budget (DEFENSE first)
        budget = int(self.cfg.command_budget)
        ordered: List[Tuple[str, Active]] = sorted(
            self._active_by_domain.items(),
            key=lambda kv: (0 if kv[0] == "DEFENSE" else 1, -kv[1].score),
        )

        for domain, slot in ordered:
            if budget <= 0:
                break
            used = await slot.task.step(bot, tick, attention)
            if used:
                budget -= 1
```

# bot/mind/self.py
```python
# bot/runtime/app.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

from sc2.data import Result

from bot.devlog import DevLogger
from bot.inteligence.threat import Threat
from bot.mind.ego import Scheduler, SchedulerConfig
from bot.mind.attention import derive_attention
from bot.infra.unit_leases import UnitLeases
from bot.mind.awareness import Awareness
from bot.tasks.base import TaskTick
from bot.tasks.defend import Defend
from bot.tasks.scout import Scout
from bot.planners.defense_planner import DefensePlanner
from bot.planners.intel_planner import IntelPlanner


@dataclass
class RuntimeApp:
    """
    Orquestrador único do bot.
    O main.py só delega pra cá.
    """
    log: DevLogger
    awareness: Awareness
    threat: Threat
    leases: UnitLeases
    scheduler: Scheduler
    debug: bool = True

    @classmethod
    def build(cls, *, log: DevLogger, debug: bool = True) -> "RuntimeApp":
        awareness = Awareness()

        threat = Threat(defend_radius=22.0, min_enemy=1)

        leases = UnitLeases(default_ttl=8.0)
        scheduler = Scheduler(
            leases=leases,
            log=log,
            cfg=SchedulerConfig(command_budget=2, soft_preempt_at=60, hard_preempt_at=80),
        )

        # tasks
        defend_task = Defend()
        scout_task = Scout(leases=leases, awareness=awareness, trigger_time=25.0, log_every=6.0, see_radius=14.0)

        # planners
        defense_planner = DefensePlanner(awareness=awareness, defend_task=defend_task)
        intel_planner = IntelPlanner(awareness=awareness, log=log, scout_task=scout_task)

        scheduler.register_planner(defense_planner)
        scheduler.register_planner(intel_planner)

        return cls(
            log=log,
            awareness=awareness,
            threat=threat,
            leases=leases,
            scheduler=scheduler,
            debug=debug,
        )

    async def on_start(self, bot) -> None:
        # runtime decide nome do arquivo e loga init
        map_name = bot.game_info.map_name
        enemy = bot.enemy_race.name
        fname = f"MyBot__{map_name}__vs__{enemy}__start.jsonl".replace(" ", "_")
        self.log.set_file(fname)

        self.log.emit("bot_init", {"strategy": "terran_builds.yml/Default"}, meta={"map": map_name})

        if self.debug:
            print(f"[on_start] devlog={self.log.log_dir}/{fname}")

    async def on_step(self, bot, *, iteration: int) -> None:
        # derive_attention cuida de opening_done, threat, orbital, etc
        attention = derive_attention(bot, awareness=self.awareness, threat=self.threat)

        await self.scheduler.tick(
            bot,
            tick=TaskTick(iteration=iteration, time=float(bot.time)),
            attention=attention,
            awareness=self.awareness,
        )

        if iteration % 44 == 0:
            self.log.emit(
                "awareness_snapshot",
                {
                    "time": round(bot.time, 2),
                    "attention": {
                        "opening_done": attention.opening_done,
                        "threatened": attention.threatened,
                        "urgency": attention.defense_urgency,
                        "enemy_count_near_bases": attention.enemy_count_near_bases,
                        "orbital_ready_to_scan": attention.orbital_ready_to_scan,
                        "orbital_energy": round(attention.orbital_energy, 1),
                    },
                    "intel": {
                        "scv_dispatched": self.awareness.intel.scv_dispatched,
                        "scv_arrived_main": self.awareness.intel.scv_arrived_main,
                        "scanned_enemy_main": self.awareness.intel.scanned_enemy_main,
                        "last_scv_dispatch_at": round(self.awareness.intel.last_scv_dispatch_at, 2),
                        "last_scan_at": round(self.awareness.intel.last_scan_at, 2),
                    },
                },
            )

        if self.debug and iteration % 44 == 0:
            print(
                f"[tick] iter={iteration} t={bot.time:.1f} "
                f"s={int(bot.supply_used)}/{int(bot.supply_cap)} "
                f"threat={attention.threatened} urg={attention.defense_urgency} "
                f"intel(scv={self.awareness.intel.scv_dispatched}/{self.awareness.intel.scv_arrived_main}, scan={self.awareness.intel.scanned_enemy_main})"
            )
```

# bot/planners/defense_planner.py
```python
from __future__ import annotations

from dataclasses import dataclass

from bot.planners.proposals import Proposal
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.tasks.defend import Defend


@dataclass
class DefensePlanner:
    planner_id: str = "defense_planner"

    def __init__(self, *, awareness: Awareness, defend_task: Defend):
        self.awareness = awareness
        self.defend_task = defend_task

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        if not attention.threatened or not attention.threat_pos:
            return []

        score = 50 + int(attention.defense_urgency)

        return [
            Proposal(
                domain="DEFENSE",
                score=score,
                task=self.defend_task,
                reason="base_threatened",
            )
        ]
```

# bot/planners/intel_planner.py
```python
from __future__ import annotations

from dataclasses import dataclass

from bot.devlog import DevLogger
from bot.planners.proposals import Proposal
from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.tasks.scan import ScanAt
from bot.tasks.scout import Scout


@dataclass
class IntelPlanner:
    planner_id: str = "intel_planner"

    def __init__(self, *, awareness: Awareness, log: DevLogger, scout_task: Scout):
        self.awareness = awareness
        self.log = log
        self.scout_task = scout_task

        self._scan_task: ScanAt | None = None
        self._scan_label: str | None = None

    def _choose_scan_target(self, bot, attention: Attention):
        # por enquanto: enemy main
        target, source = bot.ares.map.enemy_main()
        return target, "enemy_main", source

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list[Proposal]:
        out: list[Proposal] = []

        threat_penalty = 50 if (attention.threatened and attention.defense_urgency >= 80) else 0

        # 1) SCV scout early
        if not awareness.intel.scv_dispatched:
            out.append(
                Proposal(
                    domain="INTEL",
                    score=max(1, 70 - threat_penalty),
                    task=self.scout_task,
                    reason="need_first_scout_main",
                )
            )

        # 2) scan quando orbital estiver pronto (derivado em attention)
        if (not awareness.intel.scanned_enemy_main) and attention.orbital_ready_to_scan:
            target, label, map_source = self._choose_scan_target(bot, attention)

            if self._scan_task is None or self._scan_label != label:
                self._scan_task = ScanAt(awareness=awareness, target=target, label=label, cooldown=20.0)
                self._scan_label = label

            out.append(
                Proposal(
                    domain="INTEL",
                    score=max(1, 85 - threat_penalty),
                    task=self._scan_task,
                    reason=f"orbital_ready_scan_{label}_src={map_source}",
                )
            )

        return out
```

# bot/planners/proposals.py
```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional, Protocol

from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.tasks.base import Task


class Planner(Protocol):
    planner_id: str

    def propose(self, bot, *, awareness: Awareness, attention: Attention) -> list["Proposal"]:
        ...


@dataclass(frozen=True)
class Proposal:
    domain: str
    score: int
    task: Task
    reason: Optional[str] = None
```

# bot/tasks/__init__.py
```python

```

# bot/tasks/base.py
```python
from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Protocol

from bot.mind.attention import Attention


class TaskStatus(str, Enum):
    ACTIVE = "ACTIVE"
    PAUSED = "PAUSED"
    DONE = "DONE"


@dataclass(frozen=True)
class TaskTick:
    iteration: int
    time: float


class Task(Protocol):
    task_id: str
    domain: str
    status: TaskStatus
    commitment: int

    def evaluate(self, bot, attention: Attention) -> int: ...
    async def step(self, bot, tick: TaskTick, attention: Attention) -> bool: ...

    async def pause(self, bot, reason: str) -> None: ...
    async def abort(self, bot, reason: str) -> None: ...
    def is_done(self) -> bool: ...
```

# bot/tasks/defend.py
```python
from __future__ import annotations

from sc2.ids.unit_typeid import UnitTypeId as U

from bot.mind.attention import Attention
from bot.tasks.base import TaskStatus, TaskTick


class Defend:
    task_id = "defend_bases"
    domain = "DEFENSE"
    commitment = 90
    status = TaskStatus.ACTIVE

    def is_done(self) -> bool:
        return False

    def evaluate(self, bot, attention: Attention) -> int:
        if not attention.threatened or not attention.threat_pos:
            return 0
        return 50 + int(attention.defense_urgency)

    async def pause(self, bot, reason: str) -> None:
        bot.log.emit("defend_pause_ignored", {"reason": reason})

    async def abort(self, bot, reason: str) -> None:
        bot.log.emit("defend_abort_ignored", {"reason": reason})

    async def step(self, bot, tick: TaskTick, attention: Attention) -> bool:
        if not attention.threatened or not attention.threat_pos:
            return False

        defenders = bot.units.of_type(
            {
                U.MARINE,
                U.MARAUDER,
                U.SIEGETANK,
                U.SIEGETANKSIEGED,
                U.HELLION,
                U.CYCLONE,
                U.THOR,
                U.THORAP,
                U.MEDIVAC,
            }
        )
        if defenders.amount == 0:
            return False

        local = defenders.closer_than(45, attention.threat_pos)
        if local.amount == 0:
            local = defenders

        medivacs = local(U.MEDIVAC)
        army = local - medivacs

        issued = False
        for u in army:
            if u.is_idle:
                u.attack(attention.threat_pos)
                issued = True

        for m in medivacs:
            if m.is_idle:
                m.move(attention.threat_pos.towards(bot.start_location, 6))
                issued = True

        if issued and tick.iteration % 11 == 0:
            bot.log.emit(
                "defend_tick",
                {
                    "iteration": tick.iteration,
                    "time": round(bot.time, 2),
                    "enemy_count": int(attention.enemy_count_near_bases),
                    "urgency": int(attention.defense_urgency),
                    "pos": [round(attention.threat_pos.x, 1), round(attention.threat_pos.y, 1)],
                },
            )

        return issued
```

# bot/tasks/scan.py
```python
from __future__ import annotations

from dataclasses import dataclass

from sc2.ids.ability_id import AbilityId as A
from sc2.ids.unit_typeid import UnitTypeId as U
from sc2.position import Point2

from bot.mind.attention import Attention
from bot.mind.awareness import Awareness
from bot.tasks.base import TaskStatus, TaskTick


@dataclass
class ScanState:
    done: bool = False


class ScanAt:
    task_id = "scan_at_once"
    domain = "INTEL"
    commitment = 5
    status = TaskStatus.ACTIVE

    def __init__(self, *, awareness: Awareness, target: Point2, label: str, cooldown: float = 20.0):
        self.awareness = awareness
        self.target = target
        self.label = str(label)
        self.cooldown = float(cooldown)
        self.state = ScanState()

    def is_done(self) -> bool:
        return self.status == TaskStatus.DONE or self.state.done

    def evaluate(self, bot, attention: Attention) -> int:
        return 0 if self.is_done() else 1

    async def pause(self, bot, reason: str) -> None:
        self.status = TaskStatus.PAUSED
        bot.log.emit("scan_paused", {"reason": reason, "label": self.label})

    async def abort(self, bot, reason: str) -> None:
        self.status = TaskStatus.DONE
        bot.log.emit("scan_aborted", {"reason": reason, "time": round(bot.time, 2), "label": self.label})

    async def step(self, bot, tick: TaskTick, attention: Attention) -> bool:
        if self.is_done():
            return False

        now = float(bot.time)

        if (now - float(self.awareness.intel.last_scan_at)) < self.cooldown:
            return False

        # usa o sinal derivado (mais limpo)
        if not attention.orbital_ready_to_scan:
            return False

        orbitals = bot.structures(U.ORBITALCOMMAND).ready
        if orbitals.amount == 0:
            return False
        oc = orbitals.first

        oc(A.SCANNERSWEEP, self.target)

        # persistência
        if self.label == "enemy_main":
            self.awareness.intel.scanned_enemy_main = True
        self.awareness.intel.last_scan_at = now

        self.state.done = True
        self.status = TaskStatus.DONE

        bot.log.emit(
            "scan_cast",
            {
                "iteration": tick.iteration,
                "time": round(now, 2),
                "label": self.label,
                "target": [round(self.target.x, 1), round(self.target.y, 1)],
                "orbital_energy": float(attention.orbital_energy),
            },
        )
        return True
```

# bot/tasks/scout.py
```python
#bot/tasks/scout.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

from ares.consts import UnitRole
from sc2.unit import Unit

from bot.mind.signals import Signals
from bot.infra.unit_leases import UnitLeases
from bot.tasks.base import TaskStatus, TaskTick


@dataclass
class ScoutState:
    dispatched: bool = False
    arrived: bool = False
    scout_tag: Optional[int] = None
    last_seen_log_at: float = 0.0


class Scout:
    task_id = "scout_worker_main"
    domain = "INTEL"
    commitment = 10
    status = TaskStatus.ACTIVE

    def __init__(
        self,
        *,
        leases: UnitLeases,
        world,
        trigger_time: float = 25.0,
        log_every: float = 6.0,
        see_radius: float = 14.0,
    ):
        self.leases = leases
        self.world = world
        self.trigger_time = trigger_time
        self.log_every = log_every
        self.see_radius = see_radius
        self.state = ScoutState()

    def is_done(self) -> bool:
        return self.status == TaskStatus.DONE

    def _get_scout(self, bot) -> Optional[Unit]:
        if self.state.scout_tag is None:
            return None
        return bot.units.find_by_tag(self.state.scout_tag)

    def evaluate(self, bot, signals: Signals) -> int:
        if signals.threatened and signals.defense_urgency >= 70:
            return 1
        # se já despachou, baixa muito o score (deixa scheduler rodar outras coisas)
        if self.state.dispatched:
            return 2
        return 20

    async def pause(self, bot, reason: str) -> None:
        self.status = TaskStatus.PAUSED
        bot.log.emit("scout_paused", {"reason": reason})

    async def abort(self, bot, reason: str) -> None:
        tag = int(self.state.scout_tag) if self.state.scout_tag is not None else None
        if self.state.scout_tag is not None:
            self.leases.release_owner(task_id=self.task_id)
        self.status = TaskStatus.DONE
        bot.log.emit("scout_aborted", {"reason": reason, "time": round(bot.time, 2), "scout_tag": tag})

    async def step(self, bot, tick: TaskTick, signals: Signals) -> bool:
        if self.status == TaskStatus.DONE:
            return False

        if self.status == TaskStatus.PAUSED:
            if signals.defense_urgency < 50:
                self.status = TaskStatus.ACTIVE
                bot.log.emit("scout_resumed", {"time": round(bot.time, 2)})
            else:
                return False

        target, source = bot.ares.map.enemy_main()
        if source != "ENEMY_START" and tick.iteration % 44 == 0:
            bot.log.emit("map_fallback", {"source": source, "time": round(bot.time, 2)})

        # 1) disparo
        if not self.state.dispatched:
            if bot.time < self.trigger_time:
                return False

            worker: Unit = bot.ares.roles.request_worker_scout(target_position=target)

            now = float(bot.time)
            ok = self.leases.claim(
                task_id=self.task_id,
                unit_tag=int(worker.tag),
                role=UnitRole.BUILD_RUNNER_SCOUT,
                now=now,
                ttl=10.0,
                force=False,
            )
            if not ok:
                return False

            worker.move(target)

            self.state.dispatched = True
            self.state.scout_tag = worker.tag

            # world-state
            self.world.intel.scv_dispatched = True
            self.world.intel.last_scv_dispatch_at = now

            bot.log.emit(
                "scout_dispatch",
                {
                    "iteration": tick.iteration,
                    "time": round(now, 2),
                    "scout_tag": int(worker.tag),
                    "target": [round(target.x, 1), round(target.y, 1)],
                    "trigger_time": self.trigger_time,
                    "map_source": source,
                },
            )
            return True

        # 2) pós-dispatch
        scout = self._get_scout(bot)
        if scout is None:
            await self.abort(bot, reason="scout_missing")
            return False

        self.leases.touch(task_id=self.task_id, unit_tag=int(scout.tag), now=float(bot.time), ttl=10.0)

        if (not self.state.arrived) and scout.distance_to(target) <= 8:
            self.state.arrived = True

            # world-state
            self.world.intel.scv_arrived_main = True

            bot.log.emit(
                "scout_arrived",
                {
                    "iteration": tick.iteration,
                    "time": round(bot.time, 2),
                    "scout_tag": int(scout.tag),
                    "pos": [round(scout.position.x, 1), round(scout.position.y, 1)],
                },
            )

        if (bot.time - self.state.last_seen_log_at) >= self.log_every:
            self.state.last_seen_log_at = bot.time
            seen = bot.enemy_structures.closer_than(self.see_radius, scout.position)
            bot.log.emit(
                "scout_seen_structures",
                {
                    "iteration": tick.iteration,
                    "time": round(bot.time, 2),
                    "scout_tag": int(scout.tag),
                    "scout_pos": [round(scout.position.x, 1), round(scout.position.y, 1)],
                    "count": int(seen.amount),
                    "types": [s.type_id.name for s in seen],
                },
            )

        return False
```

===== terran_builds.yml (ROOT) =====

# terran_builds.yml
```yaml
UseData: False
BuildSelection: Cycle
MinGamesWinrateBased: 3

BuildChoices:
  Protoss:
    BotName: MyBot
    Cycle:
      - Default
  Terran:
    BotName: MyBot
    Cycle:
      - Default
  Zerg:
    BotName: MyBot
    Cycle:
      - Default
  Random:
    BotName: MyBot
    Cycle:
      - Default

Builds:
  Default:
    ConstantWorkerProductionTill: 20
    AutoSupplyAtSupply: 16
    OpeningBuildOrder:
      - 14 supply @ ramp
      - 16 barracks @ ramp
      - 16 gas
      - 0 orbital
      - 19 expand
      - 20 marine *2
      - 1 factory
      - 21 gas
      - 1 starport
```
